CCS PCH C Compiler, Version 4.140, 22098               22-ago-14 10:28

               Filename:   D:\Projetos\Serial\master.lst

               ROM used:   1848 bytes (6%)
                           Largest free fragment is 30920
               RAM used:   66 (4%) at main() level
                           89 (6%) worst case
               Stack:     3 locations

*
0000:  GOTO   069A
.................... /* 
....................  * master.c 
....................  * 
....................  *  Created on: 18/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #include<18F252.h> 
.................... //////// Standard Header file for the PIC18F252 device //////////////// 
.................... #device PIC18F252 
.................... #list 
....................  
.................... #zero_ram 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0210:  CLRF   4D
....................    sign = 0; 
0212:  CLRF   4B
....................    base = 10; 
0214:  MOVLW  0A
0216:  MOVWF  4C
....................    result = 0; 
0218:  CLRF   4A
....................  
....................    if (!s) 
021A:  MOVF   48,W
021C:  IORWF  49,W
021E:  BNZ   0226
....................       return 0; 
0220:  MOVLW  00
0222:  MOVWF  01
0224:  BRA    03A8
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0226:  MOVF   4D,W
0228:  INCF   4D,F
022A:  CLRF   03
022C:  ADDWF  48,W
022E:  MOVWF  FE9
0230:  MOVF   49,W
0232:  ADDWFC 03,W
0234:  MOVWF  FEA
0236:  MOVFF  FEF,4E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
023A:  MOVF   4E,W
023C:  SUBLW  2D
023E:  BNZ   025A
....................    { 
....................       sign = 1;         // Set the sign to negative 
0240:  MOVLW  01
0242:  MOVWF  4B
....................       c = s[index++]; 
0244:  MOVF   4D,W
0246:  INCF   4D,F
0248:  CLRF   03
024A:  ADDWF  48,W
024C:  MOVWF  FE9
024E:  MOVF   49,W
0250:  ADDWFC 03,W
0252:  MOVWF  FEA
0254:  MOVFF  FEF,4E
....................    } 
....................    else if (c == '+') 
0258:  BRA    0274
025A:  MOVF   4E,W
025C:  SUBLW  2B
025E:  BNZ   0274
....................    { 
....................       c = s[index++]; 
0260:  MOVF   4D,W
0262:  INCF   4D,F
0264:  CLRF   03
0266:  ADDWF  48,W
0268:  MOVWF  FE9
026A:  MOVF   49,W
026C:  ADDWFC 03,W
026E:  MOVWF  FEA
0270:  MOVFF  FEF,4E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0274:  MOVF   4E,W
0276:  SUBLW  2F
0278:  BTFSC  FD8.0
027A:  BRA    0398
027C:  MOVF   4E,W
027E:  SUBLW  39
0280:  BTFSS  FD8.0
0282:  BRA    0398
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0284:  MOVF   4E,W
0286:  SUBLW  30
0288:  BNZ   02CC
028A:  CLRF   03
028C:  MOVF   4D,W
028E:  ADDWF  48,W
0290:  MOVWF  FE9
0292:  MOVF   49,W
0294:  ADDWFC 03,W
0296:  MOVWF  FEA
0298:  MOVF   FEF,W
029A:  SUBLW  78
029C:  BZ    02B2
029E:  CLRF   03
02A0:  MOVF   4D,W
02A2:  ADDWF  48,W
02A4:  MOVWF  FE9
02A6:  MOVF   49,W
02A8:  ADDWFC 03,W
02AA:  MOVWF  FEA
02AC:  MOVF   FEF,W
02AE:  SUBLW  58
02B0:  BNZ   02CC
....................       { 
....................          base = 16; 
02B2:  MOVLW  10
02B4:  MOVWF  4C
....................          index++; 
02B6:  INCF   4D,F
....................          c = s[index++]; 
02B8:  MOVF   4D,W
02BA:  INCF   4D,F
02BC:  CLRF   03
02BE:  ADDWF  48,W
02C0:  MOVWF  FE9
02C2:  MOVF   49,W
02C4:  ADDWFC 03,W
02C6:  MOVWF  FEA
02C8:  MOVFF  FEF,4E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
02CC:  MOVF   4C,W
02CE:  SUBLW  0A
02D0:  BNZ   0308
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
02D2:  MOVF   4E,W
02D4:  SUBLW  2F
02D6:  BC    0306
02D8:  MOVF   4E,W
02DA:  SUBLW  39
02DC:  BNC   0306
....................             result = 10*result + (c - '0'); 
02DE:  MOVLW  0A
02E0:  MOVWF  4F
02E2:  MOVFF  4A,50
02E6:  BRA    01C4
02E8:  MOVLW  30
02EA:  SUBWF  4E,W
02EC:  ADDWF  01,W
02EE:  MOVWF  4A
....................             c = s[index++]; 
02F0:  MOVF   4D,W
02F2:  INCF   4D,F
02F4:  CLRF   03
02F6:  ADDWF  48,W
02F8:  MOVWF  FE9
02FA:  MOVF   49,W
02FC:  ADDWFC 03,W
02FE:  MOVWF  FEA
0300:  MOVFF  FEF,4E
....................          } 
0304:  BRA    02D2
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0306:  BRA    0398
0308:  MOVF   4C,W
030A:  SUBLW  10
030C:  BNZ   0398
....................       { 
....................          c = toupper(c); 
030E:  MOVF   4E,W
0310:  SUBLW  60
0312:  BC    0320
0314:  MOVF   4E,W
0316:  SUBLW  7A
0318:  BNC   0320
031A:  MOVF   4E,W
031C:  ANDLW  DF
031E:  BRA    0322
0320:  MOVF   4E,W
0322:  MOVWF  4E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
0324:  MOVF   4E,W
0326:  SUBLW  2F
0328:  BC    0330
032A:  MOVF   4E,W
032C:  SUBLW  39
032E:  BC    033C
0330:  MOVF   4E,W
0332:  SUBLW  40
0334:  BC    0398
0336:  MOVF   4E,W
0338:  SUBLW  46
033A:  BNC   0398
....................             if (c >= '0' && c <= '9') 
033C:  MOVF   4E,W
033E:  SUBLW  2F
0340:  BC    035A
0342:  MOVF   4E,W
0344:  SUBLW  39
0346:  BNC   035A
....................                result = (result << 4) + (c - '0'); 
0348:  SWAPF  4A,W
034A:  MOVWF  4F
034C:  MOVLW  F0
034E:  ANDWF  4F,F
0350:  MOVLW  30
0352:  SUBWF  4E,W
0354:  ADDWF  4F,W
0356:  MOVWF  4A
....................             else 
0358:  BRA    036C
....................                result = (result << 4) + (c - 'A' + 10); 
035A:  SWAPF  4A,W
035C:  MOVWF  4F
035E:  MOVLW  F0
0360:  ANDWF  4F,F
0362:  MOVLW  41
0364:  SUBWF  4E,W
0366:  ADDLW  0A
0368:  ADDWF  4F,W
036A:  MOVWF  4A
....................  
....................             c = s[index++]; 
036C:  MOVF   4D,W
036E:  INCF   4D,F
0370:  CLRF   03
0372:  ADDWF  48,W
0374:  MOVWF  FE9
0376:  MOVF   49,W
0378:  ADDWFC 03,W
037A:  MOVWF  FEA
037C:  MOVFF  FEF,4E
....................             c = toupper(c); 
0380:  MOVF   4E,W
0382:  SUBLW  60
0384:  BC    0392
0386:  MOVF   4E,W
0388:  SUBLW  7A
038A:  BNC   0392
038C:  MOVF   4E,W
038E:  ANDLW  DF
0390:  BRA    0394
0392:  MOVF   4E,W
0394:  MOVWF  4E
....................          } 
0396:  BRA    0324
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0398:  DECFSZ 4B,W
039A:  BRA    03A4
039C:  MOVF   4C,W
039E:  SUBLW  0A
03A0:  BNZ   03A4
....................        result = -result; 
03A2:  NEGF   4A
....................  
....................    return(result); 
03A4:  MOVFF  4A,01
.................... } 
03A8:  GOTO   03DC (RETURN)
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0434:  CLRF   51
....................    sign = 0; 
0436:  CLRF   4F
....................    base = 10; 
0438:  MOVLW  0A
043A:  MOVWF  50
....................    result = 0; 
043C:  CLRF   4E
043E:  CLRF   4D
....................  
....................    if (!s) 
0440:  MOVF   4B,W
0442:  IORWF  4C,W
0444:  BNZ   044E
....................       return 0; 
0446:  MOVLW  00
0448:  MOVWF  01
044A:  MOVWF  02
044C:  BRA    061C
....................    c = s[index++]; 
044E:  MOVF   51,W
0450:  INCF   51,F
0452:  CLRF   03
0454:  ADDWF  4B,W
0456:  MOVWF  FE9
0458:  MOVF   4C,W
045A:  ADDWFC 03,W
045C:  MOVWF  FEA
045E:  MOVFF  FEF,52
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0462:  MOVF   52,W
0464:  SUBLW  2D
0466:  BNZ   0482
....................    { 
....................       sign = 1;         // Set the sign to negative 
0468:  MOVLW  01
046A:  MOVWF  4F
....................       c = s[index++]; 
046C:  MOVF   51,W
046E:  INCF   51,F
0470:  CLRF   03
0472:  ADDWF  4B,W
0474:  MOVWF  FE9
0476:  MOVF   4C,W
0478:  ADDWFC 03,W
047A:  MOVWF  FEA
047C:  MOVFF  FEF,52
....................    } 
....................    else if (c == '+') 
0480:  BRA    049C
0482:  MOVF   52,W
0484:  SUBLW  2B
0486:  BNZ   049C
....................    { 
....................       c = s[index++]; 
0488:  MOVF   51,W
048A:  INCF   51,F
048C:  CLRF   03
048E:  ADDWF  4B,W
0490:  MOVWF  FE9
0492:  MOVF   4C,W
0494:  ADDWFC 03,W
0496:  MOVWF  FEA
0498:  MOVFF  FEF,52
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
049C:  MOVF   52,W
049E:  SUBLW  2F
04A0:  BTFSC  FD8.0
04A2:  BRA    0600
04A4:  MOVF   52,W
04A6:  SUBLW  39
04A8:  BTFSS  FD8.0
04AA:  BRA    0600
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
04AC:  MOVF   52,W
04AE:  SUBLW  30
04B0:  BNZ   04F4
04B2:  CLRF   03
04B4:  MOVF   51,W
04B6:  ADDWF  4B,W
04B8:  MOVWF  FE9
04BA:  MOVF   4C,W
04BC:  ADDWFC 03,W
04BE:  MOVWF  FEA
04C0:  MOVF   FEF,W
04C2:  SUBLW  78
04C4:  BZ    04DA
04C6:  CLRF   03
04C8:  MOVF   51,W
04CA:  ADDWF  4B,W
04CC:  MOVWF  FE9
04CE:  MOVF   4C,W
04D0:  ADDWFC 03,W
04D2:  MOVWF  FEA
04D4:  MOVF   FEF,W
04D6:  SUBLW  58
04D8:  BNZ   04F4
....................       { 
....................          base = 16; 
04DA:  MOVLW  10
04DC:  MOVWF  50
....................          index++; 
04DE:  INCF   51,F
....................          c = s[index++]; 
04E0:  MOVF   51,W
04E2:  INCF   51,F
04E4:  CLRF   03
04E6:  ADDWF  4B,W
04E8:  MOVWF  FE9
04EA:  MOVF   4C,W
04EC:  ADDWFC 03,W
04EE:  MOVWF  FEA
04F0:  MOVFF  FEF,52
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
04F4:  MOVF   50,W
04F6:  SUBLW  0A
04F8:  BNZ   053C
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
04FA:  MOVF   52,W
04FC:  SUBLW  2F
04FE:  BC    053A
0500:  MOVF   52,W
0502:  SUBLW  39
0504:  BNC   053A
....................             result = 10*result + (c - '0'); 
0506:  CLRF   54
0508:  MOVLW  0A
050A:  MOVWF  53
050C:  MOVFF  4E,56
0510:  MOVFF  4D,55
0514:  BRA    03E2
0516:  MOVLW  30
0518:  SUBWF  52,W
051A:  ADDWF  01,W
051C:  MOVWF  4D
051E:  MOVLW  00
0520:  ADDWFC 02,W
0522:  MOVWF  4E
....................             c = s[index++]; 
0524:  MOVF   51,W
0526:  INCF   51,F
0528:  CLRF   03
052A:  ADDWF  4B,W
052C:  MOVWF  FE9
052E:  MOVF   4C,W
0530:  ADDWFC 03,W
0532:  MOVWF  FEA
0534:  MOVFF  FEF,52
....................          } 
0538:  BRA    04FA
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
053A:  BRA    0600
053C:  MOVF   50,W
053E:  SUBLW  10
0540:  BNZ   0600
....................       { 
....................          c = toupper(c); 
0542:  MOVF   52,W
0544:  SUBLW  60
0546:  BC    0554
0548:  MOVF   52,W
054A:  SUBLW  7A
054C:  BNC   0554
054E:  MOVF   52,W
0550:  ANDLW  DF
0552:  BRA    0556
0554:  MOVF   52,W
0556:  MOVWF  52
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
0558:  MOVF   52,W
055A:  SUBLW  2F
055C:  BC    0564
055E:  MOVF   52,W
0560:  SUBLW  39
0562:  BC    0570
0564:  MOVF   52,W
0566:  SUBLW  40
0568:  BC    0600
056A:  MOVF   52,W
056C:  SUBLW  46
056E:  BNC   0600
....................             if (c >= '0' && c <= '9') 
0570:  MOVF   52,W
0572:  SUBLW  2F
0574:  BC    05A8
0576:  MOVF   52,W
0578:  SUBLW  39
057A:  BNC   05A8
....................                result = (result << 4) + (c - '0'); 
057C:  RLCF   4D,W
057E:  MOVWF  53
0580:  RLCF   4E,W
0582:  MOVWF  54
0584:  RLCF   53,F
0586:  RLCF   54,F
0588:  RLCF   53,F
058A:  RLCF   54,F
058C:  RLCF   53,F
058E:  RLCF   54,F
0590:  MOVLW  F0
0592:  ANDWF  53,F
0594:  MOVLW  30
0596:  SUBWF  52,W
0598:  ADDWF  53,W
059A:  MOVWF  01
059C:  MOVLW  00
059E:  ADDWFC 54,W
05A0:  MOVFF  01,4D
05A4:  MOVWF  4E
....................             else 
05A6:  BRA    05D4
....................                result = (result << 4) + (c - 'A' + 10); 
05A8:  RLCF   4D,W
05AA:  MOVWF  53
05AC:  RLCF   4E,W
05AE:  MOVWF  54
05B0:  RLCF   53,F
05B2:  RLCF   54,F
05B4:  RLCF   53,F
05B6:  RLCF   54,F
05B8:  RLCF   53,F
05BA:  RLCF   54,F
05BC:  MOVLW  F0
05BE:  ANDWF  53,F
05C0:  MOVLW  41
05C2:  SUBWF  52,W
05C4:  ADDLW  0A
05C6:  ADDWF  53,W
05C8:  MOVWF  01
05CA:  MOVLW  00
05CC:  ADDWFC 54,W
05CE:  MOVFF  01,4D
05D2:  MOVWF  4E
....................  
....................             c = s[index++];c = toupper(c); 
05D4:  MOVF   51,W
05D6:  INCF   51,F
05D8:  CLRF   03
05DA:  ADDWF  4B,W
05DC:  MOVWF  FE9
05DE:  MOVF   4C,W
05E0:  ADDWFC 03,W
05E2:  MOVWF  FEA
05E4:  MOVFF  FEF,52
05E8:  MOVF   52,W
05EA:  SUBLW  60
05EC:  BC    05FA
05EE:  MOVF   52,W
05F0:  SUBLW  7A
05F2:  BNC   05FA
05F4:  MOVF   52,W
05F6:  ANDLW  DF
05F8:  BRA    05FC
05FA:  MOVF   52,W
05FC:  MOVWF  52
....................          } 
05FE:  BRA    0558
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0600:  MOVF   50,W
0602:  SUBLW  0A
0604:  BNZ   0614
0606:  DECFSZ 4F,W
0608:  BRA    0614
....................       result = -result; 
060A:  COMF   4D,F
060C:  COMF   4E,F
060E:  INCF   4D,F
0610:  BTFSC  FD8.2
0612:  INCF   4E,F
....................  
....................    return(result); 
0614:  MOVFF  4D,01
0618:  MOVFF  4E,02
.................... } 
061C:  GOTO   0694 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS 
.................... #use delay(clock=15MHz) 
*
0098:  CLRF   FEA
009A:  MOVLW  45
009C:  MOVWF  FE9
009E:  MOVF   FEF,W
00A0:  BZ    00BE
00A2:  MOVLW  04
00A4:  MOVWF  01
00A6:  CLRF   00
00A8:  DECFSZ 00,F
00AA:  BRA    00A8
00AC:  DECFSZ 01,F
00AE:  BRA    00A6
00B0:  MOVLW  DC
00B2:  MOVWF  00
00B4:  DECFSZ 00,F
00B6:  BRA    00B4
00B8:  NOP   
00BA:  DECFSZ FEF,F
00BC:  BRA    00A2
00BE:  RETURN 0
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................  
.................... #include "defines.c" 
.................... /* 
....................  * defines.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #define cmd_parar	0x00 
.................... #define cmd_subir	0x01 
.................... #define cmd_descer	0x02 
.................... #define cmd_r		0x04 
.................... #define cmd_w		0x05 
....................  
.................... #define bto_sobe	PIN_B0 
.................... #define bto_desce	PIN_B1 
....................  
.................... #define debounce 	100 
.................... #define nrMax		16 
.................... #define buffer_size	16 
....................  
....................  
.................... short ctrl_bto; 
....................  
.................... int m_cmd; 
.................... int nrSlv = 1; 
.................... int i; 
.................... int r_addr = 0xFF; 
.................... int r_cmd = 0xFF; 
....................  
.................... int buffer[buffer_size]; 
....................  
.................... long pos_r; 
.................... long pos_slv[nrMax]; 
....................  
.................... #include "funcoes.c" 
.................... /* 
....................  * funcoes.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... int send_cmd(int cmd) { 
.................... 	printf("%02u%02u\r\n", 0, cmd); 
.................... 	delay_ms(100); 
.................... 	return cmd; 
.................... } 
....................  
.................... int getAddr(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
*
03AC:  MOVFF  43,45
03B0:  MOVFF  42,44
....................  
.................... 	aux[0] = *p; 
03B4:  MOVFF  44,FE9
03B8:  MOVFF  45,FEA
03BC:  MOVFF  FEF,46
.................... 	aux[1] = *(p + 1); 
03C0:  MOVLW  01
03C2:  ADDWF  44,W
03C4:  MOVWF  01
03C6:  MOVLW  00
03C8:  ADDWFC 45,W
03CA:  MOVFF  01,FE9
03CE:  MOVWF  FEA
03D0:  MOVFF  FEF,47
....................  
.................... 	return atoi(aux); 
03D4:  CLRF   49
03D6:  MOVLW  46
03D8:  MOVWF  48
03DA:  BRA    0210
03DC:  MOVF   01,W
.................... } 
03DE:  GOTO   0716 (RETURN)
....................  
.................... int getCmd(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
....................  
.................... 	aux[0] = *(p + 2); 
.................... 	aux[1] = *(p + 3); 
....................  
.................... 	return atoi(aux); 
.................... } 
....................  
.................... long getPos(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[5]; 
....................  
.................... 	p = str; 
*
0620:  MOVFF  43,45
0624:  MOVFF  42,44
....................  
.................... 	aux[0] = *(p + 2); 
0628:  MOVLW  02
062A:  ADDWF  44,W
062C:  MOVWF  01
062E:  MOVLW  00
0630:  ADDWFC 45,W
0632:  MOVFF  01,FE9
0636:  MOVWF  FEA
0638:  MOVFF  FEF,46
.................... 	aux[1] = *(p + 3); 
063C:  MOVLW  03
063E:  ADDWF  44,W
0640:  MOVWF  01
0642:  MOVLW  00
0644:  ADDWFC 45,W
0646:  MOVFF  01,FE9
064A:  MOVWF  FEA
064C:  MOVFF  FEF,47
.................... 	aux[2] = *(p + 4); 
0650:  MOVLW  04
0652:  ADDWF  44,W
0654:  MOVWF  01
0656:  MOVLW  00
0658:  ADDWFC 45,W
065A:  MOVFF  01,FE9
065E:  MOVWF  FEA
0660:  MOVFF  FEF,48
.................... 	aux[3] = *(p + 5); 
0664:  MOVLW  05
0666:  ADDWF  44,W
0668:  MOVWF  01
066A:  MOVLW  00
066C:  ADDWFC 45,W
066E:  MOVFF  01,FE9
0672:  MOVWF  FEA
0674:  MOVFF  FEF,49
.................... 	aux[4] = *(p + 6); 
0678:  MOVLW  06
067A:  ADDWF  44,W
067C:  MOVWF  01
067E:  MOVLW  00
0680:  ADDWFC 45,W
0682:  MOVFF  01,FE9
0686:  MOVWF  FEA
0688:  MOVFF  FEF,4A
....................  
.................... 	return atol(aux); 
068C:  CLRF   4C
068E:  MOVLW  46
0690:  MOVWF  4B
0692:  BRA    0434
0694:  MOVF   02,W
....................  
.................... } 
0696:  GOTO   0722 (RETURN)
....................  
.................... int trata_bto() { 
.................... 	short sobe = !input(bto_sobe); 
.................... 	short desce = !input(bto_desce); 
.................... 	int ret = 0xFF; 
....................  
.................... 	if (sobe ^ desce) { 
.................... 		if (!ctrl_bto) { 
.................... 			delay_ms(debounce); 
.................... 			if (!input(bto_sobe)) 
.................... 				ret = send_cmd(cmd_subir); 
.................... 			if (!input(bto_desce)) 
.................... 				ret = send_cmd(cmd_descer); 
.................... 			ctrl_bto = TRUE; 
.................... 		} 
.................... 	} else if (ctrl_bto) { 
.................... 		ctrl_bto = FALSE; 
.................... 		ret = send_cmd(cmd_parar); 
.................... 	} 
....................  
.................... 	return ret; 
.................... } 
....................  
.................... void send_cmd(int addr, int cmd) { 
.................... 	printf("%02u%02u\n\r", addr, cmd); 
*
00C0:  MOVFF  42,45
00C4:  MOVLW  01
00C6:  MOVWF  46
00C8:  RCALL  002C
00CA:  MOVFF  43,45
00CE:  MOVLW  01
00D0:  MOVWF  46
00D2:  RCALL  002C
00D4:  MOVLW  0A
00D6:  BTFSS  F9E.4
00D8:  BRA    00D6
00DA:  MOVWF  FAD
00DC:  MOVLW  0D
00DE:  BTFSS  F9E.4
00E0:  BRA    00DE
00E2:  MOVWF  FAD
.................... 	delay_ms(20); 
00E4:  MOVLW  14
00E6:  MOVWF  45
00E8:  RCALL  0098
.................... } 
00EA:  RETURN 0
....................  
.................... void send_pos(int addr, long pos) { 
.................... 	printf("%02u%05lu\n\r", addr, pos); 
*
0192:  MOVFF  42,45
0196:  MOVLW  01
0198:  MOVWF  46
019A:  RCALL  002C
019C:  MOVLW  08
019E:  MOVWF  FE9
01A0:  MOVFF  44,46
01A4:  MOVFF  43,45
01A8:  BRA    00EC
01AA:  MOVLW  0A
01AC:  BTFSS  F9E.4
01AE:  BRA    01AC
01B0:  MOVWF  FAD
01B2:  MOVLW  0D
01B4:  BTFSS  F9E.4
01B6:  BRA    01B4
01B8:  MOVWF  FAD
.................... 	delay_ms(20); 
01BA:  MOVLW  14
01BC:  MOVWF  45
01BE:  RCALL  0098
.................... } 
01C0:  GOTO   06EC (RETURN)
....................  
....................  
.................... int main(void) { 
*
069A:  CLRF   FF8
069C:  BCF    FD0.7
069E:  MOVLW  FE
06A0:  MOVWF  00
06A2:  MOVLW  06
06A4:  MOVWF  01
06A6:  MOVLW  02
06A8:  MOVWF  FE9
06AA:  MOVLW  00
06AC:  MOVWF  FEA
06AE:  CLRF   FEE
06B0:  DECFSZ 00,F
06B2:  BRA    06AE
06B4:  DECFSZ 01,F
06B6:  BRA    06AE
06B8:  CLRF   FEA
06BA:  CLRF   FE9
06BC:  MOVLW  61
06BE:  MOVWF  FAF
06C0:  MOVLW  A6
06C2:  MOVWF  FAC
06C4:  MOVLW  90
06C6:  MOVWF  FAB
06C8:  MOVLW  01
06CA:  MOVWF  0C
06CC:  SETF   0E
06CE:  SETF   0F
06D0:  BSF    FC1.0
06D2:  BSF    FC1.1
06D4:  BSF    FC1.2
06D6:  BCF    FC1.3
....................  
.................... 	while (TRUE) { 
.................... //		m_cmd = trata_bto(); 
.................... //		if (m_cmd == cmd_subir || m_cmd == cmd_descer) { 
.................... //			delay_ms(20); 
.................... //			for (i = 1; i <= nrSlv; ++i) { 
.................... //				printf("%02u%02u\r\n", i, cmd_r); 
.................... //				gets(buffer); 
.................... //				pos_r = getPos(buffer); 
.................... //				pos_slv[i] = pos_r; 
.................... //			} 
.................... //		} 
.................... 		send_cmd(0, cmd_w); 
06D8:  CLRF   42
06DA:  MOVLW  05
06DC:  MOVWF  43
06DE:  RCALL  00C0
.................... 		send_pos(0, 12345); 
06E0:  CLRF   42
06E2:  MOVLW  30
06E4:  MOVWF  44
06E6:  MOVLW  39
06E8:  MOVWF  43
06EA:  BRA    0192
.................... 		send_cmd(1, cmd_r); 
06EC:  MOVLW  01
06EE:  MOVWF  42
06F0:  MOVLW  04
06F2:  MOVWF  43
06F4:  RCALL  00C0
.................... 		gets(buffer); 
06F6:  CLRF   FEA
06F8:  MOVLW  10
06FA:  MOVWF  FE9
06FC:  DECF   FE9,F
06FE:  BTFSS  F9E.5
0700:  BRA    06FE
0702:  MOVFF  FAE,FEC
0706:  MOVLW  0D
0708:  SUBWF  FEF,W
070A:  BNZ   06FE
070C:  CLRF   FEC
.................... 		r_addr = getAddr(buffer); 
070E:  CLRF   43
0710:  MOVLW  10
0712:  MOVWF  42
0714:  BRA    03AC
0716:  MOVFF  01,0E
.................... 		pos_slv[0] = getPos(buffer); 
071A:  CLRF   43
071C:  MOVLW  10
071E:  MOVWF  42
0720:  BRA    0620
0722:  MOVFF  02,23
0726:  MOVFF  01,22
....................  
.................... 		delay_ms(100); 
072A:  MOVLW  64
072C:  MOVWF  45
072E:  RCALL  0098
.................... 	} 
0730:  BRA    06D8
....................  
.................... 	return 0; 
0732:  MOVLW  00
0734:  MOVWF  01
.................... } 
....................  
0736:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
