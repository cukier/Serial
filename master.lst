CCS PCH C Compiler, Version 4.140, 22098               15-set-14 16:00

               Filename:   D:\Projetos\Serial\master.lst

               ROM used:   2308 bytes (7%)
                           Largest free fragment is 30456
               RAM used:   131 (9%) at main() level
                           162 (11%) worst case
               Stack:     6 worst case (4 in main + 2 for interrupts)

*
0000:  GOTO   0824
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0144
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... /* 
....................  * master.c 
....................  * 
....................  *  Created on: 18/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #include<18F252.h> 
.................... //////// Standard Header file for the PIC18F252 device //////////////// 
.................... #device PIC18F252 
.................... #list 
....................  
.................... #zero_ram 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
055A:  CLRF   x94
....................    sign = 0; 
055C:  CLRF   x92
....................    base = 10; 
055E:  MOVLW  0A
0560:  MOVWF  x93
....................    result = 0; 
0562:  CLRF   x91
0564:  CLRF   x90
....................  
....................    if (!s) 
0566:  MOVF   x8E,W
0568:  IORWF  x8F,W
056A:  BNZ   0574
....................       return 0; 
056C:  MOVLW  00
056E:  MOVWF  01
0570:  MOVWF  02
0572:  BRA    0742
....................    c = s[index++]; 
0574:  MOVF   x94,W
0576:  INCF   x94,F
0578:  CLRF   03
057A:  ADDWF  x8E,W
057C:  MOVWF  FE9
057E:  MOVF   x8F,W
0580:  ADDWFC 03,W
0582:  MOVWF  FEA
0584:  MOVFF  FEF,95
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0588:  MOVF   x95,W
058A:  SUBLW  2D
058C:  BNZ   05A8
....................    { 
....................       sign = 1;         // Set the sign to negative 
058E:  MOVLW  01
0590:  MOVWF  x92
....................       c = s[index++]; 
0592:  MOVF   x94,W
0594:  INCF   x94,F
0596:  CLRF   03
0598:  ADDWF  x8E,W
059A:  MOVWF  FE9
059C:  MOVF   x8F,W
059E:  ADDWFC 03,W
05A0:  MOVWF  FEA
05A2:  MOVFF  FEF,95
....................    } 
....................    else if (c == '+') 
05A6:  BRA    05C2
05A8:  MOVF   x95,W
05AA:  SUBLW  2B
05AC:  BNZ   05C2
....................    { 
....................       c = s[index++]; 
05AE:  MOVF   x94,W
05B0:  INCF   x94,F
05B2:  CLRF   03
05B4:  ADDWF  x8E,W
05B6:  MOVWF  FE9
05B8:  MOVF   x8F,W
05BA:  ADDWFC 03,W
05BC:  MOVWF  FEA
05BE:  MOVFF  FEF,95
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
05C2:  MOVF   x95,W
05C4:  SUBLW  2F
05C6:  BTFSC  FD8.0
05C8:  BRA    0726
05CA:  MOVF   x95,W
05CC:  SUBLW  39
05CE:  BTFSS  FD8.0
05D0:  BRA    0726
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
05D2:  MOVF   x95,W
05D4:  SUBLW  30
05D6:  BNZ   061A
05D8:  CLRF   03
05DA:  MOVF   x94,W
05DC:  ADDWF  x8E,W
05DE:  MOVWF  FE9
05E0:  MOVF   x8F,W
05E2:  ADDWFC 03,W
05E4:  MOVWF  FEA
05E6:  MOVF   FEF,W
05E8:  SUBLW  78
05EA:  BZ    0600
05EC:  CLRF   03
05EE:  MOVF   x94,W
05F0:  ADDWF  x8E,W
05F2:  MOVWF  FE9
05F4:  MOVF   x8F,W
05F6:  ADDWFC 03,W
05F8:  MOVWF  FEA
05FA:  MOVF   FEF,W
05FC:  SUBLW  58
05FE:  BNZ   061A
....................       { 
....................          base = 16; 
0600:  MOVLW  10
0602:  MOVWF  x93
....................          index++; 
0604:  INCF   x94,F
....................          c = s[index++]; 
0606:  MOVF   x94,W
0608:  INCF   x94,F
060A:  CLRF   03
060C:  ADDWF  x8E,W
060E:  MOVWF  FE9
0610:  MOVF   x8F,W
0612:  ADDWFC 03,W
0614:  MOVWF  FEA
0616:  MOVFF  FEF,95
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
061A:  MOVF   x93,W
061C:  SUBLW  0A
061E:  BNZ   0662
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0620:  MOVF   x95,W
0622:  SUBLW  2F
0624:  BC    0660
0626:  MOVF   x95,W
0628:  SUBLW  39
062A:  BNC   0660
....................             result = 10*result + (c - '0'); 
062C:  CLRF   x97
062E:  MOVLW  0A
0630:  MOVWF  x96
0632:  MOVFF  91,99
0636:  MOVFF  90,98
063A:  BRA    0508
063C:  MOVLW  30
063E:  SUBWF  x95,W
0640:  ADDWF  01,W
0642:  MOVWF  x90
0644:  MOVLW  00
0646:  ADDWFC 02,W
0648:  MOVWF  x91
....................             c = s[index++]; 
064A:  MOVF   x94,W
064C:  INCF   x94,F
064E:  CLRF   03
0650:  ADDWF  x8E,W
0652:  MOVWF  FE9
0654:  MOVF   x8F,W
0656:  ADDWFC 03,W
0658:  MOVWF  FEA
065A:  MOVFF  FEF,95
....................          } 
065E:  BRA    0620
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0660:  BRA    0726
0662:  MOVF   x93,W
0664:  SUBLW  10
0666:  BNZ   0726
....................       { 
....................          c = toupper(c); 
0668:  MOVF   x95,W
066A:  SUBLW  60
066C:  BC    067A
066E:  MOVF   x95,W
0670:  SUBLW  7A
0672:  BNC   067A
0674:  MOVF   x95,W
0676:  ANDLW  DF
0678:  BRA    067C
067A:  MOVF   x95,W
067C:  MOVWF  x95
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
067E:  MOVF   x95,W
0680:  SUBLW  2F
0682:  BC    068A
0684:  MOVF   x95,W
0686:  SUBLW  39
0688:  BC    0696
068A:  MOVF   x95,W
068C:  SUBLW  40
068E:  BC    0726
0690:  MOVF   x95,W
0692:  SUBLW  46
0694:  BNC   0726
....................             if (c >= '0' && c <= '9') 
0696:  MOVF   x95,W
0698:  SUBLW  2F
069A:  BC    06CE
069C:  MOVF   x95,W
069E:  SUBLW  39
06A0:  BNC   06CE
....................                result = (result << 4) + (c - '0'); 
06A2:  RLCF   x90,W
06A4:  MOVWF  x96
06A6:  RLCF   x91,W
06A8:  MOVWF  x97
06AA:  RLCF   x96,F
06AC:  RLCF   x97,F
06AE:  RLCF   x96,F
06B0:  RLCF   x97,F
06B2:  RLCF   x96,F
06B4:  RLCF   x97,F
06B6:  MOVLW  F0
06B8:  ANDWF  x96,F
06BA:  MOVLW  30
06BC:  SUBWF  x95,W
06BE:  ADDWF  x96,W
06C0:  MOVWF  01
06C2:  MOVLW  00
06C4:  ADDWFC x97,W
06C6:  MOVFF  01,90
06CA:  MOVWF  x91
....................             else 
06CC:  BRA    06FA
....................                result = (result << 4) + (c - 'A' + 10); 
06CE:  RLCF   x90,W
06D0:  MOVWF  x96
06D2:  RLCF   x91,W
06D4:  MOVWF  x97
06D6:  RLCF   x96,F
06D8:  RLCF   x97,F
06DA:  RLCF   x96,F
06DC:  RLCF   x97,F
06DE:  RLCF   x96,F
06E0:  RLCF   x97,F
06E2:  MOVLW  F0
06E4:  ANDWF  x96,F
06E6:  MOVLW  41
06E8:  SUBWF  x95,W
06EA:  ADDLW  0A
06EC:  ADDWF  x96,W
06EE:  MOVWF  01
06F0:  MOVLW  00
06F2:  ADDWFC x97,W
06F4:  MOVFF  01,90
06F8:  MOVWF  x91
....................  
....................             c = s[index++];c = toupper(c); 
06FA:  MOVF   x94,W
06FC:  INCF   x94,F
06FE:  CLRF   03
0700:  ADDWF  x8E,W
0702:  MOVWF  FE9
0704:  MOVF   x8F,W
0706:  ADDWFC 03,W
0708:  MOVWF  FEA
070A:  MOVFF  FEF,95
070E:  MOVF   x95,W
0710:  SUBLW  60
0712:  BC    0720
0714:  MOVF   x95,W
0716:  SUBLW  7A
0718:  BNC   0720
071A:  MOVF   x95,W
071C:  ANDLW  DF
071E:  BRA    0722
0720:  MOVF   x95,W
0722:  MOVWF  x95
....................          } 
0724:  BRA    067E
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0726:  MOVF   x93,W
0728:  SUBLW  0A
072A:  BNZ   073A
072C:  DECFSZ x92,W
072E:  BRA    073A
....................       result = -result; 
0730:  COMF   x90,F
0732:  COMF   x91,F
0734:  INCF   x90,F
0736:  BTFSC  FD8.2
0738:  INCF   x91,F
....................  
....................    return(result); 
073A:  MOVFF  90,01
073E:  MOVFF  91,02
.................... } 
0742:  GOTO   07A2 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS 
.................... #use delay(clock=15MHz) 
*
02FC:  CLRF   FEA
02FE:  MOVLW  86
0300:  MOVWF  FE9
0302:  MOVF   FEF,W
0304:  BZ    0322
0306:  MOVLW  04
0308:  MOVWF  01
030A:  CLRF   00
030C:  DECFSZ 00,F
030E:  BRA    030C
0310:  DECFSZ 01,F
0312:  BRA    030A
0314:  MOVLW  DC
0316:  MOVWF  00
0318:  DECFSZ 00,F
031A:  BRA    0318
031C:  NOP   
031E:  DECFSZ FEF,F
0320:  BRA    0306
0322:  RETURN 0
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................  
.................... #include "defines.c" 
.................... /* 
....................  * defines.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
.................... //Comandos 
.................... #define cmd_parar	0x00 
.................... #define cmd_subir	0x01 
.................... #define cmd_descer	0x02 
.................... #define cmd_r		0x04 
.................... #define cmd_w		0x05 
.................... //Entradas 
.................... #define bto_sobe	PIN_B0 
.................... #define bto_desce	PIN_B1 
.................... //Saidas 
.................... #define pin_sobe	PIN_C0 
.................... #define pin_desce	PIN_C1 
.................... //Tempos 
.................... #define debounce 	100 
.................... #define latencia	20 
.................... //definicoes 
.................... #define bufferLen	16 
.................... #define allSlvs		0 
....................  
.................... #include "variaveis.c" 
.................... /* 
....................  * vairaveis.c 
....................  * 
....................  *  Created on: 22/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... short ctrl_bto; 
.................... short RxOk; 
....................  
.................... int m_addr = 0xFF; //meu endereco 
.................... int r_addr = 0xFF; //endereco lido 
.................... int aux_addr = 0xFF; 
.................... int m_cmd = 0xFF; // meu comando atual 
.................... int r_cmd = 0xFF; //comando lido 
.................... int l_cmd = 0xFF; //ultimo comando recebido 
.................... int nrSlv = 2; //nr de escravos da rede 
.................... int i; 
.................... int line; //linha do buffer de leitrua 
....................  
.................... int buffer[bufferLen]; //buffer de leitura 
....................  
.................... long r_pos = 12345; //posicao recebida 
.................... long m_pos = 12345; //minha posicao 
....................  
.................... long *p; 
.................... long pos_slv[bufferLen]; //posicao de todos os escravos 
....................  
.................... #include "funcoes.c" 
.................... /* 
....................  * funcoes.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... int getAddr(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
....................  
.................... 	aux[0] = *p; 
.................... 	aux[1] = *(p + 1); 
....................  
.................... 	return atoi(aux); 
.................... } 
....................  
.................... int getCmd(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
....................  
.................... 	aux[0] = *(p + 2); 
.................... 	aux[1] = *(p + 3); 
....................  
.................... 	return atoi(aux); 
.................... } 
....................  
.................... long getPos(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[5]; 
....................  
.................... 	p = str; 
*
0746:  MOVFF  86,88
074A:  MOVFF  85,87
....................  
.................... 	for (i = 0; i < 5; ++i) 
074E:  CLRF   27
0750:  MOVF   27,W
0752:  SUBLW  04
0754:  BNC   079A
.................... 		aux[i] = *(p + i + 2); 
0756:  CLRF   03
0758:  MOVF   27,W
075A:  ADDLW  89
075C:  MOVWF  01
075E:  MOVLW  00
0760:  ADDWFC 03,F
0762:  MOVFF  01,8E
0766:  MOVFF  03,8F
076A:  MOVF   27,W
076C:  ADDWF  x87,W
076E:  MOVWF  x90
0770:  MOVLW  00
0772:  ADDWFC x88,W
0774:  MOVWF  x91
0776:  MOVLW  02
0778:  ADDWF  x90,W
077A:  MOVWF  01
077C:  MOVLW  00
077E:  ADDWFC x91,W
0780:  MOVFF  01,FE9
0784:  MOVWF  FEA
0786:  MOVFF  FEF,90
078A:  MOVFF  8F,FEA
078E:  MOVFF  8E,FE9
0792:  MOVFF  90,FEF
0796:  INCF   27,F
0798:  BRA    0750
....................  
.................... 	return atol(aux); 
079A:  CLRF   x8F
079C:  MOVLW  89
079E:  MOVWF  x8E
07A0:  BRA    055A
07A2:  MOVF   02,W
....................  
.................... } 
07A4:  GOTO   0802 (RETURN)
....................  
.................... int send_cmd(int addr, int cmd) { 
.................... 	delay_ms(latencia); 
*
0390:  MOVLW  14
0392:  MOVWF  x86
0394:  RCALL  02FC
.................... 	printf("%02u%02u\n\r", addr, cmd); 
0396:  MOVFF  83,86
039A:  MOVLW  01
039C:  MOVWF  x87
039E:  RCALL  0324
03A0:  MOVFF  84,86
03A4:  MOVLW  01
03A6:  MOVWF  x87
03A8:  RCALL  0324
03AA:  MOVLW  0A
03AC:  BTFSS  F9E.4
03AE:  BRA    03AC
03B0:  MOVWF  FAD
03B2:  MOVLW  0D
03B4:  BTFSS  F9E.4
03B6:  BRA    03B4
03B8:  MOVWF  FAD
.................... 	return cmd; 
03BA:  MOVFF  84,01
.................... } 
03BE:  RETURN 0
....................  
.................... void send_pos(int addr, long pos) { 
.................... 	delay_ms(latencia); 
*
04D6:  MOVLW  14
04D8:  MOVWF  x86
04DA:  RCALL  02FC
.................... 	printf("%02u%05lu\n\r", addr, pos); 
04DC:  MOVFF  83,86
04E0:  MOVLW  01
04E2:  MOVWF  x87
04E4:  RCALL  0324
04E6:  MOVLW  08
04E8:  MOVWF  FE9
04EA:  MOVFF  85,87
04EE:  MOVFF  84,86
04F2:  BRA    0430
04F4:  MOVLW  0A
04F6:  BTFSS  F9E.4
04F8:  BRA    04F6
04FA:  MOVWF  FAD
04FC:  MOVLW  0D
04FE:  BTFSS  F9E.4
0500:  BRA    04FE
0502:  MOVWF  FAD
.................... } 
0504:  GOTO   07BC (RETURN)
....................  
.................... long *recall_pos(int nrSlaves, long pos) { 
.................... 	int i; 
.................... 	static long ret[bufferLen]; 
....................  
.................... 	send_cmd(allSlvs, cmd_w); 
*
07A8:  CLRF   x83
07AA:  MOVLW  05
07AC:  MOVWF  x84
07AE:  RCALL  0390
.................... 	send_pos(allSlvs, pos); 
07B0:  CLRF   x83
07B2:  MOVFF  81,85
07B6:  MOVFF  80,84
07BA:  BRA    04D6
....................  
.................... 	for (i = 1; i <= nrSlaves; ++i) { 
07BC:  MOVLW  01
07BE:  MOVWF  x82
07C0:  MOVF   x82,W
07C2:  SUBWF  7F,W
07C4:  BNC   0818
.................... 		send_cmd(i, cmd_r); 
07C6:  MOVFF  82,83
07CA:  MOVLW  04
07CC:  MOVWF  x84
07CE:  RCALL  0390
.................... 		delay_ms(latencia * 2); 
07D0:  MOVLW  28
07D2:  MOVWF  x86
07D4:  RCALL  02FC
.................... 		while (!RxOk) 
.................... 			; 
07D6:  BTFSS  1F.1
07D8:  BRA    07D6
.................... 		RxOk = FALSE; 
07DA:  BCF    1F.1
.................... 		ret[i - 1] = getPos(buffer); 
07DC:  MOVLW  01
07DE:  SUBWF  x82,W
07E0:  MOVWF  00
07E2:  BCF    FD8.0
07E4:  RLCF   00,F
07E6:  MOVF   00,W
07E8:  CLRF   03
07EA:  ADDLW  5F
07EC:  MOVWF  01
07EE:  MOVLW  00
07F0:  ADDWFC 03,F
07F2:  MOVFF  01,83
07F6:  MOVFF  03,84
07FA:  CLRF   x86
07FC:  MOVLW  29
07FE:  MOVWF  x85
0800:  BRA    0746
0802:  MOVFF  84,FEA
0806:  MOVFF  83,FE9
080A:  MOVFF  02,FEC
080E:  MOVF   FED,F
0810:  MOVFF  01,FEF
.................... 	} 
0814:  INCF   x82,F
0816:  BRA    07C0
....................  
.................... 	return ret; 
0818:  MOVLW  5F
081A:  MOVWF  01
081C:  MOVLW  00
081E:  MOVWF  02
.................... } 
0820:  GOTO   08A2 (RETURN)
....................  
.................... int trata_bto(int cmd) { 
*
03C0:  BSF    F93.0
03C2:  BCF    x80.0
03C4:  BTFSS  F81.0
03C6:  BSF    x80.0
03C8:  BSF    F93.1
03CA:  BCF    x80.1
03CC:  BTFSS  F81.1
03CE:  BSF    x80.1
03D0:  MOVFF  7F,81
.................... 	short sobe = !input(bto_sobe); 
.................... 	short desce = !input(bto_desce); 
.................... 	int ret = cmd; 
....................  
.................... 	if (sobe ^ desce) { 
03D4:  MOVLW  00
03D6:  BTFSC  x80.0
03D8:  MOVLW  01
03DA:  MOVWF  x83
03DC:  MOVLW  00
03DE:  BTFSC  x80.1
03E0:  MOVLW  01
03E2:  XORWF  x83,W
03E4:  BZ    0418
.................... 		if (!ctrl_bto) { 
03E6:  BTFSC  1F.0
03E8:  BRA    0416
.................... 			delay_ms(debounce); 
03EA:  MOVLW  64
03EC:  MOVWF  x86
03EE:  RCALL  02FC
.................... 			if (!input(bto_sobe)) 
03F0:  BSF    F93.0
03F2:  BTFSC  F81.0
03F4:  BRA    0402
.................... 				ret = send_cmd(allSlvs, cmd_subir); 
03F6:  CLRF   x83
03F8:  MOVLW  01
03FA:  MOVWF  x84
03FC:  RCALL  0390
03FE:  MOVFF  01,81
.................... 			if (!input(bto_desce)) 
0402:  BSF    F93.1
0404:  BTFSC  F81.1
0406:  BRA    0414
.................... 				ret = send_cmd(allSlvs, cmd_descer); 
0408:  CLRF   x83
040A:  MOVLW  02
040C:  MOVWF  x84
040E:  RCALL  0390
0410:  MOVFF  01,81
.................... 			ctrl_bto = TRUE; 
0414:  BSF    1F.0
.................... 		} 
.................... 	} else if (ctrl_bto) { 
0416:  BRA    0428
0418:  BTFSS  1F.0
041A:  BRA    0428
.................... 		ctrl_bto = FALSE; 
041C:  BCF    1F.0
.................... 		ret = send_cmd(allSlvs, cmd_parar); 
041E:  CLRF   x83
0420:  CLRF   x84
0422:  RCALL  0390
0424:  MOVFF  01,81
.................... 	} 
....................  
.................... 	return ret; 
0428:  MOVFF  81,01
.................... } 
042C:  GOTO   0884 (RETURN)
....................  
.................... int trata_comunicacao() { 
....................  
.................... 	r_addr = 0xFF; 
.................... 	r_cmd = 0xFF; 
....................  
.................... 	r_addr = getAddr(buffer); 
.................... 	r_cmd = getCmd(buffer); 
....................  
.................... 	if (r_addr == m_addr || !r_addr) { 
.................... 		if (r_cmd == cmd_w) { 
.................... 			while (!RxOk) 
.................... 				; 
.................... 			RxOk = FALSE; 
.................... 			r_pos = getPos(buffer); 
.................... 		} else if (r_cmd == cmd_r) { 
.................... 			m_pos++; 
.................... 			send_pos(m_addr, m_pos); 
.................... 		} 
.................... 	} 
....................  
.................... 	return r_cmd; 
.................... } 
....................  
.................... void subir() { 
.................... 	output_low(pin_desce); 
.................... 	delay_ms(latencia >> 1); 
.................... 	output_high(pin_sobe); 
.................... } 
....................  
.................... void descer() { 
.................... 	output_low(pin_sobe); 
.................... 	delay_ms(latencia >> 1); 
.................... 	output_high(pin_desce); 
.................... } 
....................  
.................... void parar() { 
.................... 	output_low(pin_sobe); 
*
01AE:  BCF    F94.0
01B0:  BCF    F8B.0
.................... 	output_low(pin_desce); 
01B2:  BCF    F94.1
01B4:  BCF    F8B.1
.................... 	m_pos += get_timer0(); 
01B6:  MOVF   FD6,W
01B8:  ADDWF  3B,F
01BA:  MOVF   FD7,W
01BC:  ADDWFC 3C,F
.................... 	set_timer0(0); 
01BE:  CLRF   FD7
01C0:  CLRF   FD6
.................... } 
01C2:  GOTO   02D2 (RETURN)
....................  
.................... int getMAddr() { 
*
0190:  SETF   F92
0192:  MOVFF  F80,7F
.................... 	int aux = input_a(); 
.................... 	return ((input_a() & 0xF0) >> 4) & 0x0F; 
0196:  SETF   F92
0198:  MOVF   F80,W
019A:  ANDLW  F0
019C:  MOVWF  00
019E:  SWAPF  00,F
01A0:  MOVLW  0F
01A2:  ANDWF  00,F
01A4:  MOVF   00,W
01A6:  ANDLW  0F
01A8:  MOVWF  01
.................... } 
01AA:  GOTO   02CC (RETURN)
....................  
.................... void init_mstr() { 
.................... //	set_timer0(T0_EXT_H_TO_L | T0_DIV_1); 
.................... //	set_timer1(T1_EXTERNAL | T1_DIV_BY_1); 
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
*
02C2:  BSF    F9D.5
.................... 	enable_interrupts(GLOBAL); 
02C4:  MOVLW  C0
02C6:  IORWF  FF2,F
....................  
.................... 	m_cmd = cmd_parar; 
02C8:  CLRF   23
.................... 	nrSlv = getMAddr(); 
02CA:  BRA    0190
02CC:  MOVFF  01,26
....................  
.................... 	parar(); 
02D0:  BRA    01AE
....................  
.................... 	printf("Inicio Mestre:\n\r%d escravos\n\r", nrSlv); 
02D2:  MOVLW  AE
02D4:  MOVWF  FF6
02D6:  MOVLW  00
02D8:  MOVWF  FF7
02DA:  MOVLW  10
02DC:  MOVWF  7F
02DE:  RCALL  01C6
02E0:  MOVFF  26,7F
02E4:  MOVLW  18
02E6:  MOVWF  x80
02E8:  BRA    020E
02EA:  MOVLW  C0
02EC:  MOVWF  FF6
02EE:  MOVLW  00
02F0:  MOVWF  FF7
02F2:  MOVLW  0B
02F4:  MOVWF  7F
02F6:  RCALL  01C6
.................... } 
02F8:  GOTO   087E (RETURN)
....................  
.................... void init_slv() { 
.................... //	set_timer0(T0_EXT_H_TO_L | T0_DIV_1); 
.................... //	set_timer1(T1_EXTERNAL | T1_DIV_BY_1); 
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... 	enable_interrupts(GLOBAL); 
....................  
.................... 	m_cmd = cmd_parar; 
.................... 	m_addr = getMAddr(); 
....................  
.................... 	parar(); 
....................  
.................... 	printf("Inicio Escravo:\n\rEndereco: %d\n\r", m_addr); 
.................... } 
....................  
.................... void trata_cmd(int cmd) { 
.................... 	switch (cmd) { 
.................... 	case cmd_subir: 
.................... 		subir(); 
.................... 		break; 
.................... 	case cmd_descer: 
.................... 		descer(); 
.................... 		break; 
.................... 	case cmd_parar: 
.................... 		parar(); 
.................... 		cmd_parar; 
.................... 		break; 
.................... 	default: 
.................... 	} 
.................... } 
....................  
.................... short recivedOk(int *buff) { 
.................... 	int *p; 
....................  
.................... 	for (p = buff; *p != '\0'; p++) 
*
00EC:  MOVFF  9D,9F
00F0:  MOVFF  9C,9E
00F4:  MOVFF  9F,03
00F8:  MOVFF  9E,FE9
00FC:  MOVFF  9F,FEA
0100:  MOVF   FEF,F
0102:  BZ    013C
.................... 		if (*p == '\n' && *(p + 1) == '\r') 
0104:  MOVFF  9F,03
0108:  MOVFF  9E,FE9
010C:  MOVFF  9F,FEA
0110:  MOVF   FEF,W
0112:  SUBLW  0A
0114:  BNZ   0134
0116:  MOVLW  01
0118:  ADDWF  x9E,W
011A:  MOVWF  01
011C:  MOVLW  00
011E:  ADDWFC x9F,W
0120:  MOVWF  03
0122:  MOVFF  01,FE9
0126:  MOVWF  FEA
0128:  MOVF   FEF,W
012A:  SUBLW  0D
012C:  BNZ   0134
.................... 			return TRUE; 
012E:  MOVLW  01
0130:  MOVWF  01
0132:  BRA    0140
0134:  INCF   x9E,F
0136:  BTFSC  FD8.2
0138:  INCF   x9F,F
013A:  BRA    00F4
....................  
.................... 	return FALSE; 
013C:  MOVLW  00
013E:  MOVWF  01
.................... } 
0140:  GOTO   017A (RETURN)
....................  
.................... #include "interrupcoes.c" 
.................... /* 
....................  * interrupcoes.c 
....................  * 
....................  *  Created on: 02/09/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #int_rda 
.................... void isr_rda() { 
.................... 	clear_interrupt(INT_RDA); 
.................... 	buffer[line++] = getc(); 
0144:  MOVF   28,W
0146:  INCF   28,F
0148:  CLRF   03
014A:  ADDLW  29
014C:  MOVWF  FE9
014E:  MOVLW  00
0150:  ADDWFC 03,W
0152:  MOVWF  FEA
0154:  BTFSS  F9E.5
0156:  BRA    0154
0158:  MOVFF  FAE,FEF
.................... 	buffer[line] = "\0"; 
015C:  CLRF   03
015E:  MOVF   28,W
0160:  ADDLW  29
0162:  MOVWF  01
0164:  MOVLW  00
0166:  ADDWFC 03,F
0168:  MOVFF  03,FEA
016C:  MOVFF  01,FE9
0170:  CLRF   FEF
.................... 	RxOk = recivedOk(buffer); 
0172:  CLRF   x9D
0174:  MOVLW  29
0176:  MOVWF  x9C
0178:  BRA    00EC
017A:  BCF    1F.1
017C:  BTFSC  01.0
017E:  BSF    1F.1
.................... 	if (RxOk && line) 
0180:  BTFSS  1F.1
0182:  BRA    018A
0184:  MOVF   28,F
0186:  BZ    018A
.................... 		line = 0; 
0188:  CLRF   28
.................... } 
....................  
....................  
018A:  BCF    F9E.5
018C:  GOTO   0060
.................... int main(void) { 
*
0824:  CLRF   FF8
0826:  BCF    FD0.7
0828:  BSF    07.7
082A:  MOVLW  FE
082C:  MOVWF  00
082E:  MOVLW  06
0830:  MOVWF  01
0832:  MOVLW  02
0834:  MOVWF  FE9
0836:  MOVLW  00
0838:  MOVWF  FEA
083A:  CLRF   FEE
083C:  DECFSZ 00,F
083E:  BRA    083A
0840:  DECFSZ 01,F
0842:  BRA    083A
0844:  CLRF   FEA
0846:  CLRF   FE9
0848:  MOVLW  61
084A:  MOVWF  FAF
084C:  MOVLW  A6
084E:  MOVWF  FAC
0850:  MOVLW  90
0852:  MOVWF  FAB
0854:  SETF   20
0856:  SETF   21
0858:  SETF   22
085A:  SETF   23
085C:  SETF   24
085E:  SETF   25
0860:  MOVLW  02
0862:  MOVWF  26
0864:  MOVLW  30
0866:  MOVWF  3A
0868:  MOVLW  39
086A:  MOVWF  39
086C:  MOVLW  30
086E:  MOVWF  3C
0870:  MOVLW  39
0872:  MOVWF  3B
0874:  BSF    FC1.0
0876:  BSF    FC1.1
0878:  BSF    FC1.2
087A:  BCF    FC1.3
....................  
.................... 	init_mstr(); 
087C:  BRA    02C2
....................  
.................... 	while (TRUE) { 
....................  
.................... 		m_cmd = trata_bto(m_cmd); 
087E:  MOVFF  23,7F
0882:  BRA    03C0
0884:  MOVFF  01,23
....................  
.................... 		if (m_cmd == cmd_subir || m_cmd == cmd_descer) { 
0888:  DECFSZ 23,W
088A:  BRA    088E
088C:  BRA    0894
088E:  MOVF   23,W
0890:  SUBLW  02
0892:  BNZ   08FA
.................... 			p = recall_pos(nrSlv, r_pos); 
0894:  MOVFF  26,7F
0898:  MOVFF  3A,81
089C:  MOVFF  39,80
08A0:  BRA    07A8
08A2:  MOVFF  02,3E
08A6:  MOVFF  01,3D
.................... 			for (i = 0; i < nrSlv; ++i) { 
08AA:  CLRF   27
08AC:  MOVF   26,W
08AE:  SUBWF  27,W
08B0:  BC    08FA
.................... 				pos_slv[i] = *(p + i); 
08B2:  BCF    FD8.0
08B4:  RLCF   27,W
08B6:  CLRF   03
08B8:  ADDLW  3F
08BA:  MOVWF  01
08BC:  MOVLW  00
08BE:  ADDWFC 03,F
08C0:  MOVFF  01,7F
08C4:  MOVFF  03,80
08C8:  BCF    FD8.0
08CA:  RLCF   27,W
08CC:  ADDWF  3D,W
08CE:  MOVWF  01
08D0:  MOVLW  00
08D2:  ADDWFC 3E,W
08D4:  MOVFF  01,FE9
08D8:  MOVWF  FEA
08DA:  MOVFF  FEC,03
08DE:  MOVF   FED,F
08E0:  MOVFF  FEF,81
08E4:  MOVFF  80,FEA
08E8:  MOVFF  7F,FE9
08EC:  MOVFF  03,FEC
08F0:  MOVF   FED,F
08F2:  MOVFF  81,FEF
.................... 			} 
08F6:  INCF   27,F
08F8:  BRA    08AC
.................... 		} 
.................... 		delay_ms(100); 
08FA:  MOVLW  64
08FC:  MOVWF  x86
08FE:  RCALL  02FC
.................... 	} 
0900:  BRA    087E
....................  
.................... 	return 0; 
0902:  MOVLW  00
0904:  MOVWF  01
.................... } 
....................  
0906:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
