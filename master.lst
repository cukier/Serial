CCS PCH C Compiler, Version 4.140, 22098               20-ago-14 15:26

               Filename:   D:\Projetos\Serial\master.lst

               ROM used:   2194 bytes (7%)
                           Largest free fragment is 30570
               RAM used:   197 (13%) at main() level
                           237 (15%) worst case
               Stack:     5 worst case (4 in main + 1 for interrupts)

*
0000:  GOTO   07F0
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00FA
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   00BA
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... /* 
....................  * master.c 
....................  * 
....................  *  Created on: 18/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #include<18F252.h> 
.................... //////// Standard Header file for the PIC18F252 device //////////////// 
.................... #device PIC18F252 
.................... #list 
....................  
.................... #zero_ram 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
02CA:  CLRF   xD2
....................    sign = 0; 
02CC:  CLRF   xD0
....................    base = 10; 
02CE:  MOVLW  0A
02D0:  MOVWF  xD1
....................    result = 0; 
02D2:  CLRF   xCF
....................  
....................    if (!s) 
02D4:  MOVF   xCD,W
02D6:  IORWF  xCE,W
02D8:  BNZ   02E0
....................       return 0; 
02DA:  MOVLW  00
02DC:  MOVWF  01
02DE:  BRA    0462
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
02E0:  MOVF   xD2,W
02E2:  INCF   xD2,F
02E4:  CLRF   03
02E6:  ADDWF  xCD,W
02E8:  MOVWF  FE9
02EA:  MOVF   xCE,W
02EC:  ADDWFC 03,W
02EE:  MOVWF  FEA
02F0:  MOVFF  FEF,D3
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
02F4:  MOVF   xD3,W
02F6:  SUBLW  2D
02F8:  BNZ   0314
....................    { 
....................       sign = 1;         // Set the sign to negative 
02FA:  MOVLW  01
02FC:  MOVWF  xD0
....................       c = s[index++]; 
02FE:  MOVF   xD2,W
0300:  INCF   xD2,F
0302:  CLRF   03
0304:  ADDWF  xCD,W
0306:  MOVWF  FE9
0308:  MOVF   xCE,W
030A:  ADDWFC 03,W
030C:  MOVWF  FEA
030E:  MOVFF  FEF,D3
....................    } 
....................    else if (c == '+') 
0312:  BRA    032E
0314:  MOVF   xD3,W
0316:  SUBLW  2B
0318:  BNZ   032E
....................    { 
....................       c = s[index++]; 
031A:  MOVF   xD2,W
031C:  INCF   xD2,F
031E:  CLRF   03
0320:  ADDWF  xCD,W
0322:  MOVWF  FE9
0324:  MOVF   xCE,W
0326:  ADDWFC 03,W
0328:  MOVWF  FEA
032A:  MOVFF  FEF,D3
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
032E:  MOVF   xD3,W
0330:  SUBLW  2F
0332:  BTFSC  FD8.0
0334:  BRA    0452
0336:  MOVF   xD3,W
0338:  SUBLW  39
033A:  BTFSS  FD8.0
033C:  BRA    0452
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
033E:  MOVF   xD3,W
0340:  SUBLW  30
0342:  BNZ   0386
0344:  CLRF   03
0346:  MOVF   xD2,W
0348:  ADDWF  xCD,W
034A:  MOVWF  FE9
034C:  MOVF   xCE,W
034E:  ADDWFC 03,W
0350:  MOVWF  FEA
0352:  MOVF   FEF,W
0354:  SUBLW  78
0356:  BZ    036C
0358:  CLRF   03
035A:  MOVF   xD2,W
035C:  ADDWF  xCD,W
035E:  MOVWF  FE9
0360:  MOVF   xCE,W
0362:  ADDWFC 03,W
0364:  MOVWF  FEA
0366:  MOVF   FEF,W
0368:  SUBLW  58
036A:  BNZ   0386
....................       { 
....................          base = 16; 
036C:  MOVLW  10
036E:  MOVWF  xD1
....................          index++; 
0370:  INCF   xD2,F
....................          c = s[index++]; 
0372:  MOVF   xD2,W
0374:  INCF   xD2,F
0376:  CLRF   03
0378:  ADDWF  xCD,W
037A:  MOVWF  FE9
037C:  MOVF   xCE,W
037E:  ADDWFC 03,W
0380:  MOVWF  FEA
0382:  MOVFF  FEF,D3
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0386:  MOVF   xD1,W
0388:  SUBLW  0A
038A:  BNZ   03C2
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
038C:  MOVF   xD3,W
038E:  SUBLW  2F
0390:  BC    03C0
0392:  MOVF   xD3,W
0394:  SUBLW  39
0396:  BNC   03C0
....................             result = 10*result + (c - '0'); 
0398:  MOVLW  0A
039A:  MOVWF  xD4
039C:  MOVFF  CF,D5
03A0:  BRA    027E
03A2:  MOVLW  30
03A4:  SUBWF  xD3,W
03A6:  ADDWF  01,W
03A8:  MOVWF  xCF
....................             c = s[index++]; 
03AA:  MOVF   xD2,W
03AC:  INCF   xD2,F
03AE:  CLRF   03
03B0:  ADDWF  xCD,W
03B2:  MOVWF  FE9
03B4:  MOVF   xCE,W
03B6:  ADDWFC 03,W
03B8:  MOVWF  FEA
03BA:  MOVFF  FEF,D3
....................          } 
03BE:  BRA    038C
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
03C0:  BRA    0452
03C2:  MOVF   xD1,W
03C4:  SUBLW  10
03C6:  BNZ   0452
....................       { 
....................          c = toupper(c); 
03C8:  MOVF   xD3,W
03CA:  SUBLW  60
03CC:  BC    03DA
03CE:  MOVF   xD3,W
03D0:  SUBLW  7A
03D2:  BNC   03DA
03D4:  MOVF   xD3,W
03D6:  ANDLW  DF
03D8:  BRA    03DC
03DA:  MOVF   xD3,W
03DC:  MOVWF  xD3
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
03DE:  MOVF   xD3,W
03E0:  SUBLW  2F
03E2:  BC    03EA
03E4:  MOVF   xD3,W
03E6:  SUBLW  39
03E8:  BC    03F6
03EA:  MOVF   xD3,W
03EC:  SUBLW  40
03EE:  BC    0452
03F0:  MOVF   xD3,W
03F2:  SUBLW  46
03F4:  BNC   0452
....................             if (c >= '0' && c <= '9') 
03F6:  MOVF   xD3,W
03F8:  SUBLW  2F
03FA:  BC    0414
03FC:  MOVF   xD3,W
03FE:  SUBLW  39
0400:  BNC   0414
....................                result = (result << 4) + (c - '0'); 
0402:  SWAPF  xCF,W
0404:  MOVWF  xD4
0406:  MOVLW  F0
0408:  ANDWF  xD4,F
040A:  MOVLW  30
040C:  SUBWF  xD3,W
040E:  ADDWF  xD4,W
0410:  MOVWF  xCF
....................             else 
0412:  BRA    0426
....................                result = (result << 4) + (c - 'A' + 10); 
0414:  SWAPF  xCF,W
0416:  MOVWF  xD4
0418:  MOVLW  F0
041A:  ANDWF  xD4,F
041C:  MOVLW  41
041E:  SUBWF  xD3,W
0420:  ADDLW  0A
0422:  ADDWF  xD4,W
0424:  MOVWF  xCF
....................  
....................             c = s[index++]; 
0426:  MOVF   xD2,W
0428:  INCF   xD2,F
042A:  CLRF   03
042C:  ADDWF  xCD,W
042E:  MOVWF  FE9
0430:  MOVF   xCE,W
0432:  ADDWFC 03,W
0434:  MOVWF  FEA
0436:  MOVFF  FEF,D3
....................             c = toupper(c); 
043A:  MOVF   xD3,W
043C:  SUBLW  60
043E:  BC    044C
0440:  MOVF   xD3,W
0442:  SUBLW  7A
0444:  BNC   044C
0446:  MOVF   xD3,W
0448:  ANDLW  DF
044A:  BRA    044E
044C:  MOVF   xD3,W
044E:  MOVWF  xD3
....................          } 
0450:  BRA    03DE
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0452:  DECFSZ xD0,W
0454:  BRA    045E
0456:  MOVF   xD1,W
0458:  SUBLW  0A
045A:  BNZ   045E
....................        result = -result; 
045C:  NEGF   xCF
....................  
....................    return(result); 
045E:  MOVFF  CF,01
.................... } 
0462:  GOTO   04B8 (RETURN)
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0516:  CLRF   xE3
....................    sign = 0; 
0518:  CLRF   xE1
....................    base = 10; 
051A:  MOVLW  0A
051C:  MOVWF  xE2
....................    result = 0; 
051E:  CLRF   xE0
0520:  CLRF   xDF
....................  
....................    if (!s) 
0522:  MOVF   xDD,W
0524:  IORWF  xDE,W
0526:  BNZ   0530
....................       return 0; 
0528:  MOVLW  00
052A:  MOVWF  01
052C:  MOVWF  02
052E:  BRA    06FE
....................    c = s[index++]; 
0530:  MOVF   xE3,W
0532:  INCF   xE3,F
0534:  CLRF   03
0536:  ADDWF  xDD,W
0538:  MOVWF  FE9
053A:  MOVF   xDE,W
053C:  ADDWFC 03,W
053E:  MOVWF  FEA
0540:  MOVFF  FEF,E4
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0544:  MOVF   xE4,W
0546:  SUBLW  2D
0548:  BNZ   0564
....................    { 
....................       sign = 1;         // Set the sign to negative 
054A:  MOVLW  01
054C:  MOVWF  xE1
....................       c = s[index++]; 
054E:  MOVF   xE3,W
0550:  INCF   xE3,F
0552:  CLRF   03
0554:  ADDWF  xDD,W
0556:  MOVWF  FE9
0558:  MOVF   xDE,W
055A:  ADDWFC 03,W
055C:  MOVWF  FEA
055E:  MOVFF  FEF,E4
....................    } 
....................    else if (c == '+') 
0562:  BRA    057E
0564:  MOVF   xE4,W
0566:  SUBLW  2B
0568:  BNZ   057E
....................    { 
....................       c = s[index++]; 
056A:  MOVF   xE3,W
056C:  INCF   xE3,F
056E:  CLRF   03
0570:  ADDWF  xDD,W
0572:  MOVWF  FE9
0574:  MOVF   xDE,W
0576:  ADDWFC 03,W
0578:  MOVWF  FEA
057A:  MOVFF  FEF,E4
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
057E:  MOVF   xE4,W
0580:  SUBLW  2F
0582:  BTFSC  FD8.0
0584:  BRA    06E2
0586:  MOVF   xE4,W
0588:  SUBLW  39
058A:  BTFSS  FD8.0
058C:  BRA    06E2
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
058E:  MOVF   xE4,W
0590:  SUBLW  30
0592:  BNZ   05D6
0594:  CLRF   03
0596:  MOVF   xE3,W
0598:  ADDWF  xDD,W
059A:  MOVWF  FE9
059C:  MOVF   xDE,W
059E:  ADDWFC 03,W
05A0:  MOVWF  FEA
05A2:  MOVF   FEF,W
05A4:  SUBLW  78
05A6:  BZ    05BC
05A8:  CLRF   03
05AA:  MOVF   xE3,W
05AC:  ADDWF  xDD,W
05AE:  MOVWF  FE9
05B0:  MOVF   xDE,W
05B2:  ADDWFC 03,W
05B4:  MOVWF  FEA
05B6:  MOVF   FEF,W
05B8:  SUBLW  58
05BA:  BNZ   05D6
....................       { 
....................          base = 16; 
05BC:  MOVLW  10
05BE:  MOVWF  xE2
....................          index++; 
05C0:  INCF   xE3,F
....................          c = s[index++]; 
05C2:  MOVF   xE3,W
05C4:  INCF   xE3,F
05C6:  CLRF   03
05C8:  ADDWF  xDD,W
05CA:  MOVWF  FE9
05CC:  MOVF   xDE,W
05CE:  ADDWFC 03,W
05D0:  MOVWF  FEA
05D2:  MOVFF  FEF,E4
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
05D6:  MOVF   xE2,W
05D8:  SUBLW  0A
05DA:  BNZ   061E
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
05DC:  MOVF   xE4,W
05DE:  SUBLW  2F
05E0:  BC    061C
05E2:  MOVF   xE4,W
05E4:  SUBLW  39
05E6:  BNC   061C
....................             result = 10*result + (c - '0'); 
05E8:  CLRF   xE6
05EA:  MOVLW  0A
05EC:  MOVWF  xE5
05EE:  MOVFF  E0,E8
05F2:  MOVFF  DF,E7
05F6:  BRA    04C4
05F8:  MOVLW  30
05FA:  SUBWF  xE4,W
05FC:  ADDWF  01,W
05FE:  MOVWF  xDF
0600:  MOVLW  00
0602:  ADDWFC 02,W
0604:  MOVWF  xE0
....................             c = s[index++]; 
0606:  MOVF   xE3,W
0608:  INCF   xE3,F
060A:  CLRF   03
060C:  ADDWF  xDD,W
060E:  MOVWF  FE9
0610:  MOVF   xDE,W
0612:  ADDWFC 03,W
0614:  MOVWF  FEA
0616:  MOVFF  FEF,E4
....................          } 
061A:  BRA    05DC
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
061C:  BRA    06E2
061E:  MOVF   xE2,W
0620:  SUBLW  10
0622:  BNZ   06E2
....................       { 
....................          c = toupper(c); 
0624:  MOVF   xE4,W
0626:  SUBLW  60
0628:  BC    0636
062A:  MOVF   xE4,W
062C:  SUBLW  7A
062E:  BNC   0636
0630:  MOVF   xE4,W
0632:  ANDLW  DF
0634:  BRA    0638
0636:  MOVF   xE4,W
0638:  MOVWF  xE4
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
063A:  MOVF   xE4,W
063C:  SUBLW  2F
063E:  BC    0646
0640:  MOVF   xE4,W
0642:  SUBLW  39
0644:  BC    0652
0646:  MOVF   xE4,W
0648:  SUBLW  40
064A:  BC    06E2
064C:  MOVF   xE4,W
064E:  SUBLW  46
0650:  BNC   06E2
....................             if (c >= '0' && c <= '9') 
0652:  MOVF   xE4,W
0654:  SUBLW  2F
0656:  BC    068A
0658:  MOVF   xE4,W
065A:  SUBLW  39
065C:  BNC   068A
....................                result = (result << 4) + (c - '0'); 
065E:  RLCF   xDF,W
0660:  MOVWF  xE5
0662:  RLCF   xE0,W
0664:  MOVWF  xE6
0666:  RLCF   xE5,F
0668:  RLCF   xE6,F
066A:  RLCF   xE5,F
066C:  RLCF   xE6,F
066E:  RLCF   xE5,F
0670:  RLCF   xE6,F
0672:  MOVLW  F0
0674:  ANDWF  xE5,F
0676:  MOVLW  30
0678:  SUBWF  xE4,W
067A:  ADDWF  xE5,W
067C:  MOVWF  01
067E:  MOVLW  00
0680:  ADDWFC xE6,W
0682:  MOVFF  01,DF
0686:  MOVWF  xE0
....................             else 
0688:  BRA    06B6
....................                result = (result << 4) + (c - 'A' + 10); 
068A:  RLCF   xDF,W
068C:  MOVWF  xE5
068E:  RLCF   xE0,W
0690:  MOVWF  xE6
0692:  RLCF   xE5,F
0694:  RLCF   xE6,F
0696:  RLCF   xE5,F
0698:  RLCF   xE6,F
069A:  RLCF   xE5,F
069C:  RLCF   xE6,F
069E:  MOVLW  F0
06A0:  ANDWF  xE5,F
06A2:  MOVLW  41
06A4:  SUBWF  xE4,W
06A6:  ADDLW  0A
06A8:  ADDWF  xE5,W
06AA:  MOVWF  01
06AC:  MOVLW  00
06AE:  ADDWFC xE6,W
06B0:  MOVFF  01,DF
06B4:  MOVWF  xE0
....................  
....................             c = s[index++];c = toupper(c); 
06B6:  MOVF   xE3,W
06B8:  INCF   xE3,F
06BA:  CLRF   03
06BC:  ADDWF  xDD,W
06BE:  MOVWF  FE9
06C0:  MOVF   xDE,W
06C2:  ADDWFC 03,W
06C4:  MOVWF  FEA
06C6:  MOVFF  FEF,E4
06CA:  MOVF   xE4,W
06CC:  SUBLW  60
06CE:  BC    06DC
06D0:  MOVF   xE4,W
06D2:  SUBLW  7A
06D4:  BNC   06DC
06D6:  MOVF   xE4,W
06D8:  ANDLW  DF
06DA:  BRA    06DE
06DC:  MOVF   xE4,W
06DE:  MOVWF  xE4
....................          } 
06E0:  BRA    063A
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
06E2:  MOVF   xE2,W
06E4:  SUBLW  0A
06E6:  BNZ   06F6
06E8:  DECFSZ xE1,W
06EA:  BRA    06F6
....................       result = -result; 
06EC:  COMF   xDF,F
06EE:  COMF   xE0,F
06F0:  INCF   xDF,F
06F2:  BTFSC  FD8.2
06F4:  INCF   xE0,F
....................  
....................    return(result); 
06F6:  MOVFF  DF,01
06FA:  MOVFF  E0,02
.................... } 
06FE:  GOTO   0758 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS 
.................... #use delay(clock=15MHz) 
*
010E:  CLRF   FEA
0110:  MOVLW  C7
0112:  MOVWF  FE9
0114:  MOVF   FEF,W
0116:  BZ    0134
0118:  MOVLW  04
011A:  MOVWF  01
011C:  CLRF   00
011E:  DECFSZ 00,F
0120:  BRA    011E
0122:  DECFSZ 01,F
0124:  BRA    011C
0126:  MOVLW  DC
0128:  MOVWF  00
012A:  DECFSZ 00,F
012C:  BRA    012A
012E:  NOP   
0130:  DECFSZ FEF,F
0132:  BRA    0118
0134:  RETURN 0
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................  
.................... #include "definicoes.c" 
.................... /* 
....................  * definicoes.c 
....................  * 
....................  *  Created on: 20/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... //defines 
.................... #define buffer_size 128 
.................... #define vbto_parar 0 
.................... #define max_slv	16 
.................... //cmd 
.................... #define cmd_parar	0x00 
.................... #define cmd_subir	0x01 
.................... #define cmd_descer	0x02 
.................... #define cmd_pos		0x03 
.................... //entradas 
.................... #define bto_sobe	PIN_B0 
.................... #define bto_desce	PIN_B1 
.................... //saidas 
.................... #define saida_sobe	PIN_C0 
.................... #define saida_desce	PIN_C1 
.................... //tempos 
.................... #define debounce 100 
....................  
.................... #include "variaveis.c" 
.................... /* 
....................  * variaveis.c 
....................  * 
....................  *  Created on: 20/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... int buffer[buffer_size]; 
.................... int line = 0; 
.................... int addr = 1; 
.................... int r_addr = 10; 
....................  
.................... short recived = FALSE; 
.................... short en_timer2 = TRUE; 
.................... //mestre 
.................... int nrSlaves = 1; 
.................... int i = 0; 
....................  
.................... long pos_elev[max_slv]; 
....................  
....................  
.................... #include "interrupcoes.c" 
.................... /* 
....................  * interrupcoes.c 
....................  * 
....................  *  Created on: 20/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #INT_RDA 
.................... void serial_isr() { 
.................... 	clear_interrupt(INT_RDA); 
.................... 	buffer[line++] = getc(); 
*
00BA:  MOVF   x9F,W
00BC:  INCF   x9F,F
00BE:  CLRF   03
00C0:  ADDLW  1F
00C2:  MOVWF  FE9
00C4:  MOVLW  00
00C6:  ADDWFC 03,W
00C8:  MOVWF  FEA
00CA:  BTFSS  F9E.5
00CC:  BRA    00CA
00CE:  MOVFF  FAE,FEF
.................... 	buffer[line] = '\0'; 
00D2:  CLRF   03
00D4:  MOVF   x9F,W
00D6:  ADDLW  1F
00D8:  MOVWF  FE9
00DA:  MOVLW  00
00DC:  ADDWFC 03,W
00DE:  MOVWF  FEA
00E0:  CLRF   FEF
.................... 	set_timer2(0); 
00E2:  CLRF   FCC
.................... 	if (en_timer2) { 
00E4:  BTFSS  xA2.1
00E6:  BRA    00F4
.................... 		en_timer2 = FALSE; 
00E8:  BCF    xA2.1
.................... 		setup_timer_2(T2_DIV_BY_16, 255, 1); 
00EA:  MOVLW  00
00EC:  IORLW  06
00EE:  MOVWF  FCA
00F0:  MOVLW  FF
00F2:  MOVWF  FCB
.................... 	} 
.................... } 
....................  
00F4:  BCF    F9E.5
00F6:  GOTO   006C
.................... #INT_TIMER2 
.................... void timer2_isr() { 
.................... 	clear_interrupt(INT_TIMER2); 
00FA:  BCF    F9E.1
.................... 	setup_timer_2(T2_DISABLED, 255, 1); 
00FC:  MOVLW  00
00FE:  MOVWF  FCA
0100:  MOVLW  FF
0102:  MOVWF  FCB
.................... 	set_timer2(0); 
0104:  CLRF   FCC
.................... 	recived = TRUE; 
0106:  BSF    xA2.0
.................... } 
....................  
.................... #include "funcoes.c" 
.................... /* 
....................  * fucoes.c 
....................  * 
....................  *  Created on: 20/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
0108:  BCF    F9E.1
010A:  GOTO   006C
.................... int trans_addr(int *ptr) { 
*
0466:  SETF   xC8
.................... 	int ret = 0xFF; 
.................... 	int aux[2]; 
.................... 	int *p; 
....................  
.................... 	for (p = ptr; *p != '\0'; p++) 
0468:  MOVFF  C7,CC
046C:  MOVFF  C6,CB
0470:  MOVFF  CC,03
0474:  MOVFF  CB,FE9
0478:  MOVFF  CC,FEA
047C:  MOVF   FEF,F
047E:  BZ    0488
.................... 		; 
0480:  INCF   xCB,F
0482:  BTFSC  FD8.2
0484:  INCF   xCC,F
0486:  BRA    0470
....................  
.................... 	aux[0] = *(p - 4); 
0488:  MOVLW  04
048A:  SUBWF  xCB,W
048C:  MOVWF  00
048E:  MOVLW  00
0490:  SUBWFB xCC,W
0492:  MOVFF  00,FE9
0496:  MOVWF  FEA
0498:  MOVFF  FEF,C9
.................... 	aux[1] = *(p - 3); 
049C:  MOVLW  03
049E:  SUBWF  xCB,W
04A0:  MOVWF  00
04A2:  MOVLW  00
04A4:  SUBWFB xCC,W
04A6:  MOVFF  00,FE9
04AA:  MOVWF  FEA
04AC:  MOVFF  FEF,CA
....................  
.................... 	ret = atoi(aux); 
04B0:  CLRF   xCE
04B2:  MOVLW  C9
04B4:  MOVWF  xCD
04B6:  BRA    02CA
04B8:  MOVFF  01,C8
....................  
.................... 	return ret; 
04BC:  MOVFF  C8,01
.................... } 
04C0:  GOTO   07AE (RETURN)
....................  
.................... long trans_pos(int *ptr) { 
*
0702:  SETF   xCB
0704:  SETF   xCA
0706:  CLRF   xDC
....................  
.................... 	long ret = 0xFFFF; 
.................... 	int posArray[16]; 
.................... 	int i = 0; 
....................  
.................... 	for (i = 1; i < line; ++i) { 
0708:  MOVLW  01
070A:  MOVWF  xDC
070C:  MOVF   x9F,W
070E:  SUBWF  xDC,W
0710:  BC    0750
.................... 		posArray[i - 1] = *ptr[i]; 
0712:  MOVLW  01
0714:  SUBWF  xDC,W
0716:  CLRF   03
0718:  ADDLW  CC
071A:  MOVWF  01
071C:  MOVLW  00
071E:  ADDWFC 03,F
0720:  MOVFF  03,DE
0724:  CLRF   03
0726:  MOVF   xDC,W
0728:  ADDWF  xC8,W
072A:  MOVWF  FE9
072C:  MOVF   xC9,W
072E:  ADDWFC 03,W
0730:  MOVWF  FEA
0732:  MOVF   FEF,W
0734:  CLRF   03
0736:  MOVWF  FE9
0738:  MOVFF  03,FEA
073C:  MOVFF  FEF,DF
0740:  MOVFF  DE,FEA
0744:  MOVFF  01,FE9
0748:  MOVFF  DF,FEF
.................... 	} 
074C:  INCF   xDC,F
074E:  BRA    070C
....................  
.................... 	ret = atol(posArray); 
0750:  CLRF   xDE
0752:  MOVLW  CC
0754:  MOVWF  xDD
0756:  BRA    0516
0758:  MOVFF  02,CB
075C:  MOVFF  01,CA
....................  
.................... 	return ret; 
0760:  MOVFF  CA,01
0764:  MOVFF  CB,02
.................... } 
0768:  GOTO   07D0 (RETURN)
....................  
.................... int trans_cmd(int *ptr) { 
.................... 	int ret = 0xFF; 
.................... 	int aux[2]; 
.................... 	int *p; 
....................  
.................... 	for (p = ptr; *p != '\0'; p++) 
.................... 		; 
....................  
.................... 	aux[0] = *(p - 2); 
.................... 	aux[1] = *(p - 1); 
....................  
.................... 	ret = atoi(aux); 
....................  
.................... 	return ret; 
.................... } 
....................  
....................  
.................... short send_stp = TRUE; 
.................... short ctrl_bto = FALSE; 
.................... short recolhe = FALSE; 
....................  
.................... int trata_bto() { 
*
0136:  BSF    F93.0
0138:  BCF    xC5.0
013A:  BTFSS  F81.0
013C:  BSF    xC5.0
013E:  BSF    F93.1
0140:  BCF    xC5.1
0142:  BTFSS  F81.1
0144:  BSF    xC5.1
0146:  SETF   xC6
.................... 	short sobe = !input(bto_sobe); 
.................... 	short desce = !input(bto_desce); 
.................... 	int ret = 0xFF; 
....................  
.................... 	if (sobe ^ desce) { 
0148:  MOVLW  00
014A:  BTFSC  xC5.0
014C:  MOVLW  01
014E:  MOVWF  xC8
0150:  MOVLW  00
0152:  BTFSC  xC5.1
0154:  MOVLW  01
0156:  XORWF  xC8,W
0158:  BZ    017C
.................... 		if (!ctrl_bto) { 
015A:  BTFSC  xA2.3
015C:  BRA    017A
.................... 			delay_ms(debounce); 
015E:  MOVLW  64
0160:  MOVWF  xC7
0162:  RCALL  010E
.................... 			if (!input(bto_sobe)) 
0164:  BSF    F93.0
0166:  BTFSC  F81.0
0168:  BRA    016E
.................... 				ret = bto_sobe; 
016A:  MOVLW  08
016C:  MOVWF  xC6
.................... 			if (!input(bto_desce)) 
016E:  BSF    F93.1
0170:  BTFSC  F81.1
0172:  BRA    0178
.................... 				ret = bto_desce; 
0174:  MOVLW  09
0176:  MOVWF  xC6
.................... 			ctrl_bto = TRUE; 
0178:  BSF    xA2.3
.................... 		} 
.................... 	} else if (ctrl_bto) { 
017A:  BRA    0184
017C:  BTFSS  xA2.3
017E:  BRA    0184
.................... 		ctrl_bto = FALSE; 
0180:  BCF    xA2.3
.................... 		ret = vbto_parar; 
0182:  CLRF   xC6
.................... 	} 
....................  
.................... 	return ret; 
0184:  MOVFF  C6,01
.................... } 
0188:  GOTO   0858 (RETURN)
....................  
.................... void send(int iCmd) { 
*
0220:  CLRF   xC6
.................... 	int i = 0; 
.................... 	if (iCmd != cmd_parar) { 
0222:  MOVF   xC5,F
0224:  BZ    025A
.................... 		for (i = 1; i <= nrSlaves; ++i) 
0226:  MOVLW  01
0228:  MOVWF  xC6
022A:  MOVF   xC6,W
022C:  SUBWF  xA3,W
022E:  BNC   0258
.................... 			printf("\n\r%02u%02u", i, iCmd); 
0230:  MOVLW  0A
0232:  BTFSS  F9E.4
0234:  BRA    0232
0236:  MOVWF  FAD
0238:  MOVLW  0D
023A:  BTFSS  F9E.4
023C:  BRA    023A
023E:  MOVWF  FAD
0240:  MOVFF  C6,C7
0244:  MOVLW  01
0246:  MOVWF  xC8
0248:  RCALL  01B4
024A:  MOVFF  C5,C7
024E:  MOVLW  01
0250:  MOVWF  xC8
0252:  RCALL  01B4
0254:  INCF   xC6,F
0256:  BRA    022A
.................... 	} else 
0258:  BRA    027C
.................... 		printf("\n\r%02u%02u", 0, iCmd); 
025A:  MOVLW  0A
025C:  BTFSS  F9E.4
025E:  BRA    025C
0260:  MOVWF  FAD
0262:  MOVLW  0D
0264:  BTFSS  F9E.4
0266:  BRA    0264
0268:  MOVWF  FAD
026A:  CLRF   xC7
026C:  MOVLW  01
026E:  MOVWF  xC8
0270:  RCALL  01B4
0272:  MOVFF  C5,C7
0276:  MOVLW  01
0278:  MOVWF  xC8
027A:  RCALL  01B4
.................... } 
027C:  RETURN 0
....................  
.................... void read() { 
*
076C:  CLRF   xC5
.................... 	int i = 0; 
....................  
.................... 	for (i = 1; i <= nrSlaves; ++i) { 
076E:  MOVLW  01
0770:  MOVWF  xC5
0772:  MOVF   xC5,W
0774:  SUBWF  xA3,W
0776:  BNC   07EC
.................... 		printf("\n\r%02u%02u", i, cmd_pos); 
0778:  MOVLW  0A
077A:  BTFSS  F9E.4
077C:  BRA    077A
077E:  MOVWF  FAD
0780:  MOVLW  0D
0782:  BTFSS  F9E.4
0784:  BRA    0782
0786:  MOVWF  FAD
0788:  MOVFF  C5,C7
078C:  MOVLW  01
078E:  MOVWF  xC8
0790:  RCALL  01B4
0792:  MOVLW  03
0794:  MOVWF  xC7
0796:  MOVLW  01
0798:  MOVWF  xC8
079A:  RCALL  01B4
....................  
.................... 		while (!recived) 
.................... 			; 
079C:  BTFSS  xA2.0
079E:  BRA    079C
.................... 		if (recived) { 
07A0:  BTFSS  xA2.0
07A2:  BRA    07E8
.................... 			recived = FALSE; 
07A4:  BCF    xA2.0
.................... 			r_addr = trans_addr(buffer); 
07A6:  CLRF   xC7
07A8:  MOVLW  1F
07AA:  MOVWF  xC6
07AC:  BRA    0466
07AE:  MOVFF  01,A1
.................... 			pos_elev[r_addr] = trans_pos(buffer); 
07B2:  BCF    FD8.0
07B4:  RLCF   xA1,W
07B6:  CLRF   03
07B8:  ADDLW  A5
07BA:  MOVWF  01
07BC:  MOVLW  00
07BE:  ADDWFC 03,F
07C0:  MOVFF  01,C6
07C4:  MOVFF  03,C7
07C8:  CLRF   xC9
07CA:  MOVLW  1F
07CC:  MOVWF  xC8
07CE:  BRA    0702
07D0:  MOVFF  C7,FEA
07D4:  MOVFF  C6,FE9
07D8:  MOVFF  02,FEC
07DC:  MOVF   FED,F
07DE:  MOVFF  01,FEF
.................... 			buffer[0] = '\0'; 
07E2:  CLRF   1F
.................... 			line = 0; 
07E4:  CLRF   x9F
.................... 			en_timer2 = TRUE; 
07E6:  BSF    xA2.1
.................... 		} 
.................... 	} 
07E8:  INCF   xC5,F
07EA:  BRA    0772
.................... } 
07EC:  GOTO   0888 (RETURN)
....................  
.................... int main(void) { 
07F0:  CLRF   FF8
07F2:  BCF    FD0.7
07F4:  BSF    07.7
07F6:  MOVLW  FE
07F8:  MOVWF  00
07FA:  MOVLW  06
07FC:  MOVWF  01
07FE:  MOVLW  02
0800:  MOVWF  FE9
0802:  MOVLW  00
0804:  MOVWF  FEA
0806:  CLRF   FEE
0808:  DECFSZ 00,F
080A:  BRA    0806
080C:  DECFSZ 01,F
080E:  BRA    0806
0810:  CLRF   FEA
0812:  CLRF   FE9
0814:  MOVLW  61
0816:  MOVWF  FAF
0818:  MOVLW  A6
081A:  MOVWF  FAC
081C:  MOVLW  90
081E:  MOVWF  FAB
0820:  CLRF   x9F
0822:  MOVLW  01
0824:  MOVWF  xA0
0826:  MOVLW  0A
0828:  MOVWF  xA1
082A:  BCF    xA2.0
082C:  BSF    xA2.1
082E:  MOVLW  01
0830:  MOVWF  xA3
0832:  CLRF   xA4
0834:  BSF    xA2.2
0836:  BCF    xA2.3
0838:  BCF    xA2.4
083A:  BSF    FC1.0
083C:  BSF    FC1.1
083E:  BSF    FC1.2
0840:  BCF    FC1.3
....................  
.................... 	clear_interrupt(INT_TIMER2); 
0842:  BCF    F9E.1
.................... 	set_timer2(0); 
0844:  CLRF   FCC
.................... 	setup_timer_2(T2_DISABLED, 255, 1); 
0846:  MOVLW  00
0848:  MOVWF  FCA
084A:  MOVLW  FF
084C:  MOVWF  FCB
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
084E:  BSF    F9D.5
.................... 	enable_interrupts(INT_TIMER2); 
0850:  BSF    F9D.1
.................... 	enable_interrupts(GLOBAL); 
0852:  MOVLW  C0
0854:  IORWF  FF2,F
....................  
.................... 	while (TRUE) { 
.................... 		switch (trata_bto()) { 
0856:  BRA    0136
0858:  MOVF   01,W
085A:  XORLW  08
085C:  BZ    0868
085E:  XORLW  01
0860:  BZ    0872
0862:  XORLW  09
0864:  BZ    087C
0866:  BRA    0882
.................... 		case bto_sobe: 
.................... 			send(cmd_subir); 
0868:  MOVLW  01
086A:  MOVWF  xC5
086C:  RCALL  0220
.................... 			recolhe = TRUE; 
086E:  BSF    xA2.4
.................... 			break; 
0870:  BRA    0882
.................... 		case bto_desce: 
.................... 			send(cmd_descer); 
0872:  MOVLW  02
0874:  MOVWF  xC5
0876:  RCALL  0220
.................... 			recolhe = TRUE; 
0878:  BSF    xA2.4
.................... 			break; 
087A:  BRA    0882
.................... 		case vbto_parar: 
.................... 			send(cmd_parar); 
087C:  CLRF   xC5
087E:  RCALL  0220
.................... 			recolhe = FALSE; 
0880:  BCF    xA2.4
.................... 			break; 
.................... 		} 
....................  
.................... 		if (recolhe) { 
0882:  BTFSS  xA2.4
0884:  BRA    0888
.................... 			read(); 
0886:  BRA    076C
.................... 		} 
....................  
.................... 		delay_ms(100); 
0888:  MOVLW  64
088A:  MOVWF  xC7
088C:  RCALL  010E
.................... 	} 
088E:  BRA    0856
....................  
.................... 	return 0; 
0890:  MOVLW  00
0892:  MOVWF  01
.................... } 
0894:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
