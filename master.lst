CCS PCH C Compiler, Version 4.140, 22098               08-set-14 16:31

               Filename:   D:\Projetos\Serial\master.lst

               ROM used:   2006 bytes (6%)
                           Largest free fragment is 30758
               RAM used:   130 (8%) at main() level
                           177 (12%) worst case
               Stack:     6 worst case (4 in main + 2 for interrupts)

*
0000:  GOTO   06F8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0106
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... /* 
....................  * master.c 
....................  * 
....................  *  Created on: 18/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #include<18F252.h> 
.................... //////// Standard Header file for the PIC18F252 device //////////////// 
.................... #device PIC18F252 
.................... #list 
....................  
.................... #zero_ram 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
0422:  CLRF   xA3
....................    sign = 0; 
0424:  CLRF   xA1
....................    base = 10; 
0426:  MOVLW  0A
0428:  MOVWF  xA2
....................    result = 0; 
042A:  CLRF   xA0
042C:  CLRF   x9F
....................  
....................    if (!s) 
042E:  MOVF   x9D,W
0430:  IORWF  x9E,W
0432:  BNZ   043C
....................       return 0; 
0434:  MOVLW  00
0436:  MOVWF  01
0438:  MOVWF  02
043A:  BRA    060A
....................    c = s[index++]; 
043C:  MOVF   xA3,W
043E:  INCF   xA3,F
0440:  CLRF   03
0442:  ADDWF  x9D,W
0444:  MOVWF  FE9
0446:  MOVF   x9E,W
0448:  ADDWFC 03,W
044A:  MOVWF  FEA
044C:  MOVFF  FEF,A4
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0450:  MOVF   xA4,W
0452:  SUBLW  2D
0454:  BNZ   0470
....................    { 
....................       sign = 1;         // Set the sign to negative 
0456:  MOVLW  01
0458:  MOVWF  xA1
....................       c = s[index++]; 
045A:  MOVF   xA3,W
045C:  INCF   xA3,F
045E:  CLRF   03
0460:  ADDWF  x9D,W
0462:  MOVWF  FE9
0464:  MOVF   x9E,W
0466:  ADDWFC 03,W
0468:  MOVWF  FEA
046A:  MOVFF  FEF,A4
....................    } 
....................    else if (c == '+') 
046E:  BRA    048A
0470:  MOVF   xA4,W
0472:  SUBLW  2B
0474:  BNZ   048A
....................    { 
....................       c = s[index++]; 
0476:  MOVF   xA3,W
0478:  INCF   xA3,F
047A:  CLRF   03
047C:  ADDWF  x9D,W
047E:  MOVWF  FE9
0480:  MOVF   x9E,W
0482:  ADDWFC 03,W
0484:  MOVWF  FEA
0486:  MOVFF  FEF,A4
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
048A:  MOVF   xA4,W
048C:  SUBLW  2F
048E:  BTFSC  FD8.0
0490:  BRA    05EE
0492:  MOVF   xA4,W
0494:  SUBLW  39
0496:  BTFSS  FD8.0
0498:  BRA    05EE
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
049A:  MOVF   xA4,W
049C:  SUBLW  30
049E:  BNZ   04E2
04A0:  CLRF   03
04A2:  MOVF   xA3,W
04A4:  ADDWF  x9D,W
04A6:  MOVWF  FE9
04A8:  MOVF   x9E,W
04AA:  ADDWFC 03,W
04AC:  MOVWF  FEA
04AE:  MOVF   FEF,W
04B0:  SUBLW  78
04B2:  BZ    04C8
04B4:  CLRF   03
04B6:  MOVF   xA3,W
04B8:  ADDWF  x9D,W
04BA:  MOVWF  FE9
04BC:  MOVF   x9E,W
04BE:  ADDWFC 03,W
04C0:  MOVWF  FEA
04C2:  MOVF   FEF,W
04C4:  SUBLW  58
04C6:  BNZ   04E2
....................       { 
....................          base = 16; 
04C8:  MOVLW  10
04CA:  MOVWF  xA2
....................          index++; 
04CC:  INCF   xA3,F
....................          c = s[index++]; 
04CE:  MOVF   xA3,W
04D0:  INCF   xA3,F
04D2:  CLRF   03
04D4:  ADDWF  x9D,W
04D6:  MOVWF  FE9
04D8:  MOVF   x9E,W
04DA:  ADDWFC 03,W
04DC:  MOVWF  FEA
04DE:  MOVFF  FEF,A4
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
04E2:  MOVF   xA2,W
04E4:  SUBLW  0A
04E6:  BNZ   052A
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
04E8:  MOVF   xA4,W
04EA:  SUBLW  2F
04EC:  BC    0528
04EE:  MOVF   xA4,W
04F0:  SUBLW  39
04F2:  BNC   0528
....................             result = 10*result + (c - '0'); 
04F4:  CLRF   xA6
04F6:  MOVLW  0A
04F8:  MOVWF  xA5
04FA:  MOVFF  A0,A8
04FE:  MOVFF  9F,A7
0502:  BRA    03D0
0504:  MOVLW  30
0506:  SUBWF  xA4,W
0508:  ADDWF  01,W
050A:  MOVWF  x9F
050C:  MOVLW  00
050E:  ADDWFC 02,W
0510:  MOVWF  xA0
....................             c = s[index++]; 
0512:  MOVF   xA3,W
0514:  INCF   xA3,F
0516:  CLRF   03
0518:  ADDWF  x9D,W
051A:  MOVWF  FE9
051C:  MOVF   x9E,W
051E:  ADDWFC 03,W
0520:  MOVWF  FEA
0522:  MOVFF  FEF,A4
....................          } 
0526:  BRA    04E8
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0528:  BRA    05EE
052A:  MOVF   xA2,W
052C:  SUBLW  10
052E:  BNZ   05EE
....................       { 
....................          c = toupper(c); 
0530:  MOVF   xA4,W
0532:  SUBLW  60
0534:  BC    0542
0536:  MOVF   xA4,W
0538:  SUBLW  7A
053A:  BNC   0542
053C:  MOVF   xA4,W
053E:  ANDLW  DF
0540:  BRA    0544
0542:  MOVF   xA4,W
0544:  MOVWF  xA4
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
0546:  MOVF   xA4,W
0548:  SUBLW  2F
054A:  BC    0552
054C:  MOVF   xA4,W
054E:  SUBLW  39
0550:  BC    055E
0552:  MOVF   xA4,W
0554:  SUBLW  40
0556:  BC    05EE
0558:  MOVF   xA4,W
055A:  SUBLW  46
055C:  BNC   05EE
....................             if (c >= '0' && c <= '9') 
055E:  MOVF   xA4,W
0560:  SUBLW  2F
0562:  BC    0596
0564:  MOVF   xA4,W
0566:  SUBLW  39
0568:  BNC   0596
....................                result = (result << 4) + (c - '0'); 
056A:  RLCF   x9F,W
056C:  MOVWF  xA5
056E:  RLCF   xA0,W
0570:  MOVWF  xA6
0572:  RLCF   xA5,F
0574:  RLCF   xA6,F
0576:  RLCF   xA5,F
0578:  RLCF   xA6,F
057A:  RLCF   xA5,F
057C:  RLCF   xA6,F
057E:  MOVLW  F0
0580:  ANDWF  xA5,F
0582:  MOVLW  30
0584:  SUBWF  xA4,W
0586:  ADDWF  xA5,W
0588:  MOVWF  01
058A:  MOVLW  00
058C:  ADDWFC xA6,W
058E:  MOVFF  01,9F
0592:  MOVWF  xA0
....................             else 
0594:  BRA    05C2
....................                result = (result << 4) + (c - 'A' + 10); 
0596:  RLCF   x9F,W
0598:  MOVWF  xA5
059A:  RLCF   xA0,W
059C:  MOVWF  xA6
059E:  RLCF   xA5,F
05A0:  RLCF   xA6,F
05A2:  RLCF   xA5,F
05A4:  RLCF   xA6,F
05A6:  RLCF   xA5,F
05A8:  RLCF   xA6,F
05AA:  MOVLW  F0
05AC:  ANDWF  xA5,F
05AE:  MOVLW  41
05B0:  SUBWF  xA4,W
05B2:  ADDLW  0A
05B4:  ADDWF  xA5,W
05B6:  MOVWF  01
05B8:  MOVLW  00
05BA:  ADDWFC xA6,W
05BC:  MOVFF  01,9F
05C0:  MOVWF  xA0
....................  
....................             c = s[index++];c = toupper(c); 
05C2:  MOVF   xA3,W
05C4:  INCF   xA3,F
05C6:  CLRF   03
05C8:  ADDWF  x9D,W
05CA:  MOVWF  FE9
05CC:  MOVF   x9E,W
05CE:  ADDWFC 03,W
05D0:  MOVWF  FEA
05D2:  MOVFF  FEF,A4
05D6:  MOVF   xA4,W
05D8:  SUBLW  60
05DA:  BC    05E8
05DC:  MOVF   xA4,W
05DE:  SUBLW  7A
05E0:  BNC   05E8
05E2:  MOVF   xA4,W
05E4:  ANDLW  DF
05E6:  BRA    05EA
05E8:  MOVF   xA4,W
05EA:  MOVWF  xA4
....................          } 
05EC:  BRA    0546
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
05EE:  MOVF   xA2,W
05F0:  SUBLW  0A
05F2:  BNZ   0602
05F4:  DECFSZ xA1,W
05F6:  BRA    0602
....................       result = -result; 
05F8:  COMF   x9F,F
05FA:  COMF   xA0,F
05FC:  INCF   x9F,F
05FE:  BTFSC  FD8.2
0600:  INCF   xA0,F
....................  
....................    return(result); 
0602:  MOVFF  9F,01
0606:  MOVFF  A0,02
.................... } 
060A:  GOTO   066A (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS 
.................... #use delay(clock=15MHz) 
*
019C:  CLRF   FEA
019E:  MOVLW  95
01A0:  MOVWF  FE9
01A2:  MOVF   FEF,W
01A4:  BZ    01C2
01A6:  MOVLW  04
01A8:  MOVWF  01
01AA:  CLRF   00
01AC:  DECFSZ 00,F
01AE:  BRA    01AC
01B0:  DECFSZ 01,F
01B2:  BRA    01AA
01B4:  MOVLW  DC
01B6:  MOVWF  00
01B8:  DECFSZ 00,F
01BA:  BRA    01B8
01BC:  NOP   
01BE:  DECFSZ FEF,F
01C0:  BRA    01A6
01C2:  RETURN 0
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................  
.................... #include "defines.c" 
.................... /* 
....................  * defines.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
.................... //Comandos 
.................... #define cmd_parar	0x00 
.................... #define cmd_subir	0x01 
.................... #define cmd_descer	0x02 
.................... #define cmd_r		0x04 
.................... #define cmd_w		0x05 
.................... //Entradas 
.................... #define bto_sobe	PIN_B0 
.................... #define bto_desce	PIN_B1 
.................... //Saidas 
.................... #define pin_sobe	PIN_C0 
.................... #define pin_desce	PIN_C1 
.................... //Tempos 
.................... #define debounce 	100 
.................... #define latencia	20 
.................... //definicoes 
.................... #define bufferLen	16 
.................... #define allSlvs		0 
....................  
.................... #include "variaveis.c" 
.................... /* 
....................  * vairaveis.c 
....................  * 
....................  *  Created on: 22/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... short ctrl_bto; 
.................... short RxOk; 
....................  
.................... int m_addr = 0xFF; 
.................... int r_addr = 0xFF; 
.................... int aux_addr = 0xFF; 
.................... int m_cmd = 0xFF; 
.................... int r_cmd = 0xFF; 
.................... int nrSlv = 2; 
.................... int i; 
.................... int line; 
....................  
.................... int buffer[bufferLen]; 
....................  
.................... long r_pos = 12345; 
.................... long m_pos = 12345; 
....................  
.................... long *p; 
.................... long pos_slv[bufferLen]; 
....................  
.................... #include "funcoes.c" 
.................... /* 
....................  * funcoes.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... int getAddr(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
....................  
.................... 	aux[0] = *p; 
.................... 	aux[1] = *(p + 1); 
....................  
.................... 	return atoi(aux); 
.................... } 
....................  
.................... int getCmd(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
....................  
.................... 	aux[0] = *(p + 2); 
.................... 	aux[1] = *(p + 3); 
....................  
.................... 	return atoi(aux); 
.................... } 
....................  
.................... long getPos(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[5]; 
....................  
.................... 	p = str; 
*
060E:  MOVFF  95,97
0612:  MOVFF  94,96
....................  
.................... 	for (i = 0; i < 5; ++i) 
0616:  CLRF   26
0618:  MOVF   26,W
061A:  SUBLW  04
061C:  BNC   0662
.................... 		aux[i] = *(p + i + 2); 
061E:  CLRF   03
0620:  MOVF   26,W
0622:  ADDLW  98
0624:  MOVWF  01
0626:  MOVLW  00
0628:  ADDWFC 03,F
062A:  MOVFF  01,9D
062E:  MOVFF  03,9E
0632:  MOVF   26,W
0634:  ADDWF  x96,W
0636:  MOVWF  x9F
0638:  MOVLW  00
063A:  ADDWFC x97,W
063C:  MOVWF  xA0
063E:  MOVLW  02
0640:  ADDWF  x9F,W
0642:  MOVWF  01
0644:  MOVLW  00
0646:  ADDWFC xA0,W
0648:  MOVFF  01,FE9
064C:  MOVWF  FEA
064E:  MOVFF  FEF,9F
0652:  MOVFF  9E,FEA
0656:  MOVFF  9D,FE9
065A:  MOVFF  9F,FEF
065E:  INCF   26,F
0660:  BRA    0618
....................  
.................... 	return atol(aux); 
0662:  CLRF   x9E
0664:  MOVLW  98
0666:  MOVWF  x9D
0668:  BRA    0422
066A:  MOVF   02,W
....................  
.................... } 
066C:  GOTO   06D6 (RETURN)
....................  
.................... int send_cmd(int addr, int cmd) { 
.................... 	delay_ms(latencia); 
*
0258:  MOVLW  14
025A:  MOVWF  x95
025C:  RCALL  019C
.................... 	printf("%02u%02u\n\r", addr, cmd); 
025E:  MOVFF  92,95
0262:  MOVLW  01
0264:  MOVWF  x96
0266:  RCALL  01EC
0268:  MOVFF  93,95
026C:  MOVLW  01
026E:  MOVWF  x96
0270:  RCALL  01EC
0272:  MOVLW  0A
0274:  BTFSS  F9E.4
0276:  BRA    0274
0278:  MOVWF  FAD
027A:  MOVLW  0D
027C:  BTFSS  F9E.4
027E:  BRA    027C
0280:  MOVWF  FAD
.................... 	return cmd; 
0282:  MOVFF  93,01
.................... } 
0286:  RETURN 0
....................  
.................... void send_pos(int addr, long pos) { 
.................... 	delay_ms(latencia); 
*
039E:  MOVLW  14
03A0:  MOVWF  x95
03A2:  RCALL  019C
.................... 	printf("%02u%05lu\n\r", addr, pos); 
03A4:  MOVFF  92,95
03A8:  MOVLW  01
03AA:  MOVWF  x96
03AC:  RCALL  01EC
03AE:  MOVLW  08
03B0:  MOVWF  FE9
03B2:  MOVFF  94,96
03B6:  MOVFF  93,95
03BA:  BRA    02F8
03BC:  MOVLW  0A
03BE:  BTFSS  F9E.4
03C0:  BRA    03BE
03C2:  MOVWF  FAD
03C4:  MOVLW  0D
03C6:  BTFSS  F9E.4
03C8:  BRA    03C6
03CA:  MOVWF  FAD
.................... } 
03CC:  GOTO   0684 (RETURN)
....................  
.................... long *recall_pos(int nrSlaves, long pos) { 
.................... 	int i; 
.................... 	static long ret[bufferLen]; 
.................... 	int aux[bufferLen]; 
....................  
.................... 	send_cmd(allSlvs, cmd_w); 
*
0670:  CLRF   x92
0672:  MOVLW  05
0674:  MOVWF  x93
0676:  RCALL  0258
.................... 	send_pos(allSlvs, pos); 
0678:  CLRF   x92
067A:  MOVFF  80,94
067E:  MOVFF  7F,93
0682:  BRA    039E
....................  
.................... 	for (i = 1; i <= nrSlaves; ++i) { 
0684:  MOVLW  01
0686:  MOVWF  x81
0688:  MOVF   x81,W
068A:  SUBWF  7E,W
068C:  BNC   06EC
.................... 		send_cmd(i, cmd_r); 
068E:  MOVFF  81,92
0692:  MOVLW  04
0694:  MOVWF  x93
0696:  RCALL  0258
.................... 		gets(aux); 
0698:  CLRF   FEA
069A:  MOVLW  82
069C:  MOVWF  FE9
069E:  DECF   FE9,F
06A0:  BTFSS  F9E.5
06A2:  BRA    06A0
06A4:  MOVFF  FAE,FEC
06A8:  MOVLW  0D
06AA:  SUBWF  FEF,W
06AC:  BNZ   06A0
06AE:  CLRF   FEC
.................... 		ret[i - 1] = getPos(aux); 
06B0:  MOVLW  01
06B2:  SUBWF  x81,W
06B4:  MOVWF  00
06B6:  BCF    FD8.0
06B8:  RLCF   00,F
06BA:  MOVF   00,W
06BC:  CLRF   03
06BE:  ADDLW  5E
06C0:  MOVWF  01
06C2:  MOVLW  00
06C4:  ADDWFC 03,F
06C6:  MOVFF  01,92
06CA:  MOVFF  03,93
06CE:  CLRF   x95
06D0:  MOVLW  82
06D2:  MOVWF  x94
06D4:  BRA    060E
06D6:  MOVFF  93,FEA
06DA:  MOVFF  92,FE9
06DE:  MOVFF  02,FEC
06E2:  MOVF   FED,F
06E4:  MOVFF  01,FEF
.................... 	} 
06E8:  INCF   x81,F
06EA:  BRA    0688
....................  
.................... 	return ret; 
06EC:  MOVLW  5E
06EE:  MOVWF  01
06F0:  MOVLW  00
06F2:  MOVWF  02
.................... } 
06F4:  GOTO   0774 (RETURN)
....................  
.................... int trata_bto(int cmd) { 
*
0288:  BSF    F93.0
028A:  BCF    7F.0
028C:  BTFSS  F81.0
028E:  BSF    7F.0
0290:  BSF    F93.1
0292:  BCF    7F.1
0294:  BTFSS  F81.1
0296:  BSF    7F.1
0298:  MOVFF  7E,80
.................... 	short sobe = !input(bto_sobe); 
.................... 	short desce = !input(bto_desce); 
.................... 	int ret = cmd; 
....................  
.................... 	if (sobe ^ desce) { 
029C:  MOVLW  00
029E:  BTFSC  7F.0
02A0:  MOVLW  01
02A2:  MOVWF  x82
02A4:  MOVLW  00
02A6:  BTFSC  7F.1
02A8:  MOVLW  01
02AA:  XORWF  x82,W
02AC:  BZ    02E0
.................... 		if (!ctrl_bto) { 
02AE:  BTFSC  1F.0
02B0:  BRA    02DE
.................... 			delay_ms(debounce); 
02B2:  MOVLW  64
02B4:  MOVWF  x95
02B6:  RCALL  019C
.................... 			if (!input(bto_sobe)) 
02B8:  BSF    F93.0
02BA:  BTFSC  F81.0
02BC:  BRA    02CA
.................... 				ret = send_cmd(allSlvs, cmd_subir); 
02BE:  CLRF   x92
02C0:  MOVLW  01
02C2:  MOVWF  x93
02C4:  RCALL  0258
02C6:  MOVFF  01,80
.................... 			if (!input(bto_desce)) 
02CA:  BSF    F93.1
02CC:  BTFSC  F81.1
02CE:  BRA    02DC
.................... 				ret = send_cmd(allSlvs, cmd_descer); 
02D0:  CLRF   x92
02D2:  MOVLW  02
02D4:  MOVWF  x93
02D6:  RCALL  0258
02D8:  MOVFF  01,80
.................... 			ctrl_bto = TRUE; 
02DC:  BSF    1F.0
.................... 		} 
.................... 	} else if (ctrl_bto) { 
02DE:  BRA    02F0
02E0:  BTFSS  1F.0
02E2:  BRA    02F0
.................... 		ctrl_bto = FALSE; 
02E4:  BCF    1F.0
.................... 		ret = send_cmd(allSlvs, cmd_parar); 
02E6:  CLRF   x92
02E8:  CLRF   x93
02EA:  RCALL  0258
02EC:  MOVFF  01,80
.................... 	} 
....................  
.................... 	return ret; 
02F0:  MOVFF  80,01
.................... } 
02F4:  GOTO   0756 (RETURN)
....................  
.................... int trata_comunicacao() { 
....................  
.................... 	r_addr = 0xFF; 
.................... 	r_cmd = 0xFF; 
....................  
.................... 	r_addr = getAddr(buffer); 
.................... 	r_cmd = getCmd(buffer); 
....................  
.................... 	if (r_addr == m_addr || !r_addr) { 
.................... 		if (r_cmd == cmd_w) { 
.................... 			while (!RxOk) 
.................... 				; 
.................... 			r_pos = getPos(buffer); 
.................... 		} else if (r_cmd == cmd_r) { 
.................... 			m_pos++; 
.................... 			send_pos(m_addr, m_pos); 
.................... 		} 
.................... 	} 
....................  
.................... 	return r_cmd; 
.................... } 
....................  
.................... void subir() { 
.................... 	output_low(pin_desce); 
.................... 	delay_ms(latencia >> 1); 
.................... 	output_high(pin_sobe); 
.................... } 
....................  
.................... void descer() { 
.................... 	output_low(pin_sobe); 
.................... 	delay_ms(latencia >> 1); 
.................... 	output_high(pin_desce); 
.................... } 
....................  
.................... void parar() { 
.................... 	output_low(pin_sobe); 
*
0170:  BCF    F94.0
0172:  BCF    F8B.0
.................... 	output_low(pin_desce); 
0174:  BCF    F94.1
0176:  BCF    F8B.1
.................... 	m_pos += get_timer0(); 
0178:  MOVF   FD6,W
017A:  ADDWF  3A,F
017C:  MOVF   FD7,W
017E:  ADDWFC 3B,F
.................... 	set_timer0(0); 
0180:  CLRF   FD7
0182:  CLRF   FD6
.................... } 
0184:  GOTO   0198 (RETURN)
....................  
.................... int getMAddr() { 
*
0152:  SETF   F92
0154:  MOVFF  F80,7E
.................... 	int aux = input_a(); 
.................... 	return ((input_a() & 0xF0) >> 4) & 0x0F; 
0158:  SETF   F92
015A:  MOVF   F80,W
015C:  ANDLW  F0
015E:  MOVWF  00
0160:  SWAPF  00,F
0162:  MOVLW  0F
0164:  ANDWF  00,F
0166:  MOVF   00,W
0168:  ANDLW  0F
016A:  MOVWF  01
.................... } 
016C:  GOTO   0192 (RETURN)
....................  
.................... void init_mstr() { 
.................... //	set_timer0(T0_EXT_H_TO_L | T0_DIV_1); 
.................... //	set_timer1(T1_EXTERNAL | T1_DIV_BY_1); 
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
*
0188:  BSF    F9D.5
.................... 	enable_interrupts(GLOBAL); 
018A:  MOVLW  C0
018C:  IORWF  FF2,F
....................  
.................... 	m_cmd = cmd_parar; 
018E:  CLRF   23
.................... 	nrSlv = getMAddr(); 
0190:  BRA    0152
0192:  MOVFF  01,25
....................  
.................... 	parar(); 
0196:  BRA    0170
.................... } 
0198:  GOTO   0750 (RETURN)
....................  
.................... void init_slv() { 
.................... //	set_timer0(T0_EXT_H_TO_L | T0_DIV_1); 
.................... //	set_timer1(T1_EXTERNAL | T1_DIV_BY_1); 
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... 	enable_interrupts(GLOBAL); 
....................  
.................... 	m_cmd = cmd_parar; 
.................... 	m_addr = getMAddr(); 
....................  
.................... 	parar(); 
.................... } 
....................  
.................... void trata_cmd(int cmd) { 
....................  
.................... 	switch (cmd) { 
.................... 	case cmd_subir: 
.................... 		subir(); 
.................... 		break; 
.................... 	case cmd_descer: 
.................... 		descer(); 
.................... 		break; 
.................... 	case cmd_parar: 
.................... 		parar(); 
.................... 		cmd_parar; 
.................... 		break; 
.................... 	default: 
.................... 	} 
.................... } 
....................  
.................... short recivedOk(int *buff) { 
.................... 	int *p; 
....................  
.................... 	for (p = buff; *p != '\0'; p++) 
*
00AE:  MOVFF  AC,AE
00B2:  MOVFF  AB,AD
00B6:  MOVFF  AE,03
00BA:  MOVFF  AD,FE9
00BE:  MOVFF  AE,FEA
00C2:  MOVF   FEF,F
00C4:  BZ    00FE
.................... 		if (*p == '\n' && *(p + 1) == '\r') 
00C6:  MOVFF  AE,03
00CA:  MOVFF  AD,FE9
00CE:  MOVFF  AE,FEA
00D2:  MOVF   FEF,W
00D4:  SUBLW  0A
00D6:  BNZ   00F6
00D8:  MOVLW  01
00DA:  ADDWF  xAD,W
00DC:  MOVWF  01
00DE:  MOVLW  00
00E0:  ADDWFC xAE,W
00E2:  MOVWF  03
00E4:  MOVFF  01,FE9
00E8:  MOVWF  FEA
00EA:  MOVF   FEF,W
00EC:  SUBLW  0D
00EE:  BNZ   00F6
.................... 			return TRUE; 
00F0:  MOVLW  01
00F2:  MOVWF  01
00F4:  BRA    0102
00F6:  INCF   xAD,F
00F8:  BTFSC  FD8.2
00FA:  INCF   xAE,F
00FC:  BRA    00B6
....................  
.................... 	return FALSE; 
00FE:  MOVLW  00
0100:  MOVWF  01
.................... } 
0102:  GOTO   013C (RETURN)
....................  
.................... #include "interrupcoes.c" 
.................... /* 
....................  * interrupcoes.c 
....................  * 
....................  *  Created on: 02/09/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #int_rda 
.................... void isr_rda() { 
.................... 	clear_interrupt(INT_RDA); 
.................... 	buffer[line++] = getc(); 
0106:  MOVF   27,W
0108:  INCF   27,F
010A:  CLRF   03
010C:  ADDLW  28
010E:  MOVWF  FE9
0110:  MOVLW  00
0112:  ADDWFC 03,W
0114:  MOVWF  FEA
0116:  BTFSS  F9E.5
0118:  BRA    0116
011A:  MOVFF  FAE,FEF
.................... 	buffer[line] = "\0"; 
011E:  CLRF   03
0120:  MOVF   27,W
0122:  ADDLW  28
0124:  MOVWF  01
0126:  MOVLW  00
0128:  ADDWFC 03,F
012A:  MOVFF  03,FEA
012E:  MOVFF  01,FE9
0132:  CLRF   FEF
.................... 	RxOk = recivedOk(buffer); 
0134:  CLRF   xAC
0136:  MOVLW  28
0138:  MOVWF  xAB
013A:  BRA    00AE
013C:  BCF    1F.1
013E:  BTFSC  01.0
0140:  BSF    1F.1
.................... 	if (RxOk && line) 
0142:  BTFSS  1F.1
0144:  BRA    014C
0146:  MOVF   27,F
0148:  BZ    014C
.................... 		line = 0; 
014A:  CLRF   27
.................... } 
....................  
....................  
014C:  BCF    F9E.5
014E:  GOTO   0060
.................... int main(void) { 
*
06F8:  CLRF   FF8
06FA:  BCF    FD0.7
06FC:  BSF    07.7
06FE:  MOVLW  FE
0700:  MOVWF  00
0702:  MOVLW  06
0704:  MOVWF  01
0706:  MOVLW  02
0708:  MOVWF  FE9
070A:  MOVLW  00
070C:  MOVWF  FEA
070E:  CLRF   FEE
0710:  DECFSZ 00,F
0712:  BRA    070E
0714:  DECFSZ 01,F
0716:  BRA    070E
0718:  CLRF   FEA
071A:  CLRF   FE9
071C:  MOVLW  61
071E:  MOVWF  FAF
0720:  MOVLW  A6
0722:  MOVWF  FAC
0724:  MOVLW  90
0726:  MOVWF  FAB
0728:  SETF   20
072A:  SETF   21
072C:  SETF   22
072E:  SETF   23
0730:  SETF   24
0732:  MOVLW  02
0734:  MOVWF  25
0736:  MOVLW  30
0738:  MOVWF  39
073A:  MOVLW  39
073C:  MOVWF  38
073E:  MOVLW  30
0740:  MOVWF  3B
0742:  MOVLW  39
0744:  MOVWF  3A
0746:  BSF    FC1.0
0748:  BSF    FC1.1
074A:  BSF    FC1.2
074C:  BCF    FC1.3
....................  
.................... 	init_mstr(); 
074E:  BRA    0188
....................  
.................... 	while (TRUE) { 
....................  
.................... 		m_cmd = trata_bto(m_cmd); 
0750:  MOVFF  23,7E
0754:  BRA    0288
0756:  MOVFF  01,23
....................  
.................... 		if (m_cmd == cmd_subir || m_cmd == cmd_descer) { 
075A:  DECFSZ 23,W
075C:  BRA    0760
075E:  BRA    0766
0760:  MOVF   23,W
0762:  SUBLW  02
0764:  BNZ   07CC
.................... 			p = recall_pos(nrSlv, r_pos); 
0766:  MOVFF  25,7E
076A:  MOVFF  39,80
076E:  MOVFF  38,7F
0772:  BRA    0670
0774:  MOVFF  02,3D
0778:  MOVFF  01,3C
.................... 			for (i = 0; i < nrSlv; ++i) { 
077C:  CLRF   26
077E:  MOVF   25,W
0780:  SUBWF  26,W
0782:  BC    07CC
.................... 				pos_slv[i] = *(p + i); 
0784:  BCF    FD8.0
0786:  RLCF   26,W
0788:  CLRF   03
078A:  ADDLW  3E
078C:  MOVWF  01
078E:  MOVLW  00
0790:  ADDWFC 03,F
0792:  MOVFF  01,7E
0796:  MOVFF  03,7F
079A:  BCF    FD8.0
079C:  RLCF   26,W
079E:  ADDWF  3C,W
07A0:  MOVWF  01
07A2:  MOVLW  00
07A4:  ADDWFC 3D,W
07A6:  MOVFF  01,FE9
07AA:  MOVWF  FEA
07AC:  MOVFF  FEC,03
07B0:  MOVF   FED,F
07B2:  MOVFF  FEF,80
07B6:  MOVFF  7F,FEA
07BA:  MOVFF  7E,FE9
07BE:  MOVFF  03,FEC
07C2:  MOVF   FED,F
07C4:  MOVFF  80,FEF
.................... 			} 
07C8:  INCF   26,F
07CA:  BRA    077E
.................... 		} 
.................... 		delay_ms(100); 
07CC:  MOVLW  64
07CE:  MOVWF  x95
07D0:  RCALL  019C
.................... 	} 
07D2:  BRA    0750
....................  
.................... 	return 0; 
07D4:  MOVLW  00
07D6:  MOVWF  01
.................... } 
....................  
07D8:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
