CCS PCH C Compiler, Version 4.140, 22098               20-ago-14 16:50

               Filename:   D:\Projetos\Serial\master.lst

               ROM used:   2130 bytes (7%)
                           Largest free fragment is 30634
               RAM used:   198 (13%) at main() level
                           238 (15%) worst case
               Stack:     5 worst case (4 in main + 1 for interrupts)

*
0000:  GOTO   07AE
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00FA
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   00BA
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... /* 
....................  * master.c 
....................  * 
....................  *  Created on: 18/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #include<18F252.h> 
.................... //////// Standard Header file for the PIC18F252 device //////////////// 
.................... #device PIC18F252 
.................... #list 
....................  
.................... #zero_ram 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
02A2:  CLRF   xD3
....................    sign = 0; 
02A4:  CLRF   xD1
....................    base = 10; 
02A6:  MOVLW  0A
02A8:  MOVWF  xD2
....................    result = 0; 
02AA:  CLRF   xD0
....................  
....................    if (!s) 
02AC:  MOVF   xCE,W
02AE:  IORWF  xCF,W
02B0:  BNZ   02B8
....................       return 0; 
02B2:  MOVLW  00
02B4:  MOVWF  01
02B6:  BRA    043A
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
02B8:  MOVF   xD3,W
02BA:  INCF   xD3,F
02BC:  CLRF   03
02BE:  ADDWF  xCE,W
02C0:  MOVWF  FE9
02C2:  MOVF   xCF,W
02C4:  ADDWFC 03,W
02C6:  MOVWF  FEA
02C8:  MOVFF  FEF,D4
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
02CC:  MOVF   xD4,W
02CE:  SUBLW  2D
02D0:  BNZ   02EC
....................    { 
....................       sign = 1;         // Set the sign to negative 
02D2:  MOVLW  01
02D4:  MOVWF  xD1
....................       c = s[index++]; 
02D6:  MOVF   xD3,W
02D8:  INCF   xD3,F
02DA:  CLRF   03
02DC:  ADDWF  xCE,W
02DE:  MOVWF  FE9
02E0:  MOVF   xCF,W
02E2:  ADDWFC 03,W
02E4:  MOVWF  FEA
02E6:  MOVFF  FEF,D4
....................    } 
....................    else if (c == '+') 
02EA:  BRA    0306
02EC:  MOVF   xD4,W
02EE:  SUBLW  2B
02F0:  BNZ   0306
....................    { 
....................       c = s[index++]; 
02F2:  MOVF   xD3,W
02F4:  INCF   xD3,F
02F6:  CLRF   03
02F8:  ADDWF  xCE,W
02FA:  MOVWF  FE9
02FC:  MOVF   xCF,W
02FE:  ADDWFC 03,W
0300:  MOVWF  FEA
0302:  MOVFF  FEF,D4
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0306:  MOVF   xD4,W
0308:  SUBLW  2F
030A:  BTFSC  FD8.0
030C:  BRA    042A
030E:  MOVF   xD4,W
0310:  SUBLW  39
0312:  BTFSS  FD8.0
0314:  BRA    042A
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0316:  MOVF   xD4,W
0318:  SUBLW  30
031A:  BNZ   035E
031C:  CLRF   03
031E:  MOVF   xD3,W
0320:  ADDWF  xCE,W
0322:  MOVWF  FE9
0324:  MOVF   xCF,W
0326:  ADDWFC 03,W
0328:  MOVWF  FEA
032A:  MOVF   FEF,W
032C:  SUBLW  78
032E:  BZ    0344
0330:  CLRF   03
0332:  MOVF   xD3,W
0334:  ADDWF  xCE,W
0336:  MOVWF  FE9
0338:  MOVF   xCF,W
033A:  ADDWFC 03,W
033C:  MOVWF  FEA
033E:  MOVF   FEF,W
0340:  SUBLW  58
0342:  BNZ   035E
....................       { 
....................          base = 16; 
0344:  MOVLW  10
0346:  MOVWF  xD2
....................          index++; 
0348:  INCF   xD3,F
....................          c = s[index++]; 
034A:  MOVF   xD3,W
034C:  INCF   xD3,F
034E:  CLRF   03
0350:  ADDWF  xCE,W
0352:  MOVWF  FE9
0354:  MOVF   xCF,W
0356:  ADDWFC 03,W
0358:  MOVWF  FEA
035A:  MOVFF  FEF,D4
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
035E:  MOVF   xD2,W
0360:  SUBLW  0A
0362:  BNZ   039A
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0364:  MOVF   xD4,W
0366:  SUBLW  2F
0368:  BC    0398
036A:  MOVF   xD4,W
036C:  SUBLW  39
036E:  BNC   0398
....................             result = 10*result + (c - '0'); 
0370:  MOVLW  0A
0372:  MOVWF  xD5
0374:  MOVFF  D0,D6
0378:  BRA    0256
037A:  MOVLW  30
037C:  SUBWF  xD4,W
037E:  ADDWF  01,W
0380:  MOVWF  xD0
....................             c = s[index++]; 
0382:  MOVF   xD3,W
0384:  INCF   xD3,F
0386:  CLRF   03
0388:  ADDWF  xCE,W
038A:  MOVWF  FE9
038C:  MOVF   xCF,W
038E:  ADDWFC 03,W
0390:  MOVWF  FEA
0392:  MOVFF  FEF,D4
....................          } 
0396:  BRA    0364
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0398:  BRA    042A
039A:  MOVF   xD2,W
039C:  SUBLW  10
039E:  BNZ   042A
....................       { 
....................          c = toupper(c); 
03A0:  MOVF   xD4,W
03A2:  SUBLW  60
03A4:  BC    03B2
03A6:  MOVF   xD4,W
03A8:  SUBLW  7A
03AA:  BNC   03B2
03AC:  MOVF   xD4,W
03AE:  ANDLW  DF
03B0:  BRA    03B4
03B2:  MOVF   xD4,W
03B4:  MOVWF  xD4
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
03B6:  MOVF   xD4,W
03B8:  SUBLW  2F
03BA:  BC    03C2
03BC:  MOVF   xD4,W
03BE:  SUBLW  39
03C0:  BC    03CE
03C2:  MOVF   xD4,W
03C4:  SUBLW  40
03C6:  BC    042A
03C8:  MOVF   xD4,W
03CA:  SUBLW  46
03CC:  BNC   042A
....................             if (c >= '0' && c <= '9') 
03CE:  MOVF   xD4,W
03D0:  SUBLW  2F
03D2:  BC    03EC
03D4:  MOVF   xD4,W
03D6:  SUBLW  39
03D8:  BNC   03EC
....................                result = (result << 4) + (c - '0'); 
03DA:  SWAPF  xD0,W
03DC:  MOVWF  xD5
03DE:  MOVLW  F0
03E0:  ANDWF  xD5,F
03E2:  MOVLW  30
03E4:  SUBWF  xD4,W
03E6:  ADDWF  xD5,W
03E8:  MOVWF  xD0
....................             else 
03EA:  BRA    03FE
....................                result = (result << 4) + (c - 'A' + 10); 
03EC:  SWAPF  xD0,W
03EE:  MOVWF  xD5
03F0:  MOVLW  F0
03F2:  ANDWF  xD5,F
03F4:  MOVLW  41
03F6:  SUBWF  xD4,W
03F8:  ADDLW  0A
03FA:  ADDWF  xD5,W
03FC:  MOVWF  xD0
....................  
....................             c = s[index++]; 
03FE:  MOVF   xD3,W
0400:  INCF   xD3,F
0402:  CLRF   03
0404:  ADDWF  xCE,W
0406:  MOVWF  FE9
0408:  MOVF   xCF,W
040A:  ADDWFC 03,W
040C:  MOVWF  FEA
040E:  MOVFF  FEF,D4
....................             c = toupper(c); 
0412:  MOVF   xD4,W
0414:  SUBLW  60
0416:  BC    0424
0418:  MOVF   xD4,W
041A:  SUBLW  7A
041C:  BNC   0424
041E:  MOVF   xD4,W
0420:  ANDLW  DF
0422:  BRA    0426
0424:  MOVF   xD4,W
0426:  MOVWF  xD4
....................          } 
0428:  BRA    03B6
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
042A:  DECFSZ xD1,W
042C:  BRA    0436
042E:  MOVF   xD2,W
0430:  SUBLW  0A
0432:  BNZ   0436
....................        result = -result; 
0434:  NEGF   xD0
....................  
....................    return(result); 
0436:  MOVFF  D0,01
.................... } 
043A:  GOTO   0490 (RETURN)
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
04EE:  CLRF   xE4
....................    sign = 0; 
04F0:  CLRF   xE2
....................    base = 10; 
04F2:  MOVLW  0A
04F4:  MOVWF  xE3
....................    result = 0; 
04F6:  CLRF   xE1
04F8:  CLRF   xE0
....................  
....................    if (!s) 
04FA:  MOVF   xDE,W
04FC:  IORWF  xDF,W
04FE:  BNZ   0508
....................       return 0; 
0500:  MOVLW  00
0502:  MOVWF  01
0504:  MOVWF  02
0506:  BRA    06D6
....................    c = s[index++]; 
0508:  MOVF   xE4,W
050A:  INCF   xE4,F
050C:  CLRF   03
050E:  ADDWF  xDE,W
0510:  MOVWF  FE9
0512:  MOVF   xDF,W
0514:  ADDWFC 03,W
0516:  MOVWF  FEA
0518:  MOVFF  FEF,E5
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
051C:  MOVF   xE5,W
051E:  SUBLW  2D
0520:  BNZ   053C
....................    { 
....................       sign = 1;         // Set the sign to negative 
0522:  MOVLW  01
0524:  MOVWF  xE2
....................       c = s[index++]; 
0526:  MOVF   xE4,W
0528:  INCF   xE4,F
052A:  CLRF   03
052C:  ADDWF  xDE,W
052E:  MOVWF  FE9
0530:  MOVF   xDF,W
0532:  ADDWFC 03,W
0534:  MOVWF  FEA
0536:  MOVFF  FEF,E5
....................    } 
....................    else if (c == '+') 
053A:  BRA    0556
053C:  MOVF   xE5,W
053E:  SUBLW  2B
0540:  BNZ   0556
....................    { 
....................       c = s[index++]; 
0542:  MOVF   xE4,W
0544:  INCF   xE4,F
0546:  CLRF   03
0548:  ADDWF  xDE,W
054A:  MOVWF  FE9
054C:  MOVF   xDF,W
054E:  ADDWFC 03,W
0550:  MOVWF  FEA
0552:  MOVFF  FEF,E5
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0556:  MOVF   xE5,W
0558:  SUBLW  2F
055A:  BTFSC  FD8.0
055C:  BRA    06BA
055E:  MOVF   xE5,W
0560:  SUBLW  39
0562:  BTFSS  FD8.0
0564:  BRA    06BA
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0566:  MOVF   xE5,W
0568:  SUBLW  30
056A:  BNZ   05AE
056C:  CLRF   03
056E:  MOVF   xE4,W
0570:  ADDWF  xDE,W
0572:  MOVWF  FE9
0574:  MOVF   xDF,W
0576:  ADDWFC 03,W
0578:  MOVWF  FEA
057A:  MOVF   FEF,W
057C:  SUBLW  78
057E:  BZ    0594
0580:  CLRF   03
0582:  MOVF   xE4,W
0584:  ADDWF  xDE,W
0586:  MOVWF  FE9
0588:  MOVF   xDF,W
058A:  ADDWFC 03,W
058C:  MOVWF  FEA
058E:  MOVF   FEF,W
0590:  SUBLW  58
0592:  BNZ   05AE
....................       { 
....................          base = 16; 
0594:  MOVLW  10
0596:  MOVWF  xE3
....................          index++; 
0598:  INCF   xE4,F
....................          c = s[index++]; 
059A:  MOVF   xE4,W
059C:  INCF   xE4,F
059E:  CLRF   03
05A0:  ADDWF  xDE,W
05A2:  MOVWF  FE9
05A4:  MOVF   xDF,W
05A6:  ADDWFC 03,W
05A8:  MOVWF  FEA
05AA:  MOVFF  FEF,E5
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
05AE:  MOVF   xE3,W
05B0:  SUBLW  0A
05B2:  BNZ   05F6
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
05B4:  MOVF   xE5,W
05B6:  SUBLW  2F
05B8:  BC    05F4
05BA:  MOVF   xE5,W
05BC:  SUBLW  39
05BE:  BNC   05F4
....................             result = 10*result + (c - '0'); 
05C0:  CLRF   xE7
05C2:  MOVLW  0A
05C4:  MOVWF  xE6
05C6:  MOVFF  E1,E9
05CA:  MOVFF  E0,E8
05CE:  BRA    049C
05D0:  MOVLW  30
05D2:  SUBWF  xE5,W
05D4:  ADDWF  01,W
05D6:  MOVWF  xE0
05D8:  MOVLW  00
05DA:  ADDWFC 02,W
05DC:  MOVWF  xE1
....................             c = s[index++]; 
05DE:  MOVF   xE4,W
05E0:  INCF   xE4,F
05E2:  CLRF   03
05E4:  ADDWF  xDE,W
05E6:  MOVWF  FE9
05E8:  MOVF   xDF,W
05EA:  ADDWFC 03,W
05EC:  MOVWF  FEA
05EE:  MOVFF  FEF,E5
....................          } 
05F2:  BRA    05B4
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
05F4:  BRA    06BA
05F6:  MOVF   xE3,W
05F8:  SUBLW  10
05FA:  BNZ   06BA
....................       { 
....................          c = toupper(c); 
05FC:  MOVF   xE5,W
05FE:  SUBLW  60
0600:  BC    060E
0602:  MOVF   xE5,W
0604:  SUBLW  7A
0606:  BNC   060E
0608:  MOVF   xE5,W
060A:  ANDLW  DF
060C:  BRA    0610
060E:  MOVF   xE5,W
0610:  MOVWF  xE5
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
0612:  MOVF   xE5,W
0614:  SUBLW  2F
0616:  BC    061E
0618:  MOVF   xE5,W
061A:  SUBLW  39
061C:  BC    062A
061E:  MOVF   xE5,W
0620:  SUBLW  40
0622:  BC    06BA
0624:  MOVF   xE5,W
0626:  SUBLW  46
0628:  BNC   06BA
....................             if (c >= '0' && c <= '9') 
062A:  MOVF   xE5,W
062C:  SUBLW  2F
062E:  BC    0662
0630:  MOVF   xE5,W
0632:  SUBLW  39
0634:  BNC   0662
....................                result = (result << 4) + (c - '0'); 
0636:  RLCF   xE0,W
0638:  MOVWF  xE6
063A:  RLCF   xE1,W
063C:  MOVWF  xE7
063E:  RLCF   xE6,F
0640:  RLCF   xE7,F
0642:  RLCF   xE6,F
0644:  RLCF   xE7,F
0646:  RLCF   xE6,F
0648:  RLCF   xE7,F
064A:  MOVLW  F0
064C:  ANDWF  xE6,F
064E:  MOVLW  30
0650:  SUBWF  xE5,W
0652:  ADDWF  xE6,W
0654:  MOVWF  01
0656:  MOVLW  00
0658:  ADDWFC xE7,W
065A:  MOVFF  01,E0
065E:  MOVWF  xE1
....................             else 
0660:  BRA    068E
....................                result = (result << 4) + (c - 'A' + 10); 
0662:  RLCF   xE0,W
0664:  MOVWF  xE6
0666:  RLCF   xE1,W
0668:  MOVWF  xE7
066A:  RLCF   xE6,F
066C:  RLCF   xE7,F
066E:  RLCF   xE6,F
0670:  RLCF   xE7,F
0672:  RLCF   xE6,F
0674:  RLCF   xE7,F
0676:  MOVLW  F0
0678:  ANDWF  xE6,F
067A:  MOVLW  41
067C:  SUBWF  xE5,W
067E:  ADDLW  0A
0680:  ADDWF  xE6,W
0682:  MOVWF  01
0684:  MOVLW  00
0686:  ADDWFC xE7,W
0688:  MOVFF  01,E0
068C:  MOVWF  xE1
....................  
....................             c = s[index++];c = toupper(c); 
068E:  MOVF   xE4,W
0690:  INCF   xE4,F
0692:  CLRF   03
0694:  ADDWF  xDE,W
0696:  MOVWF  FE9
0698:  MOVF   xDF,W
069A:  ADDWFC 03,W
069C:  MOVWF  FEA
069E:  MOVFF  FEF,E5
06A2:  MOVF   xE5,W
06A4:  SUBLW  60
06A6:  BC    06B4
06A8:  MOVF   xE5,W
06AA:  SUBLW  7A
06AC:  BNC   06B4
06AE:  MOVF   xE5,W
06B0:  ANDLW  DF
06B2:  BRA    06B6
06B4:  MOVF   xE5,W
06B6:  MOVWF  xE5
....................          } 
06B8:  BRA    0612
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
06BA:  MOVF   xE3,W
06BC:  SUBLW  0A
06BE:  BNZ   06CE
06C0:  DECFSZ xE2,W
06C2:  BRA    06CE
....................       result = -result; 
06C4:  COMF   xE0,F
06C6:  COMF   xE1,F
06C8:  INCF   xE0,F
06CA:  BTFSC  FD8.2
06CC:  INCF   xE1,F
....................  
....................    return(result); 
06CE:  MOVFF  E0,01
06D2:  MOVFF  E1,02
.................... } 
06D6:  GOTO   0730 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS 
.................... #use delay(clock=15MHz) 
*
010E:  CLRF   FEA
0110:  MOVLW  C9
0112:  MOVWF  FE9
0114:  MOVF   FEF,W
0116:  BZ    0134
0118:  MOVLW  04
011A:  MOVWF  01
011C:  CLRF   00
011E:  DECFSZ 00,F
0120:  BRA    011E
0122:  DECFSZ 01,F
0124:  BRA    011C
0126:  MOVLW  DC
0128:  MOVWF  00
012A:  DECFSZ 00,F
012C:  BRA    012A
012E:  NOP   
0130:  DECFSZ FEF,F
0132:  BRA    0118
0134:  RETURN 0
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................  
.................... #include "definicoes.c" 
.................... /* 
....................  * definicoes.c 
....................  * 
....................  *  Created on: 20/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... //defines 
.................... #define buffer_size 128 
.................... #define vbto_parar 0 
.................... #define max_slv	16 
.................... //cmd 
.................... #define cmd_parar	0x00 
.................... #define cmd_subir	0x01 
.................... #define cmd_descer	0x02 
.................... #define cmd_pos		0x03 
.................... //entradas 
.................... #define bto_sobe	PIN_B0 
.................... #define bto_desce	PIN_B1 
.................... //saidas 
.................... #define saida_sobe	PIN_C0 
.................... #define saida_desce	PIN_C1 
.................... //tempos 
.................... #define debounce 100 
....................  
.................... #include "variaveis.c" 
.................... /* 
....................  * variaveis.c 
....................  * 
....................  *  Created on: 20/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... int buffer[buffer_size]; 
.................... int line = 0; 
.................... int addr = 1; 
.................... int r_addr = 10; 
....................  
.................... short recived = FALSE; 
.................... short en_timer2 = TRUE; 
.................... //escravo 
.................... int r_cmd = 0; 
.................... //mestre 
.................... int nrSlaves = 2; 
.................... int i = 0; 
....................  
.................... long pos_elev[max_slv]; 
....................  
....................  
.................... #include "interrupcoes.c" 
.................... /* 
....................  * interrupcoes.c 
....................  * 
....................  *  Created on: 20/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #INT_RDA 
.................... void serial_isr() { 
.................... 	clear_interrupt(INT_RDA); 
.................... 	buffer[line++] = getc(); 
*
00BA:  MOVF   x9F,W
00BC:  INCF   x9F,F
00BE:  CLRF   03
00C0:  ADDLW  1F
00C2:  MOVWF  FE9
00C4:  MOVLW  00
00C6:  ADDWFC 03,W
00C8:  MOVWF  FEA
00CA:  BTFSS  F9E.5
00CC:  BRA    00CA
00CE:  MOVFF  FAE,FEF
.................... 	buffer[line] = '\0'; 
00D2:  CLRF   03
00D4:  MOVF   x9F,W
00D6:  ADDLW  1F
00D8:  MOVWF  FE9
00DA:  MOVLW  00
00DC:  ADDWFC 03,W
00DE:  MOVWF  FEA
00E0:  CLRF   FEF
.................... 	set_timer2(0); 
00E2:  CLRF   FCC
.................... 	if (en_timer2) { 
00E4:  BTFSS  xA2.1
00E6:  BRA    00F4
.................... 		en_timer2 = FALSE; 
00E8:  BCF    xA2.1
.................... 		setup_timer_2(T2_DIV_BY_16, 255, 1); 
00EA:  MOVLW  00
00EC:  IORLW  06
00EE:  MOVWF  FCA
00F0:  MOVLW  FF
00F2:  MOVWF  FCB
.................... 	} 
.................... } 
....................  
00F4:  BCF    F9E.5
00F6:  GOTO   006C
.................... #INT_TIMER2 
.................... void timer2_isr() { 
.................... 	clear_interrupt(INT_TIMER2); 
00FA:  BCF    F9E.1
.................... 	setup_timer_2(T2_DISABLED, 255, 1); 
00FC:  MOVLW  00
00FE:  MOVWF  FCA
0100:  MOVLW  FF
0102:  MOVWF  FCB
.................... 	set_timer2(0); 
0104:  CLRF   FCC
.................... 	recived = TRUE; 
0106:  BSF    xA2.0
.................... } 
....................  
.................... #include "funcoes.c" 
.................... /* 
....................  * fucoes.c 
....................  * 
....................  *  Created on: 20/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
0108:  BCF    F9E.1
010A:  GOTO   006C
.................... int trans_addr(int *ptr) { 
*
043E:  SETF   xC9
.................... 	int ret = 0xFF; 
.................... 	int aux[2]; 
.................... 	int *p; 
....................  
.................... 	for (p = ptr; *p != '\0'; p++) 
0440:  MOVFF  C8,CD
0444:  MOVFF  C7,CC
0448:  MOVFF  CD,03
044C:  MOVFF  CC,FE9
0450:  MOVFF  CD,FEA
0454:  MOVF   FEF,F
0456:  BZ    0460
.................... 		; 
0458:  INCF   xCC,F
045A:  BTFSC  FD8.2
045C:  INCF   xCD,F
045E:  BRA    0448
....................  
.................... 	aux[0] = *(p - 4); 
0460:  MOVLW  04
0462:  SUBWF  xCC,W
0464:  MOVWF  00
0466:  MOVLW  00
0468:  SUBWFB xCD,W
046A:  MOVFF  00,FE9
046E:  MOVWF  FEA
0470:  MOVFF  FEF,CA
.................... 	aux[1] = *(p - 3); 
0474:  MOVLW  03
0476:  SUBWF  xCC,W
0478:  MOVWF  00
047A:  MOVLW  00
047C:  SUBWFB xCD,W
047E:  MOVFF  00,FE9
0482:  MOVWF  FEA
0484:  MOVFF  FEF,CB
....................  
.................... 	ret = atoi(aux); 
0488:  CLRF   xCF
048A:  MOVLW  CA
048C:  MOVWF  xCE
048E:  BRA    02A2
0490:  MOVFF  01,C9
....................  
.................... 	return ret; 
0494:  MOVFF  C9,01
.................... } 
0498:  GOTO   076C (RETURN)
....................  
.................... long trans_pos(int *ptr) { 
*
06DA:  SETF   xCC
06DC:  SETF   xCB
06DE:  CLRF   xDD
....................  
.................... 	long ret = 0xFFFF; 
.................... 	int posArray[16]; 
.................... 	int i = 0; 
....................  
.................... 	for (i = 1; i < line; ++i) { 
06E0:  MOVLW  01
06E2:  MOVWF  xDD
06E4:  MOVF   x9F,W
06E6:  SUBWF  xDD,W
06E8:  BC    0728
.................... 		posArray[i - 1] = *ptr[i]; 
06EA:  MOVLW  01
06EC:  SUBWF  xDD,W
06EE:  CLRF   03
06F0:  ADDLW  CD
06F2:  MOVWF  01
06F4:  MOVLW  00
06F6:  ADDWFC 03,F
06F8:  MOVFF  03,DF
06FC:  CLRF   03
06FE:  MOVF   xDD,W
0700:  ADDWF  xC9,W
0702:  MOVWF  FE9
0704:  MOVF   xCA,W
0706:  ADDWFC 03,W
0708:  MOVWF  FEA
070A:  MOVF   FEF,W
070C:  CLRF   03
070E:  MOVWF  FE9
0710:  MOVFF  03,FEA
0714:  MOVFF  FEF,E0
0718:  MOVFF  DF,FEA
071C:  MOVFF  01,FE9
0720:  MOVFF  E0,FEF
.................... 	} 
0724:  INCF   xDD,F
0726:  BRA    06E4
....................  
.................... 	ret = atol(posArray); 
0728:  CLRF   xDF
072A:  MOVLW  CD
072C:  MOVWF  xDE
072E:  BRA    04EE
0730:  MOVFF  02,CC
0734:  MOVFF  01,CB
....................  
.................... 	return ret; 
0738:  MOVFF  CB,01
073C:  MOVFF  CC,02
.................... } 
0740:  GOTO   078E (RETURN)
....................  
.................... int trans_cmd(int *ptr) { 
.................... 	int ret = 0xFF; 
.................... 	int aux[2]; 
.................... 	int *p; 
....................  
.................... 	for (p = ptr; *p != '\0'; p++) 
.................... 		; 
....................  
.................... 	aux[0] = *(p - 2); 
.................... 	aux[1] = *(p - 1); 
....................  
.................... 	ret = atoi(aux); 
....................  
.................... 	return ret; 
.................... } 
....................  
....................  
.................... short send_stp = TRUE; 
.................... short ctrl_bto = FALSE; 
.................... short recolhe = FALSE; 
....................  
.................... int trata_bto() { 
*
0136:  BSF    F93.0
0138:  BCF    xC6.0
013A:  BTFSS  F81.0
013C:  BSF    xC6.0
013E:  BSF    F93.1
0140:  BCF    xC6.1
0142:  BTFSS  F81.1
0144:  BSF    xC6.1
0146:  SETF   xC7
.................... 	short sobe = !input(bto_sobe); 
.................... 	short desce = !input(bto_desce); 
.................... 	int ret = 0xFF; 
....................  
.................... 	if (sobe ^ desce) { 
0148:  MOVLW  00
014A:  BTFSC  xC6.0
014C:  MOVLW  01
014E:  MOVWF  xC9
0150:  MOVLW  00
0152:  BTFSC  xC6.1
0154:  MOVLW  01
0156:  XORWF  xC9,W
0158:  BZ    017C
.................... 		if (!ctrl_bto) { 
015A:  BTFSC  xA2.3
015C:  BRA    017A
.................... 			delay_ms(debounce); 
015E:  MOVLW  64
0160:  MOVWF  xC9
0162:  RCALL  010E
.................... 			if (!input(bto_sobe)) 
0164:  BSF    F93.0
0166:  BTFSC  F81.0
0168:  BRA    016E
.................... 				ret = bto_sobe; 
016A:  MOVLW  08
016C:  MOVWF  xC7
.................... 			if (!input(bto_desce)) 
016E:  BSF    F93.1
0170:  BTFSC  F81.1
0172:  BRA    0178
.................... 				ret = bto_desce; 
0174:  MOVLW  09
0176:  MOVWF  xC7
.................... 			ctrl_bto = TRUE; 
0178:  BSF    xA2.3
.................... 		} 
.................... 	} else if (ctrl_bto) { 
017A:  BRA    0184
017C:  BTFSS  xA2.3
017E:  BRA    0184
.................... 		ctrl_bto = FALSE; 
0180:  BCF    xA2.3
.................... 		ret = vbto_parar; 
0182:  CLRF   xC7
.................... 	} 
....................  
.................... 	return ret; 
0184:  MOVFF  C7,01
.................... } 
0188:  GOTO   0818 (RETURN)
....................  
.................... void send(int iaddr, int iCmd) { 
.................... 	printf("\n\r%02u%02u", iaddr, iCmd); 
*
0220:  MOVLW  0A
0222:  BTFSS  F9E.4
0224:  BRA    0222
0226:  MOVWF  FAD
0228:  MOVLW  0D
022A:  BTFSS  F9E.4
022C:  BRA    022A
022E:  MOVWF  FAD
0230:  MOVFF  C7,C9
0234:  MOVLW  01
0236:  MOVWF  xCA
0238:  RCALL  01B4
023A:  MOVFF  C8,C9
023E:  MOVLW  01
0240:  MOVWF  xCA
0242:  RCALL  01B4
.................... 	delay_ms(10); 
0244:  MOVLW  0A
0246:  MOVWF  xC9
0248:  RCALL  010E
.................... } 
024A:  RETURN 0
....................  
.................... void sendAll(int iCmd) { 
.................... 	send(0, iCmd); 
024C:  CLRF   xC7
024E:  MOVFF  C6,C8
0252:  RCALL  0220
.................... } 
0254:  RETURN 0
....................  
.................... void read() { 
*
0744:  CLRF   xC6
.................... 	int i = 0; 
....................  
.................... 	for (i = 1; i <= nrSlaves; ++i) { 
0746:  MOVLW  01
0748:  MOVWF  xC6
074A:  MOVF   xC6,W
074C:  SUBWF  xA4,W
074E:  BNC   07AA
.................... 		send(i, cmd_pos); 
0750:  MOVFF  C6,C7
0754:  MOVLW  03
0756:  MOVWF  xC8
0758:  RCALL  0220
....................  
.................... 		while (!recived) 
.................... 			; 
075A:  BTFSS  xA2.0
075C:  BRA    075A
.................... 		if (recived) { 
075E:  BTFSS  xA2.0
0760:  BRA    07A6
.................... 			recived = FALSE; 
0762:  BCF    xA2.0
.................... 			r_addr = trans_addr(buffer); 
0764:  CLRF   xC8
0766:  MOVLW  1F
0768:  MOVWF  xC7
076A:  BRA    043E
076C:  MOVFF  01,A1
.................... 			pos_elev[r_addr] = trans_pos(buffer); 
0770:  BCF    FD8.0
0772:  RLCF   xA1,W
0774:  CLRF   03
0776:  ADDLW  A6
0778:  MOVWF  01
077A:  MOVLW  00
077C:  ADDWFC 03,F
077E:  MOVFF  01,C7
0782:  MOVFF  03,C8
0786:  CLRF   xCA
0788:  MOVLW  1F
078A:  MOVWF  xC9
078C:  BRA    06DA
078E:  MOVFF  C8,FEA
0792:  MOVFF  C7,FE9
0796:  MOVFF  02,FEC
079A:  MOVF   FED,F
079C:  MOVFF  01,FEF
.................... 			buffer[0] = '\0'; 
07A0:  CLRF   1F
.................... 			line = 0; 
07A2:  CLRF   x9F
.................... 			en_timer2 = TRUE; 
07A4:  BSF    xA2.1
.................... 		} 
.................... 	} 
07A6:  INCF   xC6,F
07A8:  BRA    074A
.................... } 
07AA:  GOTO   0848 (RETURN)
....................  
.................... int main(void) { 
07AE:  CLRF   FF8
07B0:  BCF    FD0.7
07B2:  BSF    07.7
07B4:  MOVLW  FE
07B6:  MOVWF  00
07B8:  MOVLW  06
07BA:  MOVWF  01
07BC:  MOVLW  02
07BE:  MOVWF  FE9
07C0:  MOVLW  00
07C2:  MOVWF  FEA
07C4:  CLRF   FEE
07C6:  DECFSZ 00,F
07C8:  BRA    07C4
07CA:  DECFSZ 01,F
07CC:  BRA    07C4
07CE:  CLRF   FEA
07D0:  CLRF   FE9
07D2:  MOVLW  61
07D4:  MOVWF  FAF
07D6:  MOVLW  A6
07D8:  MOVWF  FAC
07DA:  MOVLW  90
07DC:  MOVWF  FAB
07DE:  CLRF   x9F
07E0:  MOVLW  01
07E2:  MOVWF  xA0
07E4:  MOVLW  0A
07E6:  MOVWF  xA1
07E8:  BCF    xA2.0
07EA:  BSF    xA2.1
07EC:  CLRF   xA3
07EE:  MOVLW  02
07F0:  MOVWF  xA4
07F2:  CLRF   xA5
07F4:  BSF    xA2.2
07F6:  BCF    xA2.3
07F8:  BCF    xA2.4
07FA:  BSF    FC1.0
07FC:  BSF    FC1.1
07FE:  BSF    FC1.2
0800:  BCF    FC1.3
....................  
.................... 	clear_interrupt(INT_TIMER2); 
0802:  BCF    F9E.1
.................... 	set_timer2(0); 
0804:  CLRF   FCC
.................... 	setup_timer_2(T2_DISABLED, 255, 1); 
0806:  MOVLW  00
0808:  MOVWF  FCA
080A:  MOVLW  FF
080C:  MOVWF  FCB
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
080E:  BSF    F9D.5
.................... 	enable_interrupts(INT_TIMER2); 
0810:  BSF    F9D.1
.................... 	enable_interrupts(GLOBAL); 
0812:  MOVLW  C0
0814:  IORWF  FF2,F
....................  
.................... 	while (TRUE) { 
.................... 		switch (trata_bto()) { 
0816:  BRA    0136
0818:  MOVF   01,W
081A:  XORLW  08
081C:  BZ    0828
081E:  XORLW  01
0820:  BZ    0832
0822:  XORLW  09
0824:  BZ    083C
0826:  BRA    0842
.................... 		case bto_sobe: 
.................... 			sendAll(cmd_subir); 
0828:  MOVLW  01
082A:  MOVWF  xC6
082C:  RCALL  024C
.................... 			recolhe = TRUE; 
082E:  BSF    xA2.4
.................... 			break; 
0830:  BRA    0842
.................... 		case bto_desce: 
.................... 			sendAll(cmd_descer); 
0832:  MOVLW  02
0834:  MOVWF  xC6
0836:  RCALL  024C
.................... 			recolhe = TRUE; 
0838:  BSF    xA2.4
.................... 			break; 
083A:  BRA    0842
.................... 		case vbto_parar: 
.................... 			sendAll(cmd_parar); 
083C:  CLRF   xC6
083E:  RCALL  024C
.................... 			recolhe = FALSE; 
0840:  BCF    xA2.4
.................... 			break; 
.................... 		} 
....................  
.................... 		if (recolhe) { 
0842:  BTFSS  xA2.4
0844:  BRA    0848
.................... 			read(); 
0846:  BRA    0744
.................... 		} 
....................  
.................... 		delay_ms(100); 
0848:  MOVLW  64
084A:  MOVWF  xC9
084C:  RCALL  010E
.................... 	} 
084E:  BRA    0816
....................  
.................... 	return 0; 
0850:  MOVLW  00
0852:  MOVWF  01
.................... } 
0854:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
