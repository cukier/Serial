CCS PCH C Compiler, Version 4.140, 22098               02-set-14 10:54

               Filename:   D:\Projetos\Serial\master.lst

               ROM used:   2002 bytes (6%)
                           Largest free fragment is 30762
               RAM used:   129 (8%) at main() level
                           176 (11%) worst case
               Stack:     6 worst case (4 in main + 2 for interrupts)

*
0000:  GOTO   06F6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0106
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... /* 
....................  * master.c 
....................  * 
....................  *  Created on: 18/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #include<18F252.h> 
.................... //////// Standard Header file for the PIC18F252 device //////////////// 
.................... #device PIC18F252 
.................... #list 
....................  
.................... #zero_ram 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
0420:  CLRF   xA2
....................    sign = 0; 
0422:  CLRF   xA0
....................    base = 10; 
0424:  MOVLW  0A
0426:  MOVWF  xA1
....................    result = 0; 
0428:  CLRF   x9F
042A:  CLRF   x9E
....................  
....................    if (!s) 
042C:  MOVF   x9C,W
042E:  IORWF  x9D,W
0430:  BNZ   043A
....................       return 0; 
0432:  MOVLW  00
0434:  MOVWF  01
0436:  MOVWF  02
0438:  BRA    0608
....................    c = s[index++]; 
043A:  MOVF   xA2,W
043C:  INCF   xA2,F
043E:  CLRF   03
0440:  ADDWF  x9C,W
0442:  MOVWF  FE9
0444:  MOVF   x9D,W
0446:  ADDWFC 03,W
0448:  MOVWF  FEA
044A:  MOVFF  FEF,A3
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
044E:  MOVF   xA3,W
0450:  SUBLW  2D
0452:  BNZ   046E
....................    { 
....................       sign = 1;         // Set the sign to negative 
0454:  MOVLW  01
0456:  MOVWF  xA0
....................       c = s[index++]; 
0458:  MOVF   xA2,W
045A:  INCF   xA2,F
045C:  CLRF   03
045E:  ADDWF  x9C,W
0460:  MOVWF  FE9
0462:  MOVF   x9D,W
0464:  ADDWFC 03,W
0466:  MOVWF  FEA
0468:  MOVFF  FEF,A3
....................    } 
....................    else if (c == '+') 
046C:  BRA    0488
046E:  MOVF   xA3,W
0470:  SUBLW  2B
0472:  BNZ   0488
....................    { 
....................       c = s[index++]; 
0474:  MOVF   xA2,W
0476:  INCF   xA2,F
0478:  CLRF   03
047A:  ADDWF  x9C,W
047C:  MOVWF  FE9
047E:  MOVF   x9D,W
0480:  ADDWFC 03,W
0482:  MOVWF  FEA
0484:  MOVFF  FEF,A3
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0488:  MOVF   xA3,W
048A:  SUBLW  2F
048C:  BTFSC  FD8.0
048E:  BRA    05EC
0490:  MOVF   xA3,W
0492:  SUBLW  39
0494:  BTFSS  FD8.0
0496:  BRA    05EC
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0498:  MOVF   xA3,W
049A:  SUBLW  30
049C:  BNZ   04E0
049E:  CLRF   03
04A0:  MOVF   xA2,W
04A2:  ADDWF  x9C,W
04A4:  MOVWF  FE9
04A6:  MOVF   x9D,W
04A8:  ADDWFC 03,W
04AA:  MOVWF  FEA
04AC:  MOVF   FEF,W
04AE:  SUBLW  78
04B0:  BZ    04C6
04B2:  CLRF   03
04B4:  MOVF   xA2,W
04B6:  ADDWF  x9C,W
04B8:  MOVWF  FE9
04BA:  MOVF   x9D,W
04BC:  ADDWFC 03,W
04BE:  MOVWF  FEA
04C0:  MOVF   FEF,W
04C2:  SUBLW  58
04C4:  BNZ   04E0
....................       { 
....................          base = 16; 
04C6:  MOVLW  10
04C8:  MOVWF  xA1
....................          index++; 
04CA:  INCF   xA2,F
....................          c = s[index++]; 
04CC:  MOVF   xA2,W
04CE:  INCF   xA2,F
04D0:  CLRF   03
04D2:  ADDWF  x9C,W
04D4:  MOVWF  FE9
04D6:  MOVF   x9D,W
04D8:  ADDWFC 03,W
04DA:  MOVWF  FEA
04DC:  MOVFF  FEF,A3
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
04E0:  MOVF   xA1,W
04E2:  SUBLW  0A
04E4:  BNZ   0528
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
04E6:  MOVF   xA3,W
04E8:  SUBLW  2F
04EA:  BC    0526
04EC:  MOVF   xA3,W
04EE:  SUBLW  39
04F0:  BNC   0526
....................             result = 10*result + (c - '0'); 
04F2:  CLRF   xA5
04F4:  MOVLW  0A
04F6:  MOVWF  xA4
04F8:  MOVFF  9F,A7
04FC:  MOVFF  9E,A6
0500:  BRA    03CE
0502:  MOVLW  30
0504:  SUBWF  xA3,W
0506:  ADDWF  01,W
0508:  MOVWF  x9E
050A:  MOVLW  00
050C:  ADDWFC 02,W
050E:  MOVWF  x9F
....................             c = s[index++]; 
0510:  MOVF   xA2,W
0512:  INCF   xA2,F
0514:  CLRF   03
0516:  ADDWF  x9C,W
0518:  MOVWF  FE9
051A:  MOVF   x9D,W
051C:  ADDWFC 03,W
051E:  MOVWF  FEA
0520:  MOVFF  FEF,A3
....................          } 
0524:  BRA    04E6
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0526:  BRA    05EC
0528:  MOVF   xA1,W
052A:  SUBLW  10
052C:  BNZ   05EC
....................       { 
....................          c = toupper(c); 
052E:  MOVF   xA3,W
0530:  SUBLW  60
0532:  BC    0540
0534:  MOVF   xA3,W
0536:  SUBLW  7A
0538:  BNC   0540
053A:  MOVF   xA3,W
053C:  ANDLW  DF
053E:  BRA    0542
0540:  MOVF   xA3,W
0542:  MOVWF  xA3
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
0544:  MOVF   xA3,W
0546:  SUBLW  2F
0548:  BC    0550
054A:  MOVF   xA3,W
054C:  SUBLW  39
054E:  BC    055C
0550:  MOVF   xA3,W
0552:  SUBLW  40
0554:  BC    05EC
0556:  MOVF   xA3,W
0558:  SUBLW  46
055A:  BNC   05EC
....................             if (c >= '0' && c <= '9') 
055C:  MOVF   xA3,W
055E:  SUBLW  2F
0560:  BC    0594
0562:  MOVF   xA3,W
0564:  SUBLW  39
0566:  BNC   0594
....................                result = (result << 4) + (c - '0'); 
0568:  RLCF   x9E,W
056A:  MOVWF  xA4
056C:  RLCF   x9F,W
056E:  MOVWF  xA5
0570:  RLCF   xA4,F
0572:  RLCF   xA5,F
0574:  RLCF   xA4,F
0576:  RLCF   xA5,F
0578:  RLCF   xA4,F
057A:  RLCF   xA5,F
057C:  MOVLW  F0
057E:  ANDWF  xA4,F
0580:  MOVLW  30
0582:  SUBWF  xA3,W
0584:  ADDWF  xA4,W
0586:  MOVWF  01
0588:  MOVLW  00
058A:  ADDWFC xA5,W
058C:  MOVFF  01,9E
0590:  MOVWF  x9F
....................             else 
0592:  BRA    05C0
....................                result = (result << 4) + (c - 'A' + 10); 
0594:  RLCF   x9E,W
0596:  MOVWF  xA4
0598:  RLCF   x9F,W
059A:  MOVWF  xA5
059C:  RLCF   xA4,F
059E:  RLCF   xA5,F
05A0:  RLCF   xA4,F
05A2:  RLCF   xA5,F
05A4:  RLCF   xA4,F
05A6:  RLCF   xA5,F
05A8:  MOVLW  F0
05AA:  ANDWF  xA4,F
05AC:  MOVLW  41
05AE:  SUBWF  xA3,W
05B0:  ADDLW  0A
05B2:  ADDWF  xA4,W
05B4:  MOVWF  01
05B6:  MOVLW  00
05B8:  ADDWFC xA5,W
05BA:  MOVFF  01,9E
05BE:  MOVWF  x9F
....................  
....................             c = s[index++];c = toupper(c); 
05C0:  MOVF   xA2,W
05C2:  INCF   xA2,F
05C4:  CLRF   03
05C6:  ADDWF  x9C,W
05C8:  MOVWF  FE9
05CA:  MOVF   x9D,W
05CC:  ADDWFC 03,W
05CE:  MOVWF  FEA
05D0:  MOVFF  FEF,A3
05D4:  MOVF   xA3,W
05D6:  SUBLW  60
05D8:  BC    05E6
05DA:  MOVF   xA3,W
05DC:  SUBLW  7A
05DE:  BNC   05E6
05E0:  MOVF   xA3,W
05E2:  ANDLW  DF
05E4:  BRA    05E8
05E6:  MOVF   xA3,W
05E8:  MOVWF  xA3
....................          } 
05EA:  BRA    0544
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
05EC:  MOVF   xA1,W
05EE:  SUBLW  0A
05F0:  BNZ   0600
05F2:  DECFSZ xA0,W
05F4:  BRA    0600
....................       result = -result; 
05F6:  COMF   x9E,F
05F8:  COMF   x9F,F
05FA:  INCF   x9E,F
05FC:  BTFSC  FD8.2
05FE:  INCF   x9F,F
....................  
....................    return(result); 
0600:  MOVFF  9E,01
0604:  MOVFF  9F,02
.................... } 
0608:  GOTO   0668 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS 
.................... #use delay(clock=15MHz) 
*
019A:  CLRF   FEA
019C:  MOVLW  94
019E:  MOVWF  FE9
01A0:  MOVF   FEF,W
01A2:  BZ    01C0
01A4:  MOVLW  04
01A6:  MOVWF  01
01A8:  CLRF   00
01AA:  DECFSZ 00,F
01AC:  BRA    01AA
01AE:  DECFSZ 01,F
01B0:  BRA    01A8
01B2:  MOVLW  DC
01B4:  MOVWF  00
01B6:  DECFSZ 00,F
01B8:  BRA    01B6
01BA:  NOP   
01BC:  DECFSZ FEF,F
01BE:  BRA    01A4
01C0:  RETURN 0
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................  
.................... #include "defines.c" 
.................... /* 
....................  * defines.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
.................... //Comandos 
.................... #define cmd_parar	0x00 
.................... #define cmd_subir	0x01 
.................... #define cmd_descer	0x02 
.................... #define cmd_r		0x04 
.................... #define cmd_w		0x05 
.................... //Entradas 
.................... #define bto_sobe	PIN_B0 
.................... #define bto_desce	PIN_B1 
.................... //Saidas 
.................... #define pin_sobe	PIN_C0 
.................... #define pin_desce	PIN_C1 
.................... //Tempos 
.................... #define debounce 	100 
.................... #define latencia	20 
.................... //definicoes 
.................... #define bufferLen	16 
.................... #define allSlvs		0 
....................  
.................... #include "variaveis.c" 
.................... /* 
....................  * vairaveis.c 
....................  * 
....................  *  Created on: 22/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... short ctrl_bto; 
.................... short RxOk; 
....................  
.................... int m_addr = 0xFF; 
.................... int r_addr = 0xFF; 
.................... int r_cmd = 0xFF; 
.................... int m_cmd = 0xFF; 
.................... int nrSlv = 2; 
.................... int i; 
.................... int line; 
....................  
.................... int buffer[bufferLen]; 
....................  
.................... long r_pos = 12345; 
.................... long m_pos = 12345; 
....................  
.................... long *p; 
.................... long pos_slv[bufferLen]; 
....................  
.................... #include "funcoes.c" 
.................... /* 
....................  * funcoes.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... int getAddr(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
....................  
.................... 	aux[0] = *p; 
.................... 	aux[1] = *(p + 1); 
....................  
.................... 	return atoi(aux); 
.................... } 
....................  
.................... int getCmd(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
....................  
.................... 	aux[0] = *(p + 2); 
.................... 	aux[1] = *(p + 3); 
....................  
.................... 	return atoi(aux); 
.................... } 
....................  
.................... long getPos(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[5]; 
....................  
.................... 	p = str; 
*
060C:  MOVFF  94,96
0610:  MOVFF  93,95
....................  
.................... 	for (i = 0; i < 5; ++i) 
0614:  CLRF   25
0616:  MOVF   25,W
0618:  SUBLW  04
061A:  BNC   0660
.................... 		aux[i] = *(p + i + 2); 
061C:  CLRF   03
061E:  MOVF   25,W
0620:  ADDLW  97
0622:  MOVWF  01
0624:  MOVLW  00
0626:  ADDWFC 03,F
0628:  MOVFF  01,9C
062C:  MOVFF  03,9D
0630:  MOVF   25,W
0632:  ADDWF  x95,W
0634:  MOVWF  x9E
0636:  MOVLW  00
0638:  ADDWFC x96,W
063A:  MOVWF  x9F
063C:  MOVLW  02
063E:  ADDWF  x9E,W
0640:  MOVWF  01
0642:  MOVLW  00
0644:  ADDWFC x9F,W
0646:  MOVFF  01,FE9
064A:  MOVWF  FEA
064C:  MOVFF  FEF,9E
0650:  MOVFF  9D,FEA
0654:  MOVFF  9C,FE9
0658:  MOVFF  9E,FEF
065C:  INCF   25,F
065E:  BRA    0616
....................  
.................... 	return atol(aux); 
0660:  CLRF   x9D
0662:  MOVLW  97
0664:  MOVWF  x9C
0666:  BRA    0420
0668:  MOVF   02,W
....................  
.................... } 
066A:  GOTO   06D4 (RETURN)
....................  
.................... int send_cmd(int addr, int cmd) { 
.................... 	delay_ms(latencia); 
*
0256:  MOVLW  14
0258:  MOVWF  x94
025A:  RCALL  019A
.................... 	printf("%02u%02u\n\r", addr, cmd); 
025C:  MOVFF  91,94
0260:  MOVLW  01
0262:  MOVWF  x95
0264:  RCALL  01EA
0266:  MOVFF  92,94
026A:  MOVLW  01
026C:  MOVWF  x95
026E:  RCALL  01EA
0270:  MOVLW  0A
0272:  BTFSS  F9E.4
0274:  BRA    0272
0276:  MOVWF  FAD
0278:  MOVLW  0D
027A:  BTFSS  F9E.4
027C:  BRA    027A
027E:  MOVWF  FAD
.................... 	return cmd; 
0280:  MOVFF  92,01
.................... } 
0284:  RETURN 0
....................  
.................... void send_pos(int addr, long pos) { 
.................... 	delay_ms(latencia); 
*
039C:  MOVLW  14
039E:  MOVWF  x94
03A0:  RCALL  019A
.................... 	printf("%02u%05lu\n\r", addr, pos); 
03A2:  MOVFF  91,94
03A6:  MOVLW  01
03A8:  MOVWF  x95
03AA:  RCALL  01EA
03AC:  MOVLW  08
03AE:  MOVWF  FE9
03B0:  MOVFF  93,95
03B4:  MOVFF  92,94
03B8:  BRA    02F6
03BA:  MOVLW  0A
03BC:  BTFSS  F9E.4
03BE:  BRA    03BC
03C0:  MOVWF  FAD
03C2:  MOVLW  0D
03C4:  BTFSS  F9E.4
03C6:  BRA    03C4
03C8:  MOVWF  FAD
.................... } 
03CA:  GOTO   0682 (RETURN)
....................  
.................... long *recall_pos(int nrSlaves, long pos) { 
.................... 	int i; 
.................... 	static long ret[bufferLen]; 
.................... 	int aux[bufferLen]; 
....................  
.................... 	send_cmd(allSlvs, cmd_w); 
*
066E:  CLRF   x91
0670:  MOVLW  05
0672:  MOVWF  x92
0674:  RCALL  0256
.................... 	send_pos(allSlvs, pos); 
0676:  CLRF   x91
0678:  MOVFF  7F,93
067C:  MOVFF  7E,92
0680:  BRA    039C
....................  
.................... 	for (i = 1; i <= nrSlaves; ++i) { 
0682:  MOVLW  01
0684:  MOVWF  x80
0686:  MOVF   x80,W
0688:  SUBWF  7D,W
068A:  BNC   06EA
.................... 		send_cmd(i, cmd_r); 
068C:  MOVFF  80,91
0690:  MOVLW  04
0692:  MOVWF  x92
0694:  RCALL  0256
.................... 		gets(aux); 
0696:  CLRF   FEA
0698:  MOVLW  81
069A:  MOVWF  FE9
069C:  DECF   FE9,F
069E:  BTFSS  F9E.5
06A0:  BRA    069E
06A2:  MOVFF  FAE,FEC
06A6:  MOVLW  0D
06A8:  SUBWF  FEF,W
06AA:  BNZ   069E
06AC:  CLRF   FEC
.................... 		ret[i - 1] = getPos(aux); 
06AE:  MOVLW  01
06B0:  SUBWF  x80,W
06B2:  MOVWF  00
06B4:  BCF    FD8.0
06B6:  RLCF   00,F
06B8:  MOVF   00,W
06BA:  CLRF   03
06BC:  ADDLW  5D
06BE:  MOVWF  01
06C0:  MOVLW  00
06C2:  ADDWFC 03,F
06C4:  MOVFF  01,91
06C8:  MOVFF  03,92
06CC:  CLRF   x94
06CE:  MOVLW  81
06D0:  MOVWF  x93
06D2:  BRA    060C
06D4:  MOVFF  92,FEA
06D8:  MOVFF  91,FE9
06DC:  MOVFF  02,FEC
06E0:  MOVF   FED,F
06E2:  MOVFF  01,FEF
.................... 	} 
06E6:  INCF   x80,F
06E8:  BRA    0686
....................  
.................... 	return ret; 
06EA:  MOVLW  5D
06EC:  MOVWF  01
06EE:  MOVLW  00
06F0:  MOVWF  02
.................... } 
06F2:  GOTO   0770 (RETURN)
....................  
.................... int trata_bto(int cmd) { 
*
0286:  BSF    F93.0
0288:  BCF    7E.0
028A:  BTFSS  F81.0
028C:  BSF    7E.0
028E:  BSF    F93.1
0290:  BCF    7E.1
0292:  BTFSS  F81.1
0294:  BSF    7E.1
0296:  MOVFF  7D,7F
.................... 	short sobe = !input(bto_sobe); 
.................... 	short desce = !input(bto_desce); 
.................... 	int ret = cmd; 
....................  
.................... 	if (sobe ^ desce) { 
029A:  MOVLW  00
029C:  BTFSC  7E.0
029E:  MOVLW  01
02A0:  MOVWF  x81
02A2:  MOVLW  00
02A4:  BTFSC  7E.1
02A6:  MOVLW  01
02A8:  XORWF  x81,W
02AA:  BZ    02DE
.................... 		if (!ctrl_bto) { 
02AC:  BTFSC  1F.0
02AE:  BRA    02DC
.................... 			delay_ms(debounce); 
02B0:  MOVLW  64
02B2:  MOVWF  x94
02B4:  RCALL  019A
.................... 			if (!input(bto_sobe)) 
02B6:  BSF    F93.0
02B8:  BTFSC  F81.0
02BA:  BRA    02C8
.................... 				ret = send_cmd(allSlvs, cmd_subir); 
02BC:  CLRF   x91
02BE:  MOVLW  01
02C0:  MOVWF  x92
02C2:  RCALL  0256
02C4:  MOVFF  01,7F
.................... 			if (!input(bto_desce)) 
02C8:  BSF    F93.1
02CA:  BTFSC  F81.1
02CC:  BRA    02DA
.................... 				ret = send_cmd(allSlvs, cmd_descer); 
02CE:  CLRF   x91
02D0:  MOVLW  02
02D2:  MOVWF  x92
02D4:  RCALL  0256
02D6:  MOVFF  01,7F
.................... 			ctrl_bto = TRUE; 
02DA:  BSF    1F.0
.................... 		} 
.................... 	} else if (ctrl_bto) { 
02DC:  BRA    02EE
02DE:  BTFSS  1F.0
02E0:  BRA    02EE
.................... 		ctrl_bto = FALSE; 
02E2:  BCF    1F.0
.................... 		ret = send_cmd(allSlvs, cmd_parar); 
02E4:  CLRF   x91
02E6:  CLRF   x92
02E8:  RCALL  0256
02EA:  MOVFF  01,7F
.................... 	} 
....................  
.................... 	return ret; 
02EE:  MOVFF  7F,01
.................... } 
02F2:  GOTO   0752 (RETURN)
....................  
.................... int trata_comunicacao() { 
....................  
.................... 	r_addr = 0xFF; 
.................... 	r_cmd = 0xFF; 
....................  
.................... 	r_addr = getAddr(buffer); 
.................... 	r_cmd = getCmd(buffer); 
....................  
.................... 	if (r_addr == m_addr || !r_addr) { 
.................... 		if (r_cmd == cmd_w) { 
.................... 			gets(buffer); 
.................... 			r_pos = getPos(buffer); 
.................... 		} else if (r_cmd == cmd_r) { 
.................... 			m_pos++; 
.................... 			send_pos(m_addr, m_pos); 
.................... 		} 
.................... 	} 
....................  
.................... 	return r_cmd; 
.................... } 
....................  
.................... void subir() { 
.................... 	output_low(pin_desce); 
.................... 	delay_ms(latencia >> 1); 
.................... 	output_high(pin_sobe); 
.................... } 
....................  
.................... void descer() { 
.................... 	output_low(pin_sobe); 
.................... 	delay_ms(latencia >> 1); 
.................... 	output_high(pin_desce); 
.................... } 
....................  
.................... void parar() { 
.................... 	output_low(pin_sobe); 
*
016E:  BCF    F94.0
0170:  BCF    F8B.0
.................... 	output_low(pin_desce); 
0172:  BCF    F94.1
0174:  BCF    F8B.1
.................... 	m_pos += get_timer0(); 
0176:  MOVF   FD6,W
0178:  ADDWF  39,F
017A:  MOVF   FD7,W
017C:  ADDWFC 3A,F
.................... 	set_timer0(0); 
017E:  CLRF   FD7
0180:  CLRF   FD6
.................... } 
0182:  GOTO   0196 (RETURN)
....................  
.................... int getMAddr() { 
*
0150:  SETF   F92
0152:  MOVFF  F80,7D
.................... 	int aux = input_a(); 
.................... 	return ((input_a() & 0xF0) >> 4) & 0x0F; 
0156:  SETF   F92
0158:  MOVF   F80,W
015A:  ANDLW  F0
015C:  MOVWF  00
015E:  SWAPF  00,F
0160:  MOVLW  0F
0162:  ANDWF  00,F
0164:  MOVF   00,W
0166:  ANDLW  0F
0168:  MOVWF  01
.................... } 
016A:  GOTO   0190 (RETURN)
....................  
.................... void init_mstr() { 
.................... //	set_timer0(T0_EXT_H_TO_L | T0_DIV_1); 
.................... //	set_timer1(T1_EXTERNAL | T1_DIV_BY_1); 
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
*
0186:  BSF    F9D.5
.................... 	enable_interrupts(GLOBAL); 
0188:  MOVLW  C0
018A:  IORWF  FF2,F
....................  
.................... 	m_cmd = cmd_parar; 
018C:  CLRF   23
.................... 	nrSlv = getMAddr(); 
018E:  BRA    0150
0190:  MOVFF  01,24
....................  
.................... 	parar(); 
0194:  BRA    016E
.................... } 
0196:  GOTO   074C (RETURN)
....................  
.................... void init_slv() { 
.................... //	set_timer0(T0_EXT_H_TO_L | T0_DIV_1); 
.................... //	set_timer1(T1_EXTERNAL | T1_DIV_BY_1); 
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... 	enable_interrupts(GLOBAL); 
....................  
.................... 	m_cmd = cmd_parar; 
.................... 	m_addr = getMAddr(); 
....................  
.................... 	parar(); 
.................... } 
....................  
.................... void trata_cmd(int cmd) { 
....................  
.................... 	switch (cmd) { 
.................... 	case cmd_subir: 
.................... 		subir(); 
.................... 		break; 
.................... 	case cmd_descer: 
.................... 		descer(); 
.................... 		break; 
.................... 	case cmd_parar: 
.................... 		parar(); 
.................... 		cmd_parar; 
.................... 		break; 
.................... 	default: 
.................... 	} 
.................... } 
....................  
.................... short recivedOk(int *buff) { 
.................... 	int *p; 
....................  
.................... 	for (p = buff; *p != '\0'; p++) 
*
00AE:  MOVFF  AB,AD
00B2:  MOVFF  AA,AC
00B6:  MOVFF  AD,03
00BA:  MOVFF  AC,FE9
00BE:  MOVFF  AD,FEA
00C2:  MOVF   FEF,F
00C4:  BZ    00FE
.................... 		if (*p == '\n' && *(p + 1) == '\r') 
00C6:  MOVFF  AD,03
00CA:  MOVFF  AC,FE9
00CE:  MOVFF  AD,FEA
00D2:  MOVF   FEF,W
00D4:  SUBLW  0A
00D6:  BNZ   00F6
00D8:  MOVLW  01
00DA:  ADDWF  xAC,W
00DC:  MOVWF  01
00DE:  MOVLW  00
00E0:  ADDWFC xAD,W
00E2:  MOVWF  03
00E4:  MOVFF  01,FE9
00E8:  MOVWF  FEA
00EA:  MOVF   FEF,W
00EC:  SUBLW  0D
00EE:  BNZ   00F6
.................... 			return TRUE; 
00F0:  MOVLW  01
00F2:  MOVWF  01
00F4:  BRA    0102
00F6:  INCF   xAC,F
00F8:  BTFSC  FD8.2
00FA:  INCF   xAD,F
00FC:  BRA    00B6
....................  
.................... 	return FALSE; 
00FE:  MOVLW  00
0100:  MOVWF  01
.................... } 
0102:  GOTO   013C (RETURN)
....................  
.................... #include "interrupcoes.c" 
.................... /* 
....................  * interrupcoes.c 
....................  * 
....................  *  Created on: 02/09/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #int_rda 
.................... void isr_rda() { 
.................... 	clear_interrupt(INT_RDA); 
.................... 	buffer[line++] = getc(); 
0106:  MOVF   26,W
0108:  INCF   26,F
010A:  CLRF   03
010C:  ADDLW  27
010E:  MOVWF  FE9
0110:  MOVLW  00
0112:  ADDWFC 03,W
0114:  MOVWF  FEA
0116:  BTFSS  F9E.5
0118:  BRA    0116
011A:  MOVFF  FAE,FEF
.................... 	buffer[line] = "\0"; 
011E:  CLRF   03
0120:  MOVF   26,W
0122:  ADDLW  27
0124:  MOVWF  01
0126:  MOVLW  00
0128:  ADDWFC 03,F
012A:  MOVFF  03,FEA
012E:  MOVFF  01,FE9
0132:  CLRF   FEF
.................... 	RxOk = recivedOk(buffer); 
0134:  CLRF   xAB
0136:  MOVLW  27
0138:  MOVWF  xAA
013A:  BRA    00AE
013C:  BCF    1F.1
013E:  BTFSC  01.0
0140:  BSF    1F.1
.................... 	if (RxOk) { 
0142:  BTFSS  1F.1
0144:  BRA    014A
.................... 		RxOk = FALSE; 
0146:  BCF    1F.1
.................... 		line = 0; 
0148:  CLRF   26
.................... 	} 
.................... } 
....................  
....................  
014A:  BCF    F9E.5
014C:  GOTO   0060
.................... int main(void) { 
*
06F6:  CLRF   FF8
06F8:  BCF    FD0.7
06FA:  BSF    07.7
06FC:  MOVLW  FE
06FE:  MOVWF  00
0700:  MOVLW  06
0702:  MOVWF  01
0704:  MOVLW  02
0706:  MOVWF  FE9
0708:  MOVLW  00
070A:  MOVWF  FEA
070C:  CLRF   FEE
070E:  DECFSZ 00,F
0710:  BRA    070C
0712:  DECFSZ 01,F
0714:  BRA    070C
0716:  CLRF   FEA
0718:  CLRF   FE9
071A:  MOVLW  61
071C:  MOVWF  FAF
071E:  MOVLW  A6
0720:  MOVWF  FAC
0722:  MOVLW  90
0724:  MOVWF  FAB
0726:  SETF   20
0728:  SETF   21
072A:  SETF   22
072C:  SETF   23
072E:  MOVLW  02
0730:  MOVWF  24
0732:  MOVLW  30
0734:  MOVWF  38
0736:  MOVLW  39
0738:  MOVWF  37
073A:  MOVLW  30
073C:  MOVWF  3A
073E:  MOVLW  39
0740:  MOVWF  39
0742:  BSF    FC1.0
0744:  BSF    FC1.1
0746:  BSF    FC1.2
0748:  BCF    FC1.3
....................  
.................... 	init_mstr(); 
074A:  BRA    0186
....................  
.................... 	while (TRUE) { 
....................  
.................... 		m_cmd = trata_bto(m_cmd); 
074C:  MOVFF  23,7D
0750:  BRA    0286
0752:  MOVFF  01,23
....................  
.................... 		if (m_cmd == cmd_subir || m_cmd == cmd_descer) { 
0756:  DECFSZ 23,W
0758:  BRA    075C
075A:  BRA    0762
075C:  MOVF   23,W
075E:  SUBLW  02
0760:  BNZ   07C8
.................... 			p = recall_pos(nrSlv, r_pos); 
0762:  MOVFF  24,7D
0766:  MOVFF  38,7F
076A:  MOVFF  37,7E
076E:  BRA    066E
0770:  MOVFF  02,3C
0774:  MOVFF  01,3B
.................... 			for (i = 0; i < nrSlv; ++i) { 
0778:  CLRF   25
077A:  MOVF   24,W
077C:  SUBWF  25,W
077E:  BC    07C8
.................... 				pos_slv[i] = *(p + i); 
0780:  BCF    FD8.0
0782:  RLCF   25,W
0784:  CLRF   03
0786:  ADDLW  3D
0788:  MOVWF  01
078A:  MOVLW  00
078C:  ADDWFC 03,F
078E:  MOVFF  01,7D
0792:  MOVFF  03,7E
0796:  BCF    FD8.0
0798:  RLCF   25,W
079A:  ADDWF  3B,W
079C:  MOVWF  01
079E:  MOVLW  00
07A0:  ADDWFC 3C,W
07A2:  MOVFF  01,FE9
07A6:  MOVWF  FEA
07A8:  MOVFF  FEC,03
07AC:  MOVF   FED,F
07AE:  MOVFF  FEF,7F
07B2:  MOVFF  7E,FEA
07B6:  MOVFF  7D,FE9
07BA:  MOVFF  03,FEC
07BE:  MOVF   FED,F
07C0:  MOVFF  7F,FEF
.................... 			} 
07C4:  INCF   25,F
07C6:  BRA    077A
.................... 		} 
.................... 		delay_ms(100); 
07C8:  MOVLW  64
07CA:  MOVWF  x94
07CC:  RCALL  019A
.................... 	} 
07CE:  BRA    074C
....................  
.................... 	return 0; 
07D0:  MOVLW  00
07D2:  MOVWF  01
.................... } 
....................  
07D4:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
