CCS PCH C Compiler, Version 4.140, 22098               22-ago-14 15:55

               Filename:   D:\Projetos\Serial\slave1.lst

               ROM used:   1956 bytes (6%)
                           Largest free fragment is 30812
               RAM used:   103 (7%) at main() level
                           126 (8%) worst case
               Stack:     4 locations

*
0000:  GOTO   0746
.................... /* 
....................  * slave.c 
....................  * 
....................  *  Created on: 18/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #include<18F252.h> 
.................... //////// Standard Header file for the PIC18F252 device //////////////// 
.................... #device PIC18F252 
.................... #list 
....................  
.................... #zero_ram 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0050:  CLRF   72
....................    sign = 0; 
0052:  CLRF   70
....................    base = 10; 
0054:  MOVLW  0A
0056:  MOVWF  71
....................    result = 0; 
0058:  CLRF   6F
....................  
....................    if (!s) 
005A:  MOVF   6D,W
005C:  IORWF  6E,W
005E:  BNZ   0066
....................       return 0; 
0060:  MOVLW  00
0062:  MOVWF  01
0064:  BRA    01E8
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0066:  MOVF   72,W
0068:  INCF   72,F
006A:  CLRF   03
006C:  ADDWF  6D,W
006E:  MOVWF  FE9
0070:  MOVF   6E,W
0072:  ADDWFC 03,W
0074:  MOVWF  FEA
0076:  MOVFF  FEF,73
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
007A:  MOVF   73,W
007C:  SUBLW  2D
007E:  BNZ   009A
....................    { 
....................       sign = 1;         // Set the sign to negative 
0080:  MOVLW  01
0082:  MOVWF  70
....................       c = s[index++]; 
0084:  MOVF   72,W
0086:  INCF   72,F
0088:  CLRF   03
008A:  ADDWF  6D,W
008C:  MOVWF  FE9
008E:  MOVF   6E,W
0090:  ADDWFC 03,W
0092:  MOVWF  FEA
0094:  MOVFF  FEF,73
....................    } 
....................    else if (c == '+') 
0098:  BRA    00B4
009A:  MOVF   73,W
009C:  SUBLW  2B
009E:  BNZ   00B4
....................    { 
....................       c = s[index++]; 
00A0:  MOVF   72,W
00A2:  INCF   72,F
00A4:  CLRF   03
00A6:  ADDWF  6D,W
00A8:  MOVWF  FE9
00AA:  MOVF   6E,W
00AC:  ADDWFC 03,W
00AE:  MOVWF  FEA
00B0:  MOVFF  FEF,73
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
00B4:  MOVF   73,W
00B6:  SUBLW  2F
00B8:  BTFSC  FD8.0
00BA:  BRA    01D8
00BC:  MOVF   73,W
00BE:  SUBLW  39
00C0:  BTFSS  FD8.0
00C2:  BRA    01D8
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
00C4:  MOVF   73,W
00C6:  SUBLW  30
00C8:  BNZ   010C
00CA:  CLRF   03
00CC:  MOVF   72,W
00CE:  ADDWF  6D,W
00D0:  MOVWF  FE9
00D2:  MOVF   6E,W
00D4:  ADDWFC 03,W
00D6:  MOVWF  FEA
00D8:  MOVF   FEF,W
00DA:  SUBLW  78
00DC:  BZ    00F2
00DE:  CLRF   03
00E0:  MOVF   72,W
00E2:  ADDWF  6D,W
00E4:  MOVWF  FE9
00E6:  MOVF   6E,W
00E8:  ADDWFC 03,W
00EA:  MOVWF  FEA
00EC:  MOVF   FEF,W
00EE:  SUBLW  58
00F0:  BNZ   010C
....................       { 
....................          base = 16; 
00F2:  MOVLW  10
00F4:  MOVWF  71
....................          index++; 
00F6:  INCF   72,F
....................          c = s[index++]; 
00F8:  MOVF   72,W
00FA:  INCF   72,F
00FC:  CLRF   03
00FE:  ADDWF  6D,W
0100:  MOVWF  FE9
0102:  MOVF   6E,W
0104:  ADDWFC 03,W
0106:  MOVWF  FEA
0108:  MOVFF  FEF,73
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
010C:  MOVF   71,W
010E:  SUBLW  0A
0110:  BNZ   0148
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0112:  MOVF   73,W
0114:  SUBLW  2F
0116:  BC    0146
0118:  MOVF   73,W
011A:  SUBLW  39
011C:  BNC   0146
....................             result = 10*result + (c - '0'); 
011E:  MOVLW  0A
0120:  MOVWF  74
0122:  MOVFF  6F,75
0126:  BRA    0004
0128:  MOVLW  30
012A:  SUBWF  73,W
012C:  ADDWF  01,W
012E:  MOVWF  6F
....................             c = s[index++]; 
0130:  MOVF   72,W
0132:  INCF   72,F
0134:  CLRF   03
0136:  ADDWF  6D,W
0138:  MOVWF  FE9
013A:  MOVF   6E,W
013C:  ADDWFC 03,W
013E:  MOVWF  FEA
0140:  MOVFF  FEF,73
....................          } 
0144:  BRA    0112
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0146:  BRA    01D8
0148:  MOVF   71,W
014A:  SUBLW  10
014C:  BNZ   01D8
....................       { 
....................          c = toupper(c); 
014E:  MOVF   73,W
0150:  SUBLW  60
0152:  BC    0160
0154:  MOVF   73,W
0156:  SUBLW  7A
0158:  BNC   0160
015A:  MOVF   73,W
015C:  ANDLW  DF
015E:  BRA    0162
0160:  MOVF   73,W
0162:  MOVWF  73
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
0164:  MOVF   73,W
0166:  SUBLW  2F
0168:  BC    0170
016A:  MOVF   73,W
016C:  SUBLW  39
016E:  BC    017C
0170:  MOVF   73,W
0172:  SUBLW  40
0174:  BC    01D8
0176:  MOVF   73,W
0178:  SUBLW  46
017A:  BNC   01D8
....................             if (c >= '0' && c <= '9') 
017C:  MOVF   73,W
017E:  SUBLW  2F
0180:  BC    019A
0182:  MOVF   73,W
0184:  SUBLW  39
0186:  BNC   019A
....................                result = (result << 4) + (c - '0'); 
0188:  SWAPF  6F,W
018A:  MOVWF  74
018C:  MOVLW  F0
018E:  ANDWF  74,F
0190:  MOVLW  30
0192:  SUBWF  73,W
0194:  ADDWF  74,W
0196:  MOVWF  6F
....................             else 
0198:  BRA    01AC
....................                result = (result << 4) + (c - 'A' + 10); 
019A:  SWAPF  6F,W
019C:  MOVWF  74
019E:  MOVLW  F0
01A0:  ANDWF  74,F
01A2:  MOVLW  41
01A4:  SUBWF  73,W
01A6:  ADDLW  0A
01A8:  ADDWF  74,W
01AA:  MOVWF  6F
....................  
....................             c = s[index++]; 
01AC:  MOVF   72,W
01AE:  INCF   72,F
01B0:  CLRF   03
01B2:  ADDWF  6D,W
01B4:  MOVWF  FE9
01B6:  MOVF   6E,W
01B8:  ADDWFC 03,W
01BA:  MOVWF  FEA
01BC:  MOVFF  FEF,73
....................             c = toupper(c); 
01C0:  MOVF   73,W
01C2:  SUBLW  60
01C4:  BC    01D2
01C6:  MOVF   73,W
01C8:  SUBLW  7A
01CA:  BNC   01D2
01CC:  MOVF   73,W
01CE:  ANDLW  DF
01D0:  BRA    01D4
01D2:  MOVF   73,W
01D4:  MOVWF  73
....................          } 
01D6:  BRA    0164
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
01D8:  DECFSZ 70,W
01DA:  BRA    01E4
01DC:  MOVF   71,W
01DE:  SUBLW  0A
01E0:  BNZ   01E4
....................        result = -result; 
01E2:  NEGF   6F
....................  
....................    return(result); 
01E4:  MOVFF  6F,01
.................... } 
01E8:  RETURN 0
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
02B0:  CLRF   76
....................    sign = 0; 
02B2:  CLRF   74
....................    base = 10; 
02B4:  MOVLW  0A
02B6:  MOVWF  75
....................    result = 0; 
02B8:  CLRF   73
02BA:  CLRF   72
....................  
....................    if (!s) 
02BC:  MOVF   70,W
02BE:  IORWF  71,W
02C0:  BNZ   02CA
....................       return 0; 
02C2:  MOVLW  00
02C4:  MOVWF  01
02C6:  MOVWF  02
02C8:  BRA    0498
....................    c = s[index++]; 
02CA:  MOVF   76,W
02CC:  INCF   76,F
02CE:  CLRF   03
02D0:  ADDWF  70,W
02D2:  MOVWF  FE9
02D4:  MOVF   71,W
02D6:  ADDWFC 03,W
02D8:  MOVWF  FEA
02DA:  MOVFF  FEF,77
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
02DE:  MOVF   77,W
02E0:  SUBLW  2D
02E2:  BNZ   02FE
....................    { 
....................       sign = 1;         // Set the sign to negative 
02E4:  MOVLW  01
02E6:  MOVWF  74
....................       c = s[index++]; 
02E8:  MOVF   76,W
02EA:  INCF   76,F
02EC:  CLRF   03
02EE:  ADDWF  70,W
02F0:  MOVWF  FE9
02F2:  MOVF   71,W
02F4:  ADDWFC 03,W
02F6:  MOVWF  FEA
02F8:  MOVFF  FEF,77
....................    } 
....................    else if (c == '+') 
02FC:  BRA    0318
02FE:  MOVF   77,W
0300:  SUBLW  2B
0302:  BNZ   0318
....................    { 
....................       c = s[index++]; 
0304:  MOVF   76,W
0306:  INCF   76,F
0308:  CLRF   03
030A:  ADDWF  70,W
030C:  MOVWF  FE9
030E:  MOVF   71,W
0310:  ADDWFC 03,W
0312:  MOVWF  FEA
0314:  MOVFF  FEF,77
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0318:  MOVF   77,W
031A:  SUBLW  2F
031C:  BTFSC  FD8.0
031E:  BRA    047C
0320:  MOVF   77,W
0322:  SUBLW  39
0324:  BTFSS  FD8.0
0326:  BRA    047C
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0328:  MOVF   77,W
032A:  SUBLW  30
032C:  BNZ   0370
032E:  CLRF   03
0330:  MOVF   76,W
0332:  ADDWF  70,W
0334:  MOVWF  FE9
0336:  MOVF   71,W
0338:  ADDWFC 03,W
033A:  MOVWF  FEA
033C:  MOVF   FEF,W
033E:  SUBLW  78
0340:  BZ    0356
0342:  CLRF   03
0344:  MOVF   76,W
0346:  ADDWF  70,W
0348:  MOVWF  FE9
034A:  MOVF   71,W
034C:  ADDWFC 03,W
034E:  MOVWF  FEA
0350:  MOVF   FEF,W
0352:  SUBLW  58
0354:  BNZ   0370
....................       { 
....................          base = 16; 
0356:  MOVLW  10
0358:  MOVWF  75
....................          index++; 
035A:  INCF   76,F
....................          c = s[index++]; 
035C:  MOVF   76,W
035E:  INCF   76,F
0360:  CLRF   03
0362:  ADDWF  70,W
0364:  MOVWF  FE9
0366:  MOVF   71,W
0368:  ADDWFC 03,W
036A:  MOVWF  FEA
036C:  MOVFF  FEF,77
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0370:  MOVF   75,W
0372:  SUBLW  0A
0374:  BNZ   03B8
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0376:  MOVF   77,W
0378:  SUBLW  2F
037A:  BC    03B6
037C:  MOVF   77,W
037E:  SUBLW  39
0380:  BNC   03B6
....................             result = 10*result + (c - '0'); 
0382:  CLRF   79
0384:  MOVLW  0A
0386:  MOVWF  78
0388:  MOVFF  73,7B
038C:  MOVFF  72,7A
0390:  BRA    025E
0392:  MOVLW  30
0394:  SUBWF  77,W
0396:  ADDWF  01,W
0398:  MOVWF  72
039A:  MOVLW  00
039C:  ADDWFC 02,W
039E:  MOVWF  73
....................             c = s[index++]; 
03A0:  MOVF   76,W
03A2:  INCF   76,F
03A4:  CLRF   03
03A6:  ADDWF  70,W
03A8:  MOVWF  FE9
03AA:  MOVF   71,W
03AC:  ADDWFC 03,W
03AE:  MOVWF  FEA
03B0:  MOVFF  FEF,77
....................          } 
03B4:  BRA    0376
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
03B6:  BRA    047C
03B8:  MOVF   75,W
03BA:  SUBLW  10
03BC:  BNZ   047C
....................       { 
....................          c = toupper(c); 
03BE:  MOVF   77,W
03C0:  SUBLW  60
03C2:  BC    03D0
03C4:  MOVF   77,W
03C6:  SUBLW  7A
03C8:  BNC   03D0
03CA:  MOVF   77,W
03CC:  ANDLW  DF
03CE:  BRA    03D2
03D0:  MOVF   77,W
03D2:  MOVWF  77
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
03D4:  MOVF   77,W
03D6:  SUBLW  2F
03D8:  BC    03E0
03DA:  MOVF   77,W
03DC:  SUBLW  39
03DE:  BC    03EC
03E0:  MOVF   77,W
03E2:  SUBLW  40
03E4:  BC    047C
03E6:  MOVF   77,W
03E8:  SUBLW  46
03EA:  BNC   047C
....................             if (c >= '0' && c <= '9') 
03EC:  MOVF   77,W
03EE:  SUBLW  2F
03F0:  BC    0424
03F2:  MOVF   77,W
03F4:  SUBLW  39
03F6:  BNC   0424
....................                result = (result << 4) + (c - '0'); 
03F8:  RLCF   72,W
03FA:  MOVWF  78
03FC:  RLCF   73,W
03FE:  MOVWF  79
0400:  RLCF   78,F
0402:  RLCF   79,F
0404:  RLCF   78,F
0406:  RLCF   79,F
0408:  RLCF   78,F
040A:  RLCF   79,F
040C:  MOVLW  F0
040E:  ANDWF  78,F
0410:  MOVLW  30
0412:  SUBWF  77,W
0414:  ADDWF  78,W
0416:  MOVWF  01
0418:  MOVLW  00
041A:  ADDWFC 79,W
041C:  MOVFF  01,72
0420:  MOVWF  73
....................             else 
0422:  BRA    0450
....................                result = (result << 4) + (c - 'A' + 10); 
0424:  RLCF   72,W
0426:  MOVWF  78
0428:  RLCF   73,W
042A:  MOVWF  79
042C:  RLCF   78,F
042E:  RLCF   79,F
0430:  RLCF   78,F
0432:  RLCF   79,F
0434:  RLCF   78,F
0436:  RLCF   79,F
0438:  MOVLW  F0
043A:  ANDWF  78,F
043C:  MOVLW  41
043E:  SUBWF  77,W
0440:  ADDLW  0A
0442:  ADDWF  78,W
0444:  MOVWF  01
0446:  MOVLW  00
0448:  ADDWFC 79,W
044A:  MOVFF  01,72
044E:  MOVWF  73
....................  
....................             c = s[index++];c = toupper(c); 
0450:  MOVF   76,W
0452:  INCF   76,F
0454:  CLRF   03
0456:  ADDWF  70,W
0458:  MOVWF  FE9
045A:  MOVF   71,W
045C:  ADDWFC 03,W
045E:  MOVWF  FEA
0460:  MOVFF  FEF,77
0464:  MOVF   77,W
0466:  SUBLW  60
0468:  BC    0476
046A:  MOVF   77,W
046C:  SUBLW  7A
046E:  BNC   0476
0470:  MOVF   77,W
0472:  ANDLW  DF
0474:  BRA    0478
0476:  MOVF   77,W
0478:  MOVWF  77
....................          } 
047A:  BRA    03D4
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
047C:  MOVF   75,W
047E:  SUBLW  0A
0480:  BNZ   0490
0482:  DECFSZ 74,W
0484:  BRA    0490
....................       result = -result; 
0486:  COMF   72,F
0488:  COMF   73,F
048A:  INCF   72,F
048C:  BTFSC  FD8.2
048E:  INCF   73,F
....................  
....................    return(result); 
0490:  MOVFF  72,01
0494:  MOVFF  73,02
.................... } 
0498:  GOTO   0510 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS 
.................... #use delay(clock=15MHz) 
*
0516:  CLRF   FEA
0518:  MOVLW  6A
051A:  MOVWF  FE9
051C:  MOVF   FEF,W
051E:  BZ    053C
0520:  MOVLW  04
0522:  MOVWF  01
0524:  CLRF   00
0526:  DECFSZ 00,F
0528:  BRA    0526
052A:  DECFSZ 01,F
052C:  BRA    0524
052E:  MOVLW  DC
0530:  MOVWF  00
0532:  DECFSZ 00,F
0534:  BRA    0532
0536:  NOP   
0538:  DECFSZ FEF,F
053A:  BRA    0520
053C:  GOTO   0682 (RETURN)
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................  
.................... #include "defines.c" 
.................... /* 
....................  * defines.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #define cmd_parar	0x00 
.................... #define cmd_subir	0x01 
.................... #define cmd_descer	0x02 
.................... #define cmd_r		0x04 
.................... #define cmd_w		0x05 
....................  
.................... #define bto_sobe	PIN_B0 
.................... #define bto_desce	PIN_B1 
....................  
.................... #define debounce 	100 
.................... #define latencia	20 
....................  
.................... #define arrayLen		16 
.................... #define bufferLen	16 
.................... #define allSlvs		0 
....................  
.................... #include "variaveis.c" 
.................... /* 
....................  * vairaveis.c 
....................  * 
....................  *  Created on: 22/08/2014 
....................  *      Author: cuki 
....................  */ 
.................... //slv 
.................... short ctrl_bto; 
....................  
.................... int m_addr = 0xFF; 
.................... int r_addr = 0xFF; 
.................... int r_cmd = 0xFF; 
....................  
.................... long r_pos = 12345; 
.................... long m_pos = 12345; 
....................  
.................... int buffer[arrayLen]; 
....................  
.................... //mstr 
....................  
.................... int m_cmd; 
.................... int nrSlv = 2; 
.................... int i; 
....................  
.................... long *p; 
.................... long pos_slv[arrayLen]; 
....................  
.................... #include "funcoes.c" 
.................... /* 
....................  * funcoes.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
.................... int getAddr(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
*
01EA:  MOVFF  68,6A
01EE:  MOVFF  67,69
....................  
.................... 	aux[0] = *p; 
01F2:  MOVFF  69,FE9
01F6:  MOVFF  6A,FEA
01FA:  MOVFF  FEF,6B
.................... 	aux[1] = *(p + 1); 
01FE:  MOVLW  01
0200:  ADDWF  69,W
0202:  MOVWF  01
0204:  MOVLW  00
0206:  ADDWFC 6A,W
0208:  MOVFF  01,FE9
020C:  MOVWF  FEA
020E:  MOVFF  FEF,6C
....................  
.................... 	return atoi(aux); 
0212:  CLRF   6E
0214:  MOVLW  6B
0216:  MOVWF  6D
0218:  RCALL  0050
021A:  MOVF   01,W
.................... } 
021C:  GOTO   06D2 (RETURN)
....................  
.................... int getCmd(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
0220:  MOVFF  68,6A
0224:  MOVFF  67,69
....................  
.................... 	aux[0] = *(p + 2); 
0228:  MOVLW  02
022A:  ADDWF  69,W
022C:  MOVWF  01
022E:  MOVLW  00
0230:  ADDWFC 6A,W
0232:  MOVFF  01,FE9
0236:  MOVWF  FEA
0238:  MOVFF  FEF,6B
.................... 	aux[1] = *(p + 3); 
023C:  MOVLW  03
023E:  ADDWF  69,W
0240:  MOVWF  01
0242:  MOVLW  00
0244:  ADDWFC 6A,W
0246:  MOVFF  01,FE9
024A:  MOVWF  FEA
024C:  MOVFF  FEF,6C
....................  
.................... 	return atoi(aux); 
0250:  CLRF   6E
0252:  MOVLW  6B
0254:  MOVWF  6D
0256:  RCALL  0050
0258:  MOVF   01,W
.................... } 
025A:  GOTO   06DE (RETURN)
....................  
.................... long getPos(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[5]; 
....................  
.................... 	p = str; 
*
049C:  MOVFF  68,6A
04A0:  MOVFF  67,69
....................  
.................... 	aux[0] = *(p + 2); 
04A4:  MOVLW  02
04A6:  ADDWF  69,W
04A8:  MOVWF  01
04AA:  MOVLW  00
04AC:  ADDWFC 6A,W
04AE:  MOVFF  01,FE9
04B2:  MOVWF  FEA
04B4:  MOVFF  FEF,6B
.................... 	aux[1] = *(p + 3); 
04B8:  MOVLW  03
04BA:  ADDWF  69,W
04BC:  MOVWF  01
04BE:  MOVLW  00
04C0:  ADDWFC 6A,W
04C2:  MOVFF  01,FE9
04C6:  MOVWF  FEA
04C8:  MOVFF  FEF,6C
.................... 	aux[2] = *(p + 4); 
04CC:  MOVLW  04
04CE:  ADDWF  69,W
04D0:  MOVWF  01
04D2:  MOVLW  00
04D4:  ADDWFC 6A,W
04D6:  MOVFF  01,FE9
04DA:  MOVWF  FEA
04DC:  MOVFF  FEF,6D
.................... 	aux[3] = *(p + 5); 
04E0:  MOVLW  05
04E2:  ADDWF  69,W
04E4:  MOVWF  01
04E6:  MOVLW  00
04E8:  ADDWFC 6A,W
04EA:  MOVFF  01,FE9
04EE:  MOVWF  FEA
04F0:  MOVFF  FEF,6E
.................... 	aux[4] = *(p + 6); 
04F4:  MOVLW  06
04F6:  ADDWF  69,W
04F8:  MOVWF  01
04FA:  MOVLW  00
04FC:  ADDWFC 6A,W
04FE:  MOVFF  01,FE9
0502:  MOVWF  FEA
0504:  MOVFF  FEF,6F
....................  
.................... 	return atol(aux); 
0508:  CLRF   71
050A:  MOVLW  6B
050C:  MOVWF  70
050E:  BRA    02B0
0510:  MOVF   02,W
....................  
.................... } 
0512:  GOTO   0724 (RETURN)
....................  
.................... int send_cmd(int addr, int cmd) { 
.................... 	delay_ms(latencia); 
.................... 	printf("%02u%02u\n\r", addr, cmd); 
.................... 	return cmd; 
.................... } 
....................  
.................... void send_pos(int addr, long pos) { 
.................... 	delay_ms(latencia); 
*
067C:  MOVLW  14
067E:  MOVWF  6A
0680:  BRA    0516
.................... 	printf("%02u%05lu\n\r", addr, pos); 
0682:  MOVFF  67,6A
0686:  MOVLW  01
0688:  MOVWF  6B
068A:  BRA    0568
068C:  MOVLW  08
068E:  MOVWF  FE9
0690:  MOVFF  69,6B
0694:  MOVFF  68,6A
0698:  BRA    05D6
069A:  MOVLW  0A
069C:  BTFSS  F9E.4
069E:  BRA    069C
06A0:  MOVWF  FAD
06A2:  MOVLW  0D
06A4:  BTFSS  F9E.4
06A6:  BRA    06A4
06A8:  MOVWF  FAD
.................... } 
06AA:  GOTO   0742 (RETURN)
....................  
.................... int trata_bto(int cmd) { 
.................... 	short sobe = !input(bto_sobe); 
.................... 	short desce = !input(bto_desce); 
.................... 	int ret = cmd; 
....................  
.................... 	if (sobe ^ desce) { 
.................... 		if (!ctrl_bto) { 
.................... 			delay_ms(debounce); 
.................... 			if (!input(bto_sobe)) 
.................... 				ret = send_cmd(allSlvs, cmd_subir); 
.................... 			if (!input(bto_desce)) 
.................... 				ret = send_cmd(allSlvs, cmd_descer); 
.................... 			ctrl_bto = TRUE; 
.................... 		} 
.................... 	} else if (ctrl_bto) { 
.................... 		ctrl_bto = FALSE; 
.................... 		ret = send_cmd(allSlvs, cmd_parar); 
.................... 	} 
....................  
.................... 	return ret; 
.................... } 
....................  
.................... long *recall_pos(int nrSlaves, long pos) { 
.................... 	int i; 
.................... 	static long ret[arrayLen]; 
.................... 	int aux[arrayLen]; 
....................  
.................... 	send_cmd(allSlvs, cmd_w); 
.................... 	send_pos(allSlvs, pos); 
....................  
.................... 	for (i = 1; i <= nrSlaves; ++i) { 
.................... 		delay_ms(latencia); 
.................... 		send_cmd(i, cmd_r); 
.................... 		gets(aux); 
.................... 		ret[i - 1] = getPos(aux); 
.................... 	} 
....................  
.................... 	return ret; 
.................... } 
....................  
....................  
.................... void trata_comunicacao() { 
....................  
.................... 	gets(buffer); 
06AE:  CLRF   FEA
06B0:  MOVLW  12
06B2:  MOVWF  FE9
06B4:  DECF   FE9,F
06B6:  BTFSS  F9E.5
06B8:  BRA    06B6
06BA:  MOVFF  FAE,FEC
06BE:  MOVLW  0D
06C0:  SUBWF  FEF,W
06C2:  BNZ   06B6
06C4:  CLRF   FEC
.................... 	r_addr = 0xFF; 
06C6:  SETF   0C
.................... 	r_cmd = 0xFF; 
06C8:  SETF   0D
.................... 	r_addr = getAddr(buffer); 
06CA:  CLRF   68
06CC:  MOVLW  12
06CE:  MOVWF  67
06D0:  BRA    01EA
06D2:  MOVFF  01,0C
.................... 	r_cmd = getCmd(buffer); 
06D6:  CLRF   68
06D8:  MOVLW  12
06DA:  MOVWF  67
06DC:  BRA    0220
06DE:  MOVFF  01,0D
....................  
.................... 	if (r_addr == m_addr | !r_addr) { 
06E2:  MOVF   0B,W
06E4:  SUBWF  0C,W
06E6:  BZ    06EC
06E8:  MOVLW  00
06EA:  BRA    06EE
06EC:  MOVLW  01
06EE:  MOVWF  67
06F0:  MOVF   0C,F
06F2:  BZ    06F8
06F4:  MOVLW  00
06F6:  BRA    06FA
06F8:  MOVLW  01
06FA:  IORWF  67,W
06FC:  BZ    0742
.................... 		if (r_cmd == cmd_w) { 
06FE:  MOVF   0D,W
0700:  SUBLW  05
0702:  BNZ   072E
.................... 			gets(buffer); 
0704:  CLRF   FEA
0706:  MOVLW  12
0708:  MOVWF  FE9
070A:  DECF   FE9,F
070C:  BTFSS  F9E.5
070E:  BRA    070C
0710:  MOVFF  FAE,FEC
0714:  MOVLW  0D
0716:  SUBWF  FEF,W
0718:  BNZ   070C
071A:  CLRF   FEC
.................... 			r_pos = getPos(buffer); 
071C:  CLRF   68
071E:  MOVLW  12
0720:  MOVWF  67
0722:  BRA    049C
0724:  MOVFF  02,0F
0728:  MOVFF  01,0E
.................... 		} else if (r_cmd == cmd_r) { 
072C:  BRA    0742
072E:  MOVF   0D,W
0730:  SUBLW  04
0732:  BNZ   0742
.................... 			send_pos(m_addr, r_pos); 
0734:  MOVFF  0B,67
0738:  MOVFF  0F,69
073C:  MOVFF  0E,68
0740:  BRA    067C
.................... 		} 
.................... 	} 
.................... } 
0742:  GOTO   079C (RETURN)
....................  
.................... int main(void) { 
0746:  CLRF   FF8
0748:  BCF    FD0.7
074A:  MOVLW  FE
074C:  MOVWF  00
074E:  MOVLW  06
0750:  MOVWF  01
0752:  MOVLW  02
0754:  MOVWF  FE9
0756:  MOVLW  00
0758:  MOVWF  FEA
075A:  CLRF   FEE
075C:  DECFSZ 00,F
075E:  BRA    075A
0760:  DECFSZ 01,F
0762:  BRA    075A
0764:  CLRF   FEA
0766:  CLRF   FE9
0768:  MOVLW  61
076A:  MOVWF  FAF
076C:  MOVLW  A6
076E:  MOVWF  FAC
0770:  MOVLW  90
0772:  MOVWF  FAB
0774:  SETF   0B
0776:  SETF   0C
0778:  SETF   0D
077A:  MOVLW  30
077C:  MOVWF  0F
077E:  MOVLW  39
0780:  MOVWF  0E
0782:  MOVLW  30
0784:  MOVWF  11
0786:  MOVLW  39
0788:  MOVWF  10
078A:  MOVLW  02
078C:  MOVWF  23
078E:  BSF    FC1.0
0790:  BSF    FC1.1
0792:  BSF    FC1.2
0794:  BCF    FC1.3
....................  
.................... 	m_addr = 2; 
0796:  MOVLW  02
0798:  MOVWF  0B
....................  
.................... 	while (TRUE) { 
.................... 		trata_comunicacao(); 
079A:  BRA    06AE
.................... 	} 
079C:  BRA    079A
.................... 	return 0; 
079E:  MOVLW  00
07A0:  MOVWF  01
.................... } 
07A2:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
