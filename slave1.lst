CCS PCH C Compiler, Version 4.140, 22098               22-ago-14 14:52

               Filename:   D:\Projetos\Serial\slave1.lst

               ROM used:   1938 bytes (6%)
                           Largest free fragment is 30830
               RAM used:   67 (4%) at main() level
                           89 (6%) worst case
               Stack:     3 locations

*
0000:  GOTO   06AE
.................... /* 
....................  * slave.c 
....................  * 
....................  *  Created on: 18/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #include<18F252.h> 
.................... //////// Standard Header file for the PIC18F252 device //////////////// 
.................... #device PIC18F252 
.................... #list 
....................  
.................... #zero_ram 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0050:  CLRF   4D
....................    sign = 0; 
0052:  CLRF   4B
....................    base = 10; 
0054:  MOVLW  0A
0056:  MOVWF  4C
....................    result = 0; 
0058:  CLRF   4A
....................  
....................    if (!s) 
005A:  MOVF   48,W
005C:  IORWF  49,W
005E:  BNZ   0066
....................       return 0; 
0060:  MOVLW  00
0062:  MOVWF  01
0064:  BRA    01E8
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0066:  MOVF   4D,W
0068:  INCF   4D,F
006A:  CLRF   03
006C:  ADDWF  48,W
006E:  MOVWF  FE9
0070:  MOVF   49,W
0072:  ADDWFC 03,W
0074:  MOVWF  FEA
0076:  MOVFF  FEF,4E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
007A:  MOVF   4E,W
007C:  SUBLW  2D
007E:  BNZ   009A
....................    { 
....................       sign = 1;         // Set the sign to negative 
0080:  MOVLW  01
0082:  MOVWF  4B
....................       c = s[index++]; 
0084:  MOVF   4D,W
0086:  INCF   4D,F
0088:  CLRF   03
008A:  ADDWF  48,W
008C:  MOVWF  FE9
008E:  MOVF   49,W
0090:  ADDWFC 03,W
0092:  MOVWF  FEA
0094:  MOVFF  FEF,4E
....................    } 
....................    else if (c == '+') 
0098:  BRA    00B4
009A:  MOVF   4E,W
009C:  SUBLW  2B
009E:  BNZ   00B4
....................    { 
....................       c = s[index++]; 
00A0:  MOVF   4D,W
00A2:  INCF   4D,F
00A4:  CLRF   03
00A6:  ADDWF  48,W
00A8:  MOVWF  FE9
00AA:  MOVF   49,W
00AC:  ADDWFC 03,W
00AE:  MOVWF  FEA
00B0:  MOVFF  FEF,4E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
00B4:  MOVF   4E,W
00B6:  SUBLW  2F
00B8:  BTFSC  FD8.0
00BA:  BRA    01D8
00BC:  MOVF   4E,W
00BE:  SUBLW  39
00C0:  BTFSS  FD8.0
00C2:  BRA    01D8
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
00C4:  MOVF   4E,W
00C6:  SUBLW  30
00C8:  BNZ   010C
00CA:  CLRF   03
00CC:  MOVF   4D,W
00CE:  ADDWF  48,W
00D0:  MOVWF  FE9
00D2:  MOVF   49,W
00D4:  ADDWFC 03,W
00D6:  MOVWF  FEA
00D8:  MOVF   FEF,W
00DA:  SUBLW  78
00DC:  BZ    00F2
00DE:  CLRF   03
00E0:  MOVF   4D,W
00E2:  ADDWF  48,W
00E4:  MOVWF  FE9
00E6:  MOVF   49,W
00E8:  ADDWFC 03,W
00EA:  MOVWF  FEA
00EC:  MOVF   FEF,W
00EE:  SUBLW  58
00F0:  BNZ   010C
....................       { 
....................          base = 16; 
00F2:  MOVLW  10
00F4:  MOVWF  4C
....................          index++; 
00F6:  INCF   4D,F
....................          c = s[index++]; 
00F8:  MOVF   4D,W
00FA:  INCF   4D,F
00FC:  CLRF   03
00FE:  ADDWF  48,W
0100:  MOVWF  FE9
0102:  MOVF   49,W
0104:  ADDWFC 03,W
0106:  MOVWF  FEA
0108:  MOVFF  FEF,4E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
010C:  MOVF   4C,W
010E:  SUBLW  0A
0110:  BNZ   0148
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0112:  MOVF   4E,W
0114:  SUBLW  2F
0116:  BC    0146
0118:  MOVF   4E,W
011A:  SUBLW  39
011C:  BNC   0146
....................             result = 10*result + (c - '0'); 
011E:  MOVLW  0A
0120:  MOVWF  4F
0122:  MOVFF  4A,50
0126:  BRA    0004
0128:  MOVLW  30
012A:  SUBWF  4E,W
012C:  ADDWF  01,W
012E:  MOVWF  4A
....................             c = s[index++]; 
0130:  MOVF   4D,W
0132:  INCF   4D,F
0134:  CLRF   03
0136:  ADDWF  48,W
0138:  MOVWF  FE9
013A:  MOVF   49,W
013C:  ADDWFC 03,W
013E:  MOVWF  FEA
0140:  MOVFF  FEF,4E
....................          } 
0144:  BRA    0112
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0146:  BRA    01D8
0148:  MOVF   4C,W
014A:  SUBLW  10
014C:  BNZ   01D8
....................       { 
....................          c = toupper(c); 
014E:  MOVF   4E,W
0150:  SUBLW  60
0152:  BC    0160
0154:  MOVF   4E,W
0156:  SUBLW  7A
0158:  BNC   0160
015A:  MOVF   4E,W
015C:  ANDLW  DF
015E:  BRA    0162
0160:  MOVF   4E,W
0162:  MOVWF  4E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
0164:  MOVF   4E,W
0166:  SUBLW  2F
0168:  BC    0170
016A:  MOVF   4E,W
016C:  SUBLW  39
016E:  BC    017C
0170:  MOVF   4E,W
0172:  SUBLW  40
0174:  BC    01D8
0176:  MOVF   4E,W
0178:  SUBLW  46
017A:  BNC   01D8
....................             if (c >= '0' && c <= '9') 
017C:  MOVF   4E,W
017E:  SUBLW  2F
0180:  BC    019A
0182:  MOVF   4E,W
0184:  SUBLW  39
0186:  BNC   019A
....................                result = (result << 4) + (c - '0'); 
0188:  SWAPF  4A,W
018A:  MOVWF  4F
018C:  MOVLW  F0
018E:  ANDWF  4F,F
0190:  MOVLW  30
0192:  SUBWF  4E,W
0194:  ADDWF  4F,W
0196:  MOVWF  4A
....................             else 
0198:  BRA    01AC
....................                result = (result << 4) + (c - 'A' + 10); 
019A:  SWAPF  4A,W
019C:  MOVWF  4F
019E:  MOVLW  F0
01A0:  ANDWF  4F,F
01A2:  MOVLW  41
01A4:  SUBWF  4E,W
01A6:  ADDLW  0A
01A8:  ADDWF  4F,W
01AA:  MOVWF  4A
....................  
....................             c = s[index++]; 
01AC:  MOVF   4D,W
01AE:  INCF   4D,F
01B0:  CLRF   03
01B2:  ADDWF  48,W
01B4:  MOVWF  FE9
01B6:  MOVF   49,W
01B8:  ADDWFC 03,W
01BA:  MOVWF  FEA
01BC:  MOVFF  FEF,4E
....................             c = toupper(c); 
01C0:  MOVF   4E,W
01C2:  SUBLW  60
01C4:  BC    01D2
01C6:  MOVF   4E,W
01C8:  SUBLW  7A
01CA:  BNC   01D2
01CC:  MOVF   4E,W
01CE:  ANDLW  DF
01D0:  BRA    01D4
01D2:  MOVF   4E,W
01D4:  MOVWF  4E
....................          } 
01D6:  BRA    0164
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
01D8:  DECFSZ 4B,W
01DA:  BRA    01E4
01DC:  MOVF   4C,W
01DE:  SUBLW  0A
01E0:  BNZ   01E4
....................        result = -result; 
01E2:  NEGF   4A
....................  
....................    return(result); 
01E4:  MOVFF  4A,01
.................... } 
01E8:  RETURN 0
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
02B0:  CLRF   51
....................    sign = 0; 
02B2:  CLRF   4F
....................    base = 10; 
02B4:  MOVLW  0A
02B6:  MOVWF  50
....................    result = 0; 
02B8:  CLRF   4E
02BA:  CLRF   4D
....................  
....................    if (!s) 
02BC:  MOVF   4B,W
02BE:  IORWF  4C,W
02C0:  BNZ   02CA
....................       return 0; 
02C2:  MOVLW  00
02C4:  MOVWF  01
02C6:  MOVWF  02
02C8:  BRA    0498
....................    c = s[index++]; 
02CA:  MOVF   51,W
02CC:  INCF   51,F
02CE:  CLRF   03
02D0:  ADDWF  4B,W
02D2:  MOVWF  FE9
02D4:  MOVF   4C,W
02D6:  ADDWFC 03,W
02D8:  MOVWF  FEA
02DA:  MOVFF  FEF,52
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
02DE:  MOVF   52,W
02E0:  SUBLW  2D
02E2:  BNZ   02FE
....................    { 
....................       sign = 1;         // Set the sign to negative 
02E4:  MOVLW  01
02E6:  MOVWF  4F
....................       c = s[index++]; 
02E8:  MOVF   51,W
02EA:  INCF   51,F
02EC:  CLRF   03
02EE:  ADDWF  4B,W
02F0:  MOVWF  FE9
02F2:  MOVF   4C,W
02F4:  ADDWFC 03,W
02F6:  MOVWF  FEA
02F8:  MOVFF  FEF,52
....................    } 
....................    else if (c == '+') 
02FC:  BRA    0318
02FE:  MOVF   52,W
0300:  SUBLW  2B
0302:  BNZ   0318
....................    { 
....................       c = s[index++]; 
0304:  MOVF   51,W
0306:  INCF   51,F
0308:  CLRF   03
030A:  ADDWF  4B,W
030C:  MOVWF  FE9
030E:  MOVF   4C,W
0310:  ADDWFC 03,W
0312:  MOVWF  FEA
0314:  MOVFF  FEF,52
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0318:  MOVF   52,W
031A:  SUBLW  2F
031C:  BTFSC  FD8.0
031E:  BRA    047C
0320:  MOVF   52,W
0322:  SUBLW  39
0324:  BTFSS  FD8.0
0326:  BRA    047C
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0328:  MOVF   52,W
032A:  SUBLW  30
032C:  BNZ   0370
032E:  CLRF   03
0330:  MOVF   51,W
0332:  ADDWF  4B,W
0334:  MOVWF  FE9
0336:  MOVF   4C,W
0338:  ADDWFC 03,W
033A:  MOVWF  FEA
033C:  MOVF   FEF,W
033E:  SUBLW  78
0340:  BZ    0356
0342:  CLRF   03
0344:  MOVF   51,W
0346:  ADDWF  4B,W
0348:  MOVWF  FE9
034A:  MOVF   4C,W
034C:  ADDWFC 03,W
034E:  MOVWF  FEA
0350:  MOVF   FEF,W
0352:  SUBLW  58
0354:  BNZ   0370
....................       { 
....................          base = 16; 
0356:  MOVLW  10
0358:  MOVWF  50
....................          index++; 
035A:  INCF   51,F
....................          c = s[index++]; 
035C:  MOVF   51,W
035E:  INCF   51,F
0360:  CLRF   03
0362:  ADDWF  4B,W
0364:  MOVWF  FE9
0366:  MOVF   4C,W
0368:  ADDWFC 03,W
036A:  MOVWF  FEA
036C:  MOVFF  FEF,52
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0370:  MOVF   50,W
0372:  SUBLW  0A
0374:  BNZ   03B8
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0376:  MOVF   52,W
0378:  SUBLW  2F
037A:  BC    03B6
037C:  MOVF   52,W
037E:  SUBLW  39
0380:  BNC   03B6
....................             result = 10*result + (c - '0'); 
0382:  CLRF   54
0384:  MOVLW  0A
0386:  MOVWF  53
0388:  MOVFF  4E,56
038C:  MOVFF  4D,55
0390:  BRA    025E
0392:  MOVLW  30
0394:  SUBWF  52,W
0396:  ADDWF  01,W
0398:  MOVWF  4D
039A:  MOVLW  00
039C:  ADDWFC 02,W
039E:  MOVWF  4E
....................             c = s[index++]; 
03A0:  MOVF   51,W
03A2:  INCF   51,F
03A4:  CLRF   03
03A6:  ADDWF  4B,W
03A8:  MOVWF  FE9
03AA:  MOVF   4C,W
03AC:  ADDWFC 03,W
03AE:  MOVWF  FEA
03B0:  MOVFF  FEF,52
....................          } 
03B4:  BRA    0376
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
03B6:  BRA    047C
03B8:  MOVF   50,W
03BA:  SUBLW  10
03BC:  BNZ   047C
....................       { 
....................          c = toupper(c); 
03BE:  MOVF   52,W
03C0:  SUBLW  60
03C2:  BC    03D0
03C4:  MOVF   52,W
03C6:  SUBLW  7A
03C8:  BNC   03D0
03CA:  MOVF   52,W
03CC:  ANDLW  DF
03CE:  BRA    03D2
03D0:  MOVF   52,W
03D2:  MOVWF  52
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
03D4:  MOVF   52,W
03D6:  SUBLW  2F
03D8:  BC    03E0
03DA:  MOVF   52,W
03DC:  SUBLW  39
03DE:  BC    03EC
03E0:  MOVF   52,W
03E2:  SUBLW  40
03E4:  BC    047C
03E6:  MOVF   52,W
03E8:  SUBLW  46
03EA:  BNC   047C
....................             if (c >= '0' && c <= '9') 
03EC:  MOVF   52,W
03EE:  SUBLW  2F
03F0:  BC    0424
03F2:  MOVF   52,W
03F4:  SUBLW  39
03F6:  BNC   0424
....................                result = (result << 4) + (c - '0'); 
03F8:  RLCF   4D,W
03FA:  MOVWF  53
03FC:  RLCF   4E,W
03FE:  MOVWF  54
0400:  RLCF   53,F
0402:  RLCF   54,F
0404:  RLCF   53,F
0406:  RLCF   54,F
0408:  RLCF   53,F
040A:  RLCF   54,F
040C:  MOVLW  F0
040E:  ANDWF  53,F
0410:  MOVLW  30
0412:  SUBWF  52,W
0414:  ADDWF  53,W
0416:  MOVWF  01
0418:  MOVLW  00
041A:  ADDWFC 54,W
041C:  MOVFF  01,4D
0420:  MOVWF  4E
....................             else 
0422:  BRA    0450
....................                result = (result << 4) + (c - 'A' + 10); 
0424:  RLCF   4D,W
0426:  MOVWF  53
0428:  RLCF   4E,W
042A:  MOVWF  54
042C:  RLCF   53,F
042E:  RLCF   54,F
0430:  RLCF   53,F
0432:  RLCF   54,F
0434:  RLCF   53,F
0436:  RLCF   54,F
0438:  MOVLW  F0
043A:  ANDWF  53,F
043C:  MOVLW  41
043E:  SUBWF  52,W
0440:  ADDLW  0A
0442:  ADDWF  53,W
0444:  MOVWF  01
0446:  MOVLW  00
0448:  ADDWFC 54,W
044A:  MOVFF  01,4D
044E:  MOVWF  4E
....................  
....................             c = s[index++];c = toupper(c); 
0450:  MOVF   51,W
0452:  INCF   51,F
0454:  CLRF   03
0456:  ADDWF  4B,W
0458:  MOVWF  FE9
045A:  MOVF   4C,W
045C:  ADDWFC 03,W
045E:  MOVWF  FEA
0460:  MOVFF  FEF,52
0464:  MOVF   52,W
0466:  SUBLW  60
0468:  BC    0476
046A:  MOVF   52,W
046C:  SUBLW  7A
046E:  BNC   0476
0470:  MOVF   52,W
0472:  ANDLW  DF
0474:  BRA    0478
0476:  MOVF   52,W
0478:  MOVWF  52
....................          } 
047A:  BRA    03D4
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
047C:  MOVF   50,W
047E:  SUBLW  0A
0480:  BNZ   0490
0482:  DECFSZ 4F,W
0484:  BRA    0490
....................       result = -result; 
0486:  COMF   4D,F
0488:  COMF   4E,F
048A:  INCF   4D,F
048C:  BTFSC  FD8.2
048E:  INCF   4E,F
....................  
....................    return(result); 
0490:  MOVFF  4D,01
0494:  MOVFF  4E,02
.................... } 
0498:  GOTO   0510 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS 
.................... #use delay(clock=15MHz) 
*
0516:  CLRF   FEA
0518:  MOVLW  45
051A:  MOVWF  FE9
051C:  MOVF   FEF,W
051E:  BZ    053C
0520:  MOVLW  04
0522:  MOVWF  01
0524:  CLRF   00
0526:  DECFSZ 00,F
0528:  BRA    0526
052A:  DECFSZ 01,F
052C:  BRA    0524
052E:  MOVLW  DC
0530:  MOVWF  00
0532:  DECFSZ 00,F
0534:  BRA    0532
0536:  NOP   
0538:  DECFSZ FEF,F
053A:  BRA    0520
053C:  GOTO   0682 (RETURN)
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................  
.................... #include "defines.c" 
.................... /* 
....................  * defines.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #define cmd_parar	0x00 
.................... #define cmd_subir	0x01 
.................... #define cmd_descer	0x02 
.................... #define cmd_r		0x04 
.................... #define cmd_w		0x05 
....................  
.................... #define bto_sobe	PIN_B0 
.................... #define bto_desce	PIN_B1 
....................  
.................... #define debounce 	100 
.................... #define latencia	20 
....................  
.................... #define nrMax		16 
.................... #define buffer_size	16 
.................... #define allSlvs		0 
....................  
....................  
.................... short ctrl_bto; 
....................  
.................... int m_addr = 0xFF; 
.................... int r_addr = 0xFF; 
.................... int r_cmd = 0xFF; 
....................  
.................... long r_pos = 0xFFFF; 
.................... long m_pos = 12345; 
....................  
.................... int buffer[buffer_size]; 
....................  
.................... #include "funcoes.c" 
.................... /* 
....................  * funcoes.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
.................... int getAddr(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
*
01EA:  MOVFF  43,45
01EE:  MOVFF  42,44
....................  
.................... 	aux[0] = *p; 
01F2:  MOVFF  44,FE9
01F6:  MOVFF  45,FEA
01FA:  MOVFF  FEF,46
.................... 	aux[1] = *(p + 1); 
01FE:  MOVLW  01
0200:  ADDWF  44,W
0202:  MOVWF  01
0204:  MOVLW  00
0206:  ADDWFC 45,W
0208:  MOVFF  01,FE9
020C:  MOVWF  FEA
020E:  MOVFF  FEF,47
....................  
.................... 	return atoi(aux); 
0212:  CLRF   49
0214:  MOVLW  46
0216:  MOVWF  48
0218:  RCALL  0050
021A:  MOVF   01,W
.................... } 
021C:  GOTO   071E (RETURN)
....................  
.................... int getCmd(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
0220:  MOVFF  43,45
0224:  MOVFF  42,44
....................  
.................... 	aux[0] = *(p + 2); 
0228:  MOVLW  02
022A:  ADDWF  44,W
022C:  MOVWF  01
022E:  MOVLW  00
0230:  ADDWFC 45,W
0232:  MOVFF  01,FE9
0236:  MOVWF  FEA
0238:  MOVFF  FEF,46
.................... 	aux[1] = *(p + 3); 
023C:  MOVLW  03
023E:  ADDWF  44,W
0240:  MOVWF  01
0242:  MOVLW  00
0244:  ADDWFC 45,W
0246:  MOVFF  01,FE9
024A:  MOVWF  FEA
024C:  MOVFF  FEF,47
....................  
.................... 	return atoi(aux); 
0250:  CLRF   49
0252:  MOVLW  46
0254:  MOVWF  48
0256:  RCALL  0050
0258:  MOVF   01,W
.................... } 
025A:  GOTO   072A (RETURN)
....................  
.................... long getPos(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[5]; 
....................  
.................... 	p = str; 
*
049C:  MOVFF  43,45
04A0:  MOVFF  42,44
....................  
.................... 	aux[0] = *(p + 2); 
04A4:  MOVLW  02
04A6:  ADDWF  44,W
04A8:  MOVWF  01
04AA:  MOVLW  00
04AC:  ADDWFC 45,W
04AE:  MOVFF  01,FE9
04B2:  MOVWF  FEA
04B4:  MOVFF  FEF,46
.................... 	aux[1] = *(p + 3); 
04B8:  MOVLW  03
04BA:  ADDWF  44,W
04BC:  MOVWF  01
04BE:  MOVLW  00
04C0:  ADDWFC 45,W
04C2:  MOVFF  01,FE9
04C6:  MOVWF  FEA
04C8:  MOVFF  FEF,47
.................... 	aux[2] = *(p + 4); 
04CC:  MOVLW  04
04CE:  ADDWF  44,W
04D0:  MOVWF  01
04D2:  MOVLW  00
04D4:  ADDWFC 45,W
04D6:  MOVFF  01,FE9
04DA:  MOVWF  FEA
04DC:  MOVFF  FEF,48
.................... 	aux[3] = *(p + 5); 
04E0:  MOVLW  05
04E2:  ADDWF  44,W
04E4:  MOVWF  01
04E6:  MOVLW  00
04E8:  ADDWFC 45,W
04EA:  MOVFF  01,FE9
04EE:  MOVWF  FEA
04F0:  MOVFF  FEF,49
.................... 	aux[4] = *(p + 6); 
04F4:  MOVLW  06
04F6:  ADDWF  44,W
04F8:  MOVWF  01
04FA:  MOVLW  00
04FC:  ADDWFC 45,W
04FE:  MOVFF  01,FE9
0502:  MOVWF  FEA
0504:  MOVFF  FEF,4A
....................  
.................... 	return atol(aux); 
0508:  CLRF   4C
050A:  MOVLW  46
050C:  MOVWF  4B
050E:  BRA    02B0
0510:  MOVF   02,W
....................  
.................... } 
0512:  GOTO   0770 (RETURN)
....................  
.................... int send_cmd(int addr, int cmd) { 
.................... 	delay_ms(latencia); 
.................... 	printf("%02u%02u\n\r", addr, cmd); 
.................... 	return cmd; 
.................... } 
....................  
.................... void send_pos(int addr, long pos) { 
.................... 	delay_ms(latencia); 
*
067C:  MOVLW  14
067E:  MOVWF  45
0680:  BRA    0516
.................... 	printf("%02u%05lu\n\r", addr, pos); 
0682:  MOVFF  42,45
0686:  MOVLW  01
0688:  MOVWF  46
068A:  BRA    0568
068C:  MOVLW  08
068E:  MOVWF  FE9
0690:  MOVFF  44,46
0694:  MOVFF  43,45
0698:  BRA    05D6
069A:  MOVLW  0A
069C:  BTFSS  F9E.4
069E:  BRA    069C
06A0:  MOVWF  FAD
06A2:  MOVLW  0D
06A4:  BTFSS  F9E.4
06A6:  BRA    06A4
06A8:  MOVWF  FAD
.................... } 
06AA:  GOTO   078E (RETURN)
....................  
.................... int trata_bto(int cmd) { 
.................... 	short sobe = !input(bto_sobe); 
.................... 	short desce = !input(bto_desce); 
.................... 	int ret = cmd; 
....................  
.................... 	if (sobe ^ desce) { 
.................... 		if (!ctrl_bto) { 
.................... 			delay_ms(debounce); 
.................... 			if (!input(bto_sobe)) 
.................... 				ret = send_cmd(allSlvs, cmd_subir); 
.................... 			if (!input(bto_desce)) 
.................... 				ret = send_cmd(allSlvs, cmd_descer); 
.................... 			ctrl_bto = TRUE; 
.................... 		} 
.................... 	} else if (ctrl_bto) { 
.................... 		ctrl_bto = FALSE; 
.................... 		ret = send_cmd(allSlvs, cmd_parar); 
.................... 	} 
....................  
.................... 	return ret; 
.................... } 
....................  
.................... long *recall_pos(int nrSlaves, long pos) { 
.................... 	int i; 
.................... 	static long ret[nrMax]; 
.................... 	int aux[nrMax]; 
....................  
.................... 	delay_ms(latencia); 
.................... 	send_cmd(allSlvs, cmd_w); 
.................... 	send_cmd(allSlvs, pos); 
....................  
.................... 	for (i = 1; i <= nrSlaves; ++i) { 
.................... 		delay_ms(latencia); 
.................... 		send_cmd(i, cmd_r); 
.................... 		gets(aux); 
.................... 		ret[i] = getPos(aux); 
.................... 	} 
....................  
.................... 	return ret; 
.................... } 
....................  
....................  
.................... int main(void) { 
06AE:  CLRF   FF8
06B0:  BCF    FD0.7
06B2:  MOVLW  FE
06B4:  MOVWF  00
06B6:  MOVLW  06
06B8:  MOVWF  01
06BA:  MOVLW  02
06BC:  MOVWF  FE9
06BE:  MOVLW  00
06C0:  MOVWF  FEA
06C2:  CLRF   FEE
06C4:  DECFSZ 00,F
06C6:  BRA    06C2
06C8:  DECFSZ 01,F
06CA:  BRA    06C2
06CC:  CLRF   FEA
06CE:  CLRF   FE9
06D0:  MOVLW  61
06D2:  MOVWF  FAF
06D4:  MOVLW  A6
06D6:  MOVWF  FAC
06D8:  MOVLW  90
06DA:  MOVWF  FAB
06DC:  SETF   0B
06DE:  SETF   0C
06E0:  SETF   0D
06E2:  SETF   0F
06E4:  SETF   0E
06E6:  MOVLW  30
06E8:  MOVWF  11
06EA:  MOVLW  39
06EC:  MOVWF  10
06EE:  BSF    FC1.0
06F0:  BSF    FC1.1
06F2:  BSF    FC1.2
06F4:  BCF    FC1.3
....................  
.................... 	m_addr = 2; 
06F6:  MOVLW  02
06F8:  MOVWF  0B
....................  
.................... 	while (TRUE) { 
.................... 		gets(buffer); 
06FA:  CLRF   FEA
06FC:  MOVLW  12
06FE:  MOVWF  FE9
0700:  DECF   FE9,F
0702:  BTFSS  F9E.5
0704:  BRA    0702
0706:  MOVFF  FAE,FEC
070A:  MOVLW  0D
070C:  SUBWF  FEF,W
070E:  BNZ   0702
0710:  CLRF   FEC
.................... 		r_addr = 0xFF; 
0712:  SETF   0C
.................... 		r_cmd = 0xFF; 
0714:  SETF   0D
.................... 		r_addr = getAddr(buffer); 
0716:  CLRF   43
0718:  MOVLW  12
071A:  MOVWF  42
071C:  BRA    01EA
071E:  MOVFF  01,0C
.................... 		r_cmd = getCmd(buffer); 
0722:  CLRF   43
0724:  MOVLW  12
0726:  MOVWF  42
0728:  BRA    0220
072A:  MOVFF  01,0D
....................  
.................... 		if (r_addr == m_addr | !r_addr) { 
072E:  MOVF   0B,W
0730:  SUBWF  0C,W
0732:  BZ    0738
0734:  MOVLW  00
0736:  BRA    073A
0738:  MOVLW  01
073A:  MOVWF  42
073C:  MOVF   0C,F
073E:  BZ    0744
0740:  MOVLW  00
0742:  BRA    0746
0744:  MOVLW  01
0746:  IORWF  42,W
0748:  BZ    078E
.................... 			if (r_cmd == cmd_w) { 
074A:  MOVF   0D,W
074C:  SUBLW  05
074E:  BNZ   077A
.................... 				gets(buffer); 
0750:  CLRF   FEA
0752:  MOVLW  12
0754:  MOVWF  FE9
0756:  DECF   FE9,F
0758:  BTFSS  F9E.5
075A:  BRA    0758
075C:  MOVFF  FAE,FEC
0760:  MOVLW  0D
0762:  SUBWF  FEF,W
0764:  BNZ   0758
0766:  CLRF   FEC
.................... 				r_pos = getPos(buffer); 
0768:  CLRF   43
076A:  MOVLW  12
076C:  MOVWF  42
076E:  BRA    049C
0770:  MOVFF  02,0F
0774:  MOVFF  01,0E
.................... 			} else if (r_cmd == cmd_r) { 
0778:  BRA    078E
077A:  MOVF   0D,W
077C:  SUBLW  04
077E:  BNZ   078E
.................... 				send_pos(m_addr, r_pos); 
0780:  MOVFF  0B,42
0784:  MOVFF  0F,44
0788:  MOVFF  0E,43
078C:  BRA    067C
.................... 			} 
.................... 		} 
.................... 	} 
078E:  BRA    06FA
.................... } 
0790:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
