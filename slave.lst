CCS PCH C Compiler, Version 4.140, 22098               15-set-14 09:46

               Filename:   D:\Projetos\Serial\slave.lst

               ROM used:   2296 bytes (7%)
                           Largest free fragment is 30468
               RAM used:   127 (8%) at main() level
                           156 (10%) worst case
               Stack:     6 worst case (4 in main + 2 for interrupts)

*
0000:  GOTO   0892
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0106
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... /* 
....................  * slave.c 
....................  * 
....................  *  Created on: 18/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #include<18F252.h> 
.................... //////// Standard Header file for the PIC18F252 device //////////////// 
.................... #device PIC18F252 
.................... #list 
....................  
.................... #zero_ram 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
01E8:  CLRF   x8A
....................    sign = 0; 
01EA:  CLRF   x88
....................    base = 10; 
01EC:  MOVLW  0A
01EE:  MOVWF  x89
....................    result = 0; 
01F0:  CLRF   x87
....................  
....................    if (!s) 
01F2:  MOVF   x85,W
01F4:  IORWF  x86,W
01F6:  BNZ   01FE
....................       return 0; 
01F8:  MOVLW  00
01FA:  MOVWF  01
01FC:  BRA    0380
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
01FE:  MOVF   x8A,W
0200:  INCF   x8A,F
0202:  CLRF   03
0204:  ADDWF  x85,W
0206:  MOVWF  FE9
0208:  MOVF   x86,W
020A:  ADDWFC 03,W
020C:  MOVWF  FEA
020E:  MOVFF  FEF,8B
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0212:  MOVF   x8B,W
0214:  SUBLW  2D
0216:  BNZ   0232
....................    { 
....................       sign = 1;         // Set the sign to negative 
0218:  MOVLW  01
021A:  MOVWF  x88
....................       c = s[index++]; 
021C:  MOVF   x8A,W
021E:  INCF   x8A,F
0220:  CLRF   03
0222:  ADDWF  x85,W
0224:  MOVWF  FE9
0226:  MOVF   x86,W
0228:  ADDWFC 03,W
022A:  MOVWF  FEA
022C:  MOVFF  FEF,8B
....................    } 
....................    else if (c == '+') 
0230:  BRA    024C
0232:  MOVF   x8B,W
0234:  SUBLW  2B
0236:  BNZ   024C
....................    { 
....................       c = s[index++]; 
0238:  MOVF   x8A,W
023A:  INCF   x8A,F
023C:  CLRF   03
023E:  ADDWF  x85,W
0240:  MOVWF  FE9
0242:  MOVF   x86,W
0244:  ADDWFC 03,W
0246:  MOVWF  FEA
0248:  MOVFF  FEF,8B
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
024C:  MOVF   x8B,W
024E:  SUBLW  2F
0250:  BTFSC  FD8.0
0252:  BRA    0370
0254:  MOVF   x8B,W
0256:  SUBLW  39
0258:  BTFSS  FD8.0
025A:  BRA    0370
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
025C:  MOVF   x8B,W
025E:  SUBLW  30
0260:  BNZ   02A4
0262:  CLRF   03
0264:  MOVF   x8A,W
0266:  ADDWF  x85,W
0268:  MOVWF  FE9
026A:  MOVF   x86,W
026C:  ADDWFC 03,W
026E:  MOVWF  FEA
0270:  MOVF   FEF,W
0272:  SUBLW  78
0274:  BZ    028A
0276:  CLRF   03
0278:  MOVF   x8A,W
027A:  ADDWF  x85,W
027C:  MOVWF  FE9
027E:  MOVF   x86,W
0280:  ADDWFC 03,W
0282:  MOVWF  FEA
0284:  MOVF   FEF,W
0286:  SUBLW  58
0288:  BNZ   02A4
....................       { 
....................          base = 16; 
028A:  MOVLW  10
028C:  MOVWF  x89
....................          index++; 
028E:  INCF   x8A,F
....................          c = s[index++]; 
0290:  MOVF   x8A,W
0292:  INCF   x8A,F
0294:  CLRF   03
0296:  ADDWF  x85,W
0298:  MOVWF  FE9
029A:  MOVF   x86,W
029C:  ADDWFC 03,W
029E:  MOVWF  FEA
02A0:  MOVFF  FEF,8B
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
02A4:  MOVF   x89,W
02A6:  SUBLW  0A
02A8:  BNZ   02E0
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
02AA:  MOVF   x8B,W
02AC:  SUBLW  2F
02AE:  BC    02DE
02B0:  MOVF   x8B,W
02B2:  SUBLW  39
02B4:  BNC   02DE
....................             result = 10*result + (c - '0'); 
02B6:  MOVLW  0A
02B8:  MOVWF  x8C
02BA:  MOVFF  87,8D
02BE:  BRA    019C
02C0:  MOVLW  30
02C2:  SUBWF  x8B,W
02C4:  ADDWF  01,W
02C6:  MOVWF  x87
....................             c = s[index++]; 
02C8:  MOVF   x8A,W
02CA:  INCF   x8A,F
02CC:  CLRF   03
02CE:  ADDWF  x85,W
02D0:  MOVWF  FE9
02D2:  MOVF   x86,W
02D4:  ADDWFC 03,W
02D6:  MOVWF  FEA
02D8:  MOVFF  FEF,8B
....................          } 
02DC:  BRA    02AA
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
02DE:  BRA    0370
02E0:  MOVF   x89,W
02E2:  SUBLW  10
02E4:  BNZ   0370
....................       { 
....................          c = toupper(c); 
02E6:  MOVF   x8B,W
02E8:  SUBLW  60
02EA:  BC    02F8
02EC:  MOVF   x8B,W
02EE:  SUBLW  7A
02F0:  BNC   02F8
02F2:  MOVF   x8B,W
02F4:  ANDLW  DF
02F6:  BRA    02FA
02F8:  MOVF   x8B,W
02FA:  MOVWF  x8B
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
02FC:  MOVF   x8B,W
02FE:  SUBLW  2F
0300:  BC    0308
0302:  MOVF   x8B,W
0304:  SUBLW  39
0306:  BC    0314
0308:  MOVF   x8B,W
030A:  SUBLW  40
030C:  BC    0370
030E:  MOVF   x8B,W
0310:  SUBLW  46
0312:  BNC   0370
....................             if (c >= '0' && c <= '9') 
0314:  MOVF   x8B,W
0316:  SUBLW  2F
0318:  BC    0332
031A:  MOVF   x8B,W
031C:  SUBLW  39
031E:  BNC   0332
....................                result = (result << 4) + (c - '0'); 
0320:  SWAPF  x87,W
0322:  MOVWF  x8C
0324:  MOVLW  F0
0326:  ANDWF  x8C,F
0328:  MOVLW  30
032A:  SUBWF  x8B,W
032C:  ADDWF  x8C,W
032E:  MOVWF  x87
....................             else 
0330:  BRA    0344
....................                result = (result << 4) + (c - 'A' + 10); 
0332:  SWAPF  x87,W
0334:  MOVWF  x8C
0336:  MOVLW  F0
0338:  ANDWF  x8C,F
033A:  MOVLW  41
033C:  SUBWF  x8B,W
033E:  ADDLW  0A
0340:  ADDWF  x8C,W
0342:  MOVWF  x87
....................  
....................             c = s[index++]; 
0344:  MOVF   x8A,W
0346:  INCF   x8A,F
0348:  CLRF   03
034A:  ADDWF  x85,W
034C:  MOVWF  FE9
034E:  MOVF   x86,W
0350:  ADDWFC 03,W
0352:  MOVWF  FEA
0354:  MOVFF  FEF,8B
....................             c = toupper(c); 
0358:  MOVF   x8B,W
035A:  SUBLW  60
035C:  BC    036A
035E:  MOVF   x8B,W
0360:  SUBLW  7A
0362:  BNC   036A
0364:  MOVF   x8B,W
0366:  ANDLW  DF
0368:  BRA    036C
036A:  MOVF   x8B,W
036C:  MOVWF  x8B
....................          } 
036E:  BRA    02FC
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0370:  DECFSZ x88,W
0372:  BRA    037C
0374:  MOVF   x89,W
0376:  SUBLW  0A
0378:  BNZ   037C
....................        result = -result; 
037A:  NEGF   x87
....................  
....................    return(result); 
037C:  MOVFF  87,01
.................... } 
0380:  RETURN 0
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0448:  CLRF   x8E
....................    sign = 0; 
044A:  CLRF   x8C
....................    base = 10; 
044C:  MOVLW  0A
044E:  MOVWF  x8D
....................    result = 0; 
0450:  CLRF   x8B
0452:  CLRF   x8A
....................  
....................    if (!s) 
0454:  MOVF   x88,W
0456:  IORWF  x89,W
0458:  BNZ   0462
....................       return 0; 
045A:  MOVLW  00
045C:  MOVWF  01
045E:  MOVWF  02
0460:  BRA    0630
....................    c = s[index++]; 
0462:  MOVF   x8E,W
0464:  INCF   x8E,F
0466:  CLRF   03
0468:  ADDWF  x88,W
046A:  MOVWF  FE9
046C:  MOVF   x89,W
046E:  ADDWFC 03,W
0470:  MOVWF  FEA
0472:  MOVFF  FEF,8F
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0476:  MOVF   x8F,W
0478:  SUBLW  2D
047A:  BNZ   0496
....................    { 
....................       sign = 1;         // Set the sign to negative 
047C:  MOVLW  01
047E:  MOVWF  x8C
....................       c = s[index++]; 
0480:  MOVF   x8E,W
0482:  INCF   x8E,F
0484:  CLRF   03
0486:  ADDWF  x88,W
0488:  MOVWF  FE9
048A:  MOVF   x89,W
048C:  ADDWFC 03,W
048E:  MOVWF  FEA
0490:  MOVFF  FEF,8F
....................    } 
....................    else if (c == '+') 
0494:  BRA    04B0
0496:  MOVF   x8F,W
0498:  SUBLW  2B
049A:  BNZ   04B0
....................    { 
....................       c = s[index++]; 
049C:  MOVF   x8E,W
049E:  INCF   x8E,F
04A0:  CLRF   03
04A2:  ADDWF  x88,W
04A4:  MOVWF  FE9
04A6:  MOVF   x89,W
04A8:  ADDWFC 03,W
04AA:  MOVWF  FEA
04AC:  MOVFF  FEF,8F
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
04B0:  MOVF   x8F,W
04B2:  SUBLW  2F
04B4:  BTFSC  FD8.0
04B6:  BRA    0614
04B8:  MOVF   x8F,W
04BA:  SUBLW  39
04BC:  BTFSS  FD8.0
04BE:  BRA    0614
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
04C0:  MOVF   x8F,W
04C2:  SUBLW  30
04C4:  BNZ   0508
04C6:  CLRF   03
04C8:  MOVF   x8E,W
04CA:  ADDWF  x88,W
04CC:  MOVWF  FE9
04CE:  MOVF   x89,W
04D0:  ADDWFC 03,W
04D2:  MOVWF  FEA
04D4:  MOVF   FEF,W
04D6:  SUBLW  78
04D8:  BZ    04EE
04DA:  CLRF   03
04DC:  MOVF   x8E,W
04DE:  ADDWF  x88,W
04E0:  MOVWF  FE9
04E2:  MOVF   x89,W
04E4:  ADDWFC 03,W
04E6:  MOVWF  FEA
04E8:  MOVF   FEF,W
04EA:  SUBLW  58
04EC:  BNZ   0508
....................       { 
....................          base = 16; 
04EE:  MOVLW  10
04F0:  MOVWF  x8D
....................          index++; 
04F2:  INCF   x8E,F
....................          c = s[index++]; 
04F4:  MOVF   x8E,W
04F6:  INCF   x8E,F
04F8:  CLRF   03
04FA:  ADDWF  x88,W
04FC:  MOVWF  FE9
04FE:  MOVF   x89,W
0500:  ADDWFC 03,W
0502:  MOVWF  FEA
0504:  MOVFF  FEF,8F
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0508:  MOVF   x8D,W
050A:  SUBLW  0A
050C:  BNZ   0550
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
050E:  MOVF   x8F,W
0510:  SUBLW  2F
0512:  BC    054E
0514:  MOVF   x8F,W
0516:  SUBLW  39
0518:  BNC   054E
....................             result = 10*result + (c - '0'); 
051A:  CLRF   x91
051C:  MOVLW  0A
051E:  MOVWF  x90
0520:  MOVFF  8B,93
0524:  MOVFF  8A,92
0528:  BRA    03F6
052A:  MOVLW  30
052C:  SUBWF  x8F,W
052E:  ADDWF  01,W
0530:  MOVWF  x8A
0532:  MOVLW  00
0534:  ADDWFC 02,W
0536:  MOVWF  x8B
....................             c = s[index++]; 
0538:  MOVF   x8E,W
053A:  INCF   x8E,F
053C:  CLRF   03
053E:  ADDWF  x88,W
0540:  MOVWF  FE9
0542:  MOVF   x89,W
0544:  ADDWFC 03,W
0546:  MOVWF  FEA
0548:  MOVFF  FEF,8F
....................          } 
054C:  BRA    050E
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
054E:  BRA    0614
0550:  MOVF   x8D,W
0552:  SUBLW  10
0554:  BNZ   0614
....................       { 
....................          c = toupper(c); 
0556:  MOVF   x8F,W
0558:  SUBLW  60
055A:  BC    0568
055C:  MOVF   x8F,W
055E:  SUBLW  7A
0560:  BNC   0568
0562:  MOVF   x8F,W
0564:  ANDLW  DF
0566:  BRA    056A
0568:  MOVF   x8F,W
056A:  MOVWF  x8F
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
056C:  MOVF   x8F,W
056E:  SUBLW  2F
0570:  BC    0578
0572:  MOVF   x8F,W
0574:  SUBLW  39
0576:  BC    0584
0578:  MOVF   x8F,W
057A:  SUBLW  40
057C:  BC    0614
057E:  MOVF   x8F,W
0580:  SUBLW  46
0582:  BNC   0614
....................             if (c >= '0' && c <= '9') 
0584:  MOVF   x8F,W
0586:  SUBLW  2F
0588:  BC    05BC
058A:  MOVF   x8F,W
058C:  SUBLW  39
058E:  BNC   05BC
....................                result = (result << 4) + (c - '0'); 
0590:  RLCF   x8A,W
0592:  MOVWF  x90
0594:  RLCF   x8B,W
0596:  MOVWF  x91
0598:  RLCF   x90,F
059A:  RLCF   x91,F
059C:  RLCF   x90,F
059E:  RLCF   x91,F
05A0:  RLCF   x90,F
05A2:  RLCF   x91,F
05A4:  MOVLW  F0
05A6:  ANDWF  x90,F
05A8:  MOVLW  30
05AA:  SUBWF  x8F,W
05AC:  ADDWF  x90,W
05AE:  MOVWF  01
05B0:  MOVLW  00
05B2:  ADDWFC x91,W
05B4:  MOVFF  01,8A
05B8:  MOVWF  x8B
....................             else 
05BA:  BRA    05E8
....................                result = (result << 4) + (c - 'A' + 10); 
05BC:  RLCF   x8A,W
05BE:  MOVWF  x90
05C0:  RLCF   x8B,W
05C2:  MOVWF  x91
05C4:  RLCF   x90,F
05C6:  RLCF   x91,F
05C8:  RLCF   x90,F
05CA:  RLCF   x91,F
05CC:  RLCF   x90,F
05CE:  RLCF   x91,F
05D0:  MOVLW  F0
05D2:  ANDWF  x90,F
05D4:  MOVLW  41
05D6:  SUBWF  x8F,W
05D8:  ADDLW  0A
05DA:  ADDWF  x90,W
05DC:  MOVWF  01
05DE:  MOVLW  00
05E0:  ADDWFC x91,W
05E2:  MOVFF  01,8A
05E6:  MOVWF  x8B
....................  
....................             c = s[index++];c = toupper(c); 
05E8:  MOVF   x8E,W
05EA:  INCF   x8E,F
05EC:  CLRF   03
05EE:  ADDWF  x88,W
05F0:  MOVWF  FE9
05F2:  MOVF   x89,W
05F4:  ADDWFC 03,W
05F6:  MOVWF  FEA
05F8:  MOVFF  FEF,8F
05FC:  MOVF   x8F,W
05FE:  SUBLW  60
0600:  BC    060E
0602:  MOVF   x8F,W
0604:  SUBLW  7A
0606:  BNC   060E
0608:  MOVF   x8F,W
060A:  ANDLW  DF
060C:  BRA    0610
060E:  MOVF   x8F,W
0610:  MOVWF  x8F
....................          } 
0612:  BRA    056C
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0614:  MOVF   x8D,W
0616:  SUBLW  0A
0618:  BNZ   0628
061A:  DECFSZ x8C,W
061C:  BRA    0628
....................       result = -result; 
061E:  COMF   x8A,F
0620:  COMF   x8B,F
0622:  INCF   x8A,F
0624:  BTFSC  FD8.2
0626:  INCF   x8B,F
....................  
....................    return(result); 
0628:  MOVFF  8A,01
062C:  MOVFF  8B,02
.................... } 
0630:  GOTO   0690 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS 
.................... #use delay(clock=15MHz) 
*
0696:  CLRF   FEA
0698:  MOVLW  82
069A:  MOVWF  FE9
069C:  MOVF   FEF,W
069E:  BZ    06BC
06A0:  MOVLW  04
06A2:  MOVWF  01
06A4:  CLRF   00
06A6:  DECFSZ 00,F
06A8:  BRA    06A6
06AA:  DECFSZ 01,F
06AC:  BRA    06A4
06AE:  MOVLW  DC
06B0:  MOVWF  00
06B2:  DECFSZ 00,F
06B4:  BRA    06B2
06B6:  NOP   
06B8:  DECFSZ FEF,F
06BA:  BRA    06A0
06BC:  GOTO   0802 (RETURN)
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................  
.................... #include "defines.c" 
.................... /* 
....................  * defines.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
.................... //Comandos 
.................... #define cmd_parar	0x00 
.................... #define cmd_subir	0x01 
.................... #define cmd_descer	0x02 
.................... #define cmd_r		0x04 
.................... #define cmd_w		0x05 
.................... //Entradas 
.................... #define bto_sobe	PIN_B0 
.................... #define bto_desce	PIN_B1 
.................... //Saidas 
.................... #define pin_sobe	PIN_C0 
.................... #define pin_desce	PIN_C1 
.................... //Tempos 
.................... #define debounce 	100 
.................... #define latencia	20 
.................... //definicoes 
.................... #define bufferLen	16 
.................... #define allSlvs		0 
....................  
.................... #include "variaveis.c" 
.................... /* 
....................  * vairaveis.c 
....................  * 
....................  *  Created on: 22/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... short ctrl_bto; 
.................... short RxOk; 
....................  
.................... int m_addr = 0xFF; //meu endereco 
.................... int r_addr = 0xFF; //endereco lido 
.................... int aux_addr = 0xFF; 
.................... int m_cmd = 0xFF; // meu comando atual 
.................... int r_cmd = 0xFF; //comando lido 
.................... int l_cmd = 0xFF; //ultimo comando recebido 
.................... int nrSlv = 2; //nr de escravos da rede 
.................... int i; 
.................... int line; //linha do buffer de leitrua 
....................  
.................... int buffer[bufferLen]; //buffer de leitura 
....................  
.................... long r_pos = 12345; //posicao recebida 
.................... long m_pos = 12345; //minha posicao 
....................  
.................... long *p; 
.................... long pos_slv[bufferLen]; //posicao de todos os escravos 
....................  
.................... #include "funcoes.c" 
.................... /* 
....................  * funcoes.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... int getAddr(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
*
0382:  MOVFF  80,82
0386:  MOVFF  7F,81
....................  
.................... 	aux[0] = *p; 
038A:  MOVFF  81,FE9
038E:  MOVFF  82,FEA
0392:  MOVFF  FEF,83
.................... 	aux[1] = *(p + 1); 
0396:  MOVLW  01
0398:  ADDWF  x81,W
039A:  MOVWF  01
039C:  MOVLW  00
039E:  ADDWFC x82,W
03A0:  MOVFF  01,FE9
03A4:  MOVWF  FEA
03A6:  MOVFF  FEF,84
....................  
.................... 	return atoi(aux); 
03AA:  CLRF   x86
03AC:  MOVLW  83
03AE:  MOVWF  x85
03B0:  RCALL  01E8
03B2:  MOVF   01,W
.................... } 
03B4:  GOTO   083A (RETURN)
....................  
.................... int getCmd(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
03B8:  MOVFF  80,82
03BC:  MOVFF  7F,81
....................  
.................... 	aux[0] = *(p + 2); 
03C0:  MOVLW  02
03C2:  ADDWF  x81,W
03C4:  MOVWF  01
03C6:  MOVLW  00
03C8:  ADDWFC x82,W
03CA:  MOVFF  01,FE9
03CE:  MOVWF  FEA
03D0:  MOVFF  FEF,83
.................... 	aux[1] = *(p + 3); 
03D4:  MOVLW  03
03D6:  ADDWF  x81,W
03D8:  MOVWF  01
03DA:  MOVLW  00
03DC:  ADDWFC x82,W
03DE:  MOVFF  01,FE9
03E2:  MOVWF  FEA
03E4:  MOVFF  FEF,84
....................  
.................... 	return atoi(aux); 
03E8:  CLRF   x86
03EA:  MOVLW  83
03EC:  MOVWF  x85
03EE:  RCALL  01E8
03F0:  MOVF   01,W
.................... } 
03F2:  GOTO   0846 (RETURN)
....................  
.................... long getPos(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[5]; 
....................  
.................... 	p = str; 
*
0634:  MOVFF  80,82
0638:  MOVFF  7F,81
....................  
.................... 	for (i = 0; i < 5; ++i) 
063C:  CLRF   27
063E:  MOVF   27,W
0640:  SUBLW  04
0642:  BNC   0688
.................... 		aux[i] = *(p + i + 2); 
0644:  CLRF   03
0646:  MOVF   27,W
0648:  ADDLW  83
064A:  MOVWF  01
064C:  MOVLW  00
064E:  ADDWFC 03,F
0650:  MOVFF  01,88
0654:  MOVFF  03,89
0658:  MOVF   27,W
065A:  ADDWF  x81,W
065C:  MOVWF  x8A
065E:  MOVLW  00
0660:  ADDWFC x82,W
0662:  MOVWF  x8B
0664:  MOVLW  02
0666:  ADDWF  x8A,W
0668:  MOVWF  01
066A:  MOVLW  00
066C:  ADDWFC x8B,W
066E:  MOVFF  01,FE9
0672:  MOVWF  FEA
0674:  MOVFF  FEF,8A
0678:  MOVFF  89,FEA
067C:  MOVFF  88,FE9
0680:  MOVFF  8A,FEF
0684:  INCF   27,F
0686:  BRA    063E
....................  
.................... 	return atol(aux); 
0688:  CLRF   x89
068A:  MOVLW  83
068C:  MOVWF  x88
068E:  BRA    0448
0690:  MOVF   02,W
....................  
.................... } 
0692:  GOTO   0866 (RETURN)
....................  
.................... int send_cmd(int addr, int cmd) { 
.................... 	delay_ms(latencia); 
.................... 	printf("%02u%02u\n\r", addr, cmd); 
.................... 	return cmd; 
.................... } 
....................  
.................... void send_pos(int addr, long pos) { 
.................... 	delay_ms(latencia); 
*
07FC:  MOVLW  14
07FE:  MOVWF  x82
0800:  BRA    0696
.................... 	printf("%02u%05lu\n\r", addr, pos); 
0802:  MOVFF  7F,82
0806:  MOVLW  01
0808:  MOVWF  x83
080A:  BRA    06E8
080C:  MOVLW  08
080E:  MOVWF  FE9
0810:  MOVFF  81,83
0814:  MOVFF  80,82
0818:  BRA    0756
081A:  MOVLW  0A
081C:  BTFSS  F9E.4
081E:  BRA    081C
0820:  MOVWF  FAD
0822:  MOVLW  0D
0824:  BTFSS  F9E.4
0826:  BRA    0824
0828:  MOVWF  FAD
.................... } 
082A:  GOTO   088A (RETURN)
....................  
.................... long *recall_pos(int nrSlaves, long pos) { 
.................... 	int i; 
.................... 	static long ret[bufferLen]; 
.................... 	int aux[bufferLen]; 
....................  
.................... 	send_cmd(allSlvs, cmd_w); 
.................... 	send_pos(allSlvs, pos); 
....................  
.................... 	for (i = 1; i <= nrSlaves; ++i) { 
.................... 		send_cmd(i, cmd_r); 
.................... 		gets(aux); 
.................... 		ret[i - 1] = getPos(aux); 
.................... 	} 
....................  
.................... 	return ret; 
.................... } 
....................  
.................... int trata_bto(int cmd) { 
.................... 	short sobe = !input(bto_sobe); 
.................... 	short desce = !input(bto_desce); 
.................... 	int ret = cmd; 
....................  
.................... 	if (sobe ^ desce) { 
.................... 		if (!ctrl_bto) { 
.................... 			delay_ms(debounce); 
.................... 			if (!input(bto_sobe)) 
.................... 				ret = send_cmd(allSlvs, cmd_subir); 
.................... 			if (!input(bto_desce)) 
.................... 				ret = send_cmd(allSlvs, cmd_descer); 
.................... 			ctrl_bto = TRUE; 
.................... 		} 
.................... 	} else if (ctrl_bto) { 
.................... 		ctrl_bto = FALSE; 
.................... 		ret = send_cmd(allSlvs, cmd_parar); 
.................... 	} 
....................  
.................... 	return ret; 
.................... } 
....................  
.................... int trata_comunicacao() { 
....................  
.................... 	r_addr = 0xFF; 
082E:  SETF   21
.................... 	r_cmd = 0xFF; 
0830:  SETF   24
....................  
.................... 	r_addr = getAddr(buffer); 
0832:  CLRF   x80
0834:  MOVLW  29
0836:  MOVWF  7F
0838:  BRA    0382
083A:  MOVFF  01,21
.................... 	r_cmd = getCmd(buffer); 
083E:  CLRF   x80
0840:  MOVLW  29
0842:  MOVWF  7F
0844:  BRA    03B8
0846:  MOVFF  01,24
....................  
.................... 	if (r_addr == m_addr || !r_addr) { 
084A:  MOVF   20,W
084C:  SUBWF  21,W
084E:  BZ    0854
0850:  MOVF   21,F
0852:  BNZ   088A
.................... 		if (r_cmd == cmd_w) { 
0854:  MOVF   24,W
0856:  SUBLW  05
0858:  BNZ   0870
.................... 			while (!RxOk) 
.................... 				; 
085A:  BTFSS  1F.1
085C:  BRA    085A
.................... 			r_pos = getPos(buffer); 
085E:  CLRF   x80
0860:  MOVLW  29
0862:  MOVWF  7F
0864:  BRA    0634
0866:  MOVFF  02,3A
086A:  MOVFF  01,39
.................... 		} else if (r_cmd == cmd_r) { 
086E:  BRA    088A
0870:  MOVF   24,W
0872:  SUBLW  04
0874:  BNZ   088A
.................... 			m_pos++; 
0876:  INCF   3B,F
0878:  BTFSC  FD8.2
087A:  INCF   3C,F
.................... 			send_pos(m_addr, m_pos); 
087C:  MOVFF  20,7F
0880:  MOVFF  3C,81
0884:  MOVFF  3B,80
0888:  BRA    07FC
.................... 		} 
.................... 	} 
....................  
.................... 	return r_cmd; 
088A:  MOVFF  24,01
.................... } 
088E:  GOTO   08F4 (RETURN)
....................  
.................... void subir() { 
.................... 	output_low(pin_desce); 
.................... 	delay_ms(latencia >> 1); 
.................... 	output_high(pin_sobe); 
.................... } 
....................  
.................... void descer() { 
.................... 	output_low(pin_sobe); 
.................... 	delay_ms(latencia >> 1); 
.................... 	output_high(pin_desce); 
.................... } 
....................  
.................... void parar() { 
.................... 	output_low(pin_sobe); 
*
0170:  BCF    F94.0
0172:  BCF    F8B.0
.................... 	output_low(pin_desce); 
0174:  BCF    F94.1
0176:  BCF    F8B.1
.................... 	m_pos += get_timer0(); 
0178:  MOVF   FD6,W
017A:  ADDWF  3B,F
017C:  MOVF   FD7,W
017E:  ADDWFC 3C,F
.................... 	set_timer0(0); 
0180:  CLRF   FD7
0182:  CLRF   FD6
.................... } 
0184:  GOTO   0198 (RETURN)
....................  
.................... int getMAddr() { 
*
0152:  SETF   F92
0154:  MOVFF  F80,7F
.................... 	int aux = input_a(); 
.................... 	return ((input_a() & 0xF0) >> 4) & 0x0F; 
0158:  SETF   F92
015A:  MOVF   F80,W
015C:  ANDLW  F0
015E:  MOVWF  00
0160:  SWAPF  00,F
0162:  MOVLW  0F
0164:  ANDWF  00,F
0166:  MOVF   00,W
0168:  ANDLW  0F
016A:  MOVWF  01
.................... } 
016C:  GOTO   0192 (RETURN)
....................  
.................... void init_mstr() { 
.................... //	set_timer0(T0_EXT_H_TO_L | T0_DIV_1); 
.................... //	set_timer1(T1_EXTERNAL | T1_DIV_BY_1); 
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... 	enable_interrupts(GLOBAL); 
....................  
.................... 	m_cmd = cmd_parar; 
.................... 	nrSlv = getMAddr(); 
....................  
.................... 	parar(); 
.................... } 
....................  
.................... void init_slv() { 
.................... //	set_timer0(T0_EXT_H_TO_L | T0_DIV_1); 
.................... //	set_timer1(T1_EXTERNAL | T1_DIV_BY_1); 
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
*
0188:  BSF    F9D.5
.................... 	enable_interrupts(GLOBAL); 
018A:  MOVLW  C0
018C:  IORWF  FF2,F
....................  
.................... 	m_cmd = cmd_parar; 
018E:  CLRF   23
.................... 	m_addr = getMAddr(); 
0190:  BRA    0152
0192:  MOVFF  01,20
....................  
.................... 	parar(); 
0196:  BRA    0170
.................... } 
0198:  GOTO   08EC (RETURN)
....................  
.................... void trata_cmd(int cmd) { 
.................... 	switch (cmd) { 
.................... 	case cmd_subir: 
.................... 		subir(); 
.................... 		break; 
.................... 	case cmd_descer: 
.................... 		descer(); 
.................... 		break; 
.................... 	case cmd_parar: 
.................... 		parar(); 
.................... 		cmd_parar; 
.................... 		break; 
.................... 	default: 
.................... 	} 
.................... } 
....................  
.................... short recivedOk(int *buff) { 
.................... 	int *p; 
....................  
.................... 	for (p = buff; *p != '\0'; p++) 
*
00AE:  MOVFF  97,99
00B2:  MOVFF  96,98
00B6:  MOVFF  99,03
00BA:  MOVFF  98,FE9
00BE:  MOVFF  99,FEA
00C2:  MOVF   FEF,F
00C4:  BZ    00FE
.................... 		if (*p == '\n' && *(p + 1) == '\r') 
00C6:  MOVFF  99,03
00CA:  MOVFF  98,FE9
00CE:  MOVFF  99,FEA
00D2:  MOVF   FEF,W
00D4:  SUBLW  0A
00D6:  BNZ   00F6
00D8:  MOVLW  01
00DA:  ADDWF  x98,W
00DC:  MOVWF  01
00DE:  MOVLW  00
00E0:  ADDWFC x99,W
00E2:  MOVWF  03
00E4:  MOVFF  01,FE9
00E8:  MOVWF  FEA
00EA:  MOVF   FEF,W
00EC:  SUBLW  0D
00EE:  BNZ   00F6
.................... 			return TRUE; 
00F0:  MOVLW  01
00F2:  MOVWF  01
00F4:  BRA    0102
00F6:  INCF   x98,F
00F8:  BTFSC  FD8.2
00FA:  INCF   x99,F
00FC:  BRA    00B6
....................  
.................... 	return FALSE; 
00FE:  MOVLW  00
0100:  MOVWF  01
.................... } 
0102:  GOTO   013C (RETURN)
....................  
.................... #include "interrupcoes.c" 
.................... /* 
....................  * interrupcoes.c 
....................  * 
....................  *  Created on: 02/09/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #int_rda 
.................... void isr_rda() { 
.................... 	clear_interrupt(INT_RDA); 
.................... 	buffer[line++] = getc(); 
0106:  MOVF   28,W
0108:  INCF   28,F
010A:  CLRF   03
010C:  ADDLW  29
010E:  MOVWF  FE9
0110:  MOVLW  00
0112:  ADDWFC 03,W
0114:  MOVWF  FEA
0116:  BTFSS  F9E.5
0118:  BRA    0116
011A:  MOVFF  FAE,FEF
.................... 	buffer[line] = "\0"; 
011E:  CLRF   03
0120:  MOVF   28,W
0122:  ADDLW  29
0124:  MOVWF  01
0126:  MOVLW  00
0128:  ADDWFC 03,F
012A:  MOVFF  03,FEA
012E:  MOVFF  01,FE9
0132:  CLRF   FEF
.................... 	RxOk = recivedOk(buffer); 
0134:  CLRF   x97
0136:  MOVLW  29
0138:  MOVWF  x96
013A:  BRA    00AE
013C:  BCF    1F.1
013E:  BTFSC  01.0
0140:  BSF    1F.1
.................... 	if (RxOk && line) 
0142:  BTFSS  1F.1
0144:  BRA    014C
0146:  MOVF   28,F
0148:  BZ    014C
.................... 		line = 0; 
014A:  CLRF   28
.................... } 
....................  
....................  
014C:  BCF    F9E.5
014E:  GOTO   0060
.................... int main(void) { 
*
0892:  CLRF   FF8
0894:  BCF    FD0.7
0896:  BSF    07.7
0898:  MOVLW  FE
089A:  MOVWF  00
089C:  MOVLW  06
089E:  MOVWF  01
08A0:  MOVLW  02
08A2:  MOVWF  FE9
08A4:  MOVLW  00
08A6:  MOVWF  FEA
08A8:  CLRF   FEE
08AA:  DECFSZ 00,F
08AC:  BRA    08A8
08AE:  DECFSZ 01,F
08B0:  BRA    08A8
08B2:  CLRF   FEA
08B4:  CLRF   FE9
08B6:  MOVLW  61
08B8:  MOVWF  FAF
08BA:  MOVLW  A6
08BC:  MOVWF  FAC
08BE:  MOVLW  90
08C0:  MOVWF  FAB
08C2:  SETF   20
08C4:  SETF   21
08C6:  SETF   22
08C8:  SETF   23
08CA:  SETF   24
08CC:  SETF   25
08CE:  MOVLW  02
08D0:  MOVWF  26
08D2:  MOVLW  30
08D4:  MOVWF  3A
08D6:  MOVLW  39
08D8:  MOVWF  39
08DA:  MOVLW  30
08DC:  MOVWF  3C
08DE:  MOVLW  39
08E0:  MOVWF  3B
08E2:  BSF    FC1.0
08E4:  BSF    FC1.1
08E6:  BSF    FC1.2
08E8:  BCF    FC1.3
....................  
.................... 	init_slv(); 
08EA:  BRA    0188
....................  
.................... 	while (TRUE) { 
....................  
.................... 		if (RxOk) { 
08EC:  BTFSS  1F.1
08EE:  BRA    08F4
.................... 			RxOk = FALSE; 
08F0:  BCF    1F.1
.................... 			trata_comunicacao(); 
08F2:  BRA    082E
.................... 		} 
....................  
.................... 	} 
08F4:  BRA    08EC
....................  
.................... 	return 0; 
08F6:  MOVLW  00
08F8:  MOVWF  01
.................... } 
08FA:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
