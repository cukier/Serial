CCS PCH C Compiler, Version 4.140, 22098               15-set-14 16:00

               Filename:   D:\Projetos\Serial\slave.lst

               ROM used:   2614 bytes (8%)
                           Largest free fragment is 30150
               RAM used:   127 (8%) at main() level
                           156 (10%) worst case
               Stack:     6 worst case (4 in main + 2 for interrupts)

*
0000:  GOTO   09D0
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0144
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... /* 
....................  * slave.c 
....................  * 
....................  *  Created on: 18/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #include<18F252.h> 
.................... //////// Standard Header file for the PIC18F252 device //////////////// 
.................... #device PIC18F252 
.................... #list 
....................  
.................... #zero_ram 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
034C:  CLRF   x8A
....................    sign = 0; 
034E:  CLRF   x88
....................    base = 10; 
0350:  MOVLW  0A
0352:  MOVWF  x89
....................    result = 0; 
0354:  CLRF   x87
....................  
....................    if (!s) 
0356:  MOVF   x85,W
0358:  IORWF  x86,W
035A:  BNZ   0362
....................       return 0; 
035C:  MOVLW  00
035E:  MOVWF  01
0360:  BRA    04E4
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0362:  MOVF   x8A,W
0364:  INCF   x8A,F
0366:  CLRF   03
0368:  ADDWF  x85,W
036A:  MOVWF  FE9
036C:  MOVF   x86,W
036E:  ADDWFC 03,W
0370:  MOVWF  FEA
0372:  MOVFF  FEF,8B
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0376:  MOVF   x8B,W
0378:  SUBLW  2D
037A:  BNZ   0396
....................    { 
....................       sign = 1;         // Set the sign to negative 
037C:  MOVLW  01
037E:  MOVWF  x88
....................       c = s[index++]; 
0380:  MOVF   x8A,W
0382:  INCF   x8A,F
0384:  CLRF   03
0386:  ADDWF  x85,W
0388:  MOVWF  FE9
038A:  MOVF   x86,W
038C:  ADDWFC 03,W
038E:  MOVWF  FEA
0390:  MOVFF  FEF,8B
....................    } 
....................    else if (c == '+') 
0394:  BRA    03B0
0396:  MOVF   x8B,W
0398:  SUBLW  2B
039A:  BNZ   03B0
....................    { 
....................       c = s[index++]; 
039C:  MOVF   x8A,W
039E:  INCF   x8A,F
03A0:  CLRF   03
03A2:  ADDWF  x85,W
03A4:  MOVWF  FE9
03A6:  MOVF   x86,W
03A8:  ADDWFC 03,W
03AA:  MOVWF  FEA
03AC:  MOVFF  FEF,8B
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
03B0:  MOVF   x8B,W
03B2:  SUBLW  2F
03B4:  BTFSC  FD8.0
03B6:  BRA    04D4
03B8:  MOVF   x8B,W
03BA:  SUBLW  39
03BC:  BTFSS  FD8.0
03BE:  BRA    04D4
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
03C0:  MOVF   x8B,W
03C2:  SUBLW  30
03C4:  BNZ   0408
03C6:  CLRF   03
03C8:  MOVF   x8A,W
03CA:  ADDWF  x85,W
03CC:  MOVWF  FE9
03CE:  MOVF   x86,W
03D0:  ADDWFC 03,W
03D2:  MOVWF  FEA
03D4:  MOVF   FEF,W
03D6:  SUBLW  78
03D8:  BZ    03EE
03DA:  CLRF   03
03DC:  MOVF   x8A,W
03DE:  ADDWF  x85,W
03E0:  MOVWF  FE9
03E2:  MOVF   x86,W
03E4:  ADDWFC 03,W
03E6:  MOVWF  FEA
03E8:  MOVF   FEF,W
03EA:  SUBLW  58
03EC:  BNZ   0408
....................       { 
....................          base = 16; 
03EE:  MOVLW  10
03F0:  MOVWF  x89
....................          index++; 
03F2:  INCF   x8A,F
....................          c = s[index++]; 
03F4:  MOVF   x8A,W
03F6:  INCF   x8A,F
03F8:  CLRF   03
03FA:  ADDWF  x85,W
03FC:  MOVWF  FE9
03FE:  MOVF   x86,W
0400:  ADDWFC 03,W
0402:  MOVWF  FEA
0404:  MOVFF  FEF,8B
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0408:  MOVF   x89,W
040A:  SUBLW  0A
040C:  BNZ   0444
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
040E:  MOVF   x8B,W
0410:  SUBLW  2F
0412:  BC    0442
0414:  MOVF   x8B,W
0416:  SUBLW  39
0418:  BNC   0442
....................             result = 10*result + (c - '0'); 
041A:  MOVLW  0A
041C:  MOVWF  x8C
041E:  MOVFF  87,8D
0422:  BRA    0300
0424:  MOVLW  30
0426:  SUBWF  x8B,W
0428:  ADDWF  01,W
042A:  MOVWF  x87
....................             c = s[index++]; 
042C:  MOVF   x8A,W
042E:  INCF   x8A,F
0430:  CLRF   03
0432:  ADDWF  x85,W
0434:  MOVWF  FE9
0436:  MOVF   x86,W
0438:  ADDWFC 03,W
043A:  MOVWF  FEA
043C:  MOVFF  FEF,8B
....................          } 
0440:  BRA    040E
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0442:  BRA    04D4
0444:  MOVF   x89,W
0446:  SUBLW  10
0448:  BNZ   04D4
....................       { 
....................          c = toupper(c); 
044A:  MOVF   x8B,W
044C:  SUBLW  60
044E:  BC    045C
0450:  MOVF   x8B,W
0452:  SUBLW  7A
0454:  BNC   045C
0456:  MOVF   x8B,W
0458:  ANDLW  DF
045A:  BRA    045E
045C:  MOVF   x8B,W
045E:  MOVWF  x8B
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
0460:  MOVF   x8B,W
0462:  SUBLW  2F
0464:  BC    046C
0466:  MOVF   x8B,W
0468:  SUBLW  39
046A:  BC    0478
046C:  MOVF   x8B,W
046E:  SUBLW  40
0470:  BC    04D4
0472:  MOVF   x8B,W
0474:  SUBLW  46
0476:  BNC   04D4
....................             if (c >= '0' && c <= '9') 
0478:  MOVF   x8B,W
047A:  SUBLW  2F
047C:  BC    0496
047E:  MOVF   x8B,W
0480:  SUBLW  39
0482:  BNC   0496
....................                result = (result << 4) + (c - '0'); 
0484:  SWAPF  x87,W
0486:  MOVWF  x8C
0488:  MOVLW  F0
048A:  ANDWF  x8C,F
048C:  MOVLW  30
048E:  SUBWF  x8B,W
0490:  ADDWF  x8C,W
0492:  MOVWF  x87
....................             else 
0494:  BRA    04A8
....................                result = (result << 4) + (c - 'A' + 10); 
0496:  SWAPF  x87,W
0498:  MOVWF  x8C
049A:  MOVLW  F0
049C:  ANDWF  x8C,F
049E:  MOVLW  41
04A0:  SUBWF  x8B,W
04A2:  ADDLW  0A
04A4:  ADDWF  x8C,W
04A6:  MOVWF  x87
....................  
....................             c = s[index++]; 
04A8:  MOVF   x8A,W
04AA:  INCF   x8A,F
04AC:  CLRF   03
04AE:  ADDWF  x85,W
04B0:  MOVWF  FE9
04B2:  MOVF   x86,W
04B4:  ADDWFC 03,W
04B6:  MOVWF  FEA
04B8:  MOVFF  FEF,8B
....................             c = toupper(c); 
04BC:  MOVF   x8B,W
04BE:  SUBLW  60
04C0:  BC    04CE
04C2:  MOVF   x8B,W
04C4:  SUBLW  7A
04C6:  BNC   04CE
04C8:  MOVF   x8B,W
04CA:  ANDLW  DF
04CC:  BRA    04D0
04CE:  MOVF   x8B,W
04D0:  MOVWF  x8B
....................          } 
04D2:  BRA    0460
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
04D4:  DECFSZ x88,W
04D6:  BRA    04E0
04D8:  MOVF   x89,W
04DA:  SUBLW  0A
04DC:  BNZ   04E0
....................        result = -result; 
04DE:  NEGF   x87
....................  
....................    return(result); 
04E0:  MOVFF  87,01
.................... } 
04E4:  RETURN 0
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
05AC:  CLRF   x8E
....................    sign = 0; 
05AE:  CLRF   x8C
....................    base = 10; 
05B0:  MOVLW  0A
05B2:  MOVWF  x8D
....................    result = 0; 
05B4:  CLRF   x8B
05B6:  CLRF   x8A
....................  
....................    if (!s) 
05B8:  MOVF   x88,W
05BA:  IORWF  x89,W
05BC:  BNZ   05C6
....................       return 0; 
05BE:  MOVLW  00
05C0:  MOVWF  01
05C2:  MOVWF  02
05C4:  BRA    0794
....................    c = s[index++]; 
05C6:  MOVF   x8E,W
05C8:  INCF   x8E,F
05CA:  CLRF   03
05CC:  ADDWF  x88,W
05CE:  MOVWF  FE9
05D0:  MOVF   x89,W
05D2:  ADDWFC 03,W
05D4:  MOVWF  FEA
05D6:  MOVFF  FEF,8F
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
05DA:  MOVF   x8F,W
05DC:  SUBLW  2D
05DE:  BNZ   05FA
....................    { 
....................       sign = 1;         // Set the sign to negative 
05E0:  MOVLW  01
05E2:  MOVWF  x8C
....................       c = s[index++]; 
05E4:  MOVF   x8E,W
05E6:  INCF   x8E,F
05E8:  CLRF   03
05EA:  ADDWF  x88,W
05EC:  MOVWF  FE9
05EE:  MOVF   x89,W
05F0:  ADDWFC 03,W
05F2:  MOVWF  FEA
05F4:  MOVFF  FEF,8F
....................    } 
....................    else if (c == '+') 
05F8:  BRA    0614
05FA:  MOVF   x8F,W
05FC:  SUBLW  2B
05FE:  BNZ   0614
....................    { 
....................       c = s[index++]; 
0600:  MOVF   x8E,W
0602:  INCF   x8E,F
0604:  CLRF   03
0606:  ADDWF  x88,W
0608:  MOVWF  FE9
060A:  MOVF   x89,W
060C:  ADDWFC 03,W
060E:  MOVWF  FEA
0610:  MOVFF  FEF,8F
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0614:  MOVF   x8F,W
0616:  SUBLW  2F
0618:  BTFSC  FD8.0
061A:  BRA    0778
061C:  MOVF   x8F,W
061E:  SUBLW  39
0620:  BTFSS  FD8.0
0622:  BRA    0778
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0624:  MOVF   x8F,W
0626:  SUBLW  30
0628:  BNZ   066C
062A:  CLRF   03
062C:  MOVF   x8E,W
062E:  ADDWF  x88,W
0630:  MOVWF  FE9
0632:  MOVF   x89,W
0634:  ADDWFC 03,W
0636:  MOVWF  FEA
0638:  MOVF   FEF,W
063A:  SUBLW  78
063C:  BZ    0652
063E:  CLRF   03
0640:  MOVF   x8E,W
0642:  ADDWF  x88,W
0644:  MOVWF  FE9
0646:  MOVF   x89,W
0648:  ADDWFC 03,W
064A:  MOVWF  FEA
064C:  MOVF   FEF,W
064E:  SUBLW  58
0650:  BNZ   066C
....................       { 
....................          base = 16; 
0652:  MOVLW  10
0654:  MOVWF  x8D
....................          index++; 
0656:  INCF   x8E,F
....................          c = s[index++]; 
0658:  MOVF   x8E,W
065A:  INCF   x8E,F
065C:  CLRF   03
065E:  ADDWF  x88,W
0660:  MOVWF  FE9
0662:  MOVF   x89,W
0664:  ADDWFC 03,W
0666:  MOVWF  FEA
0668:  MOVFF  FEF,8F
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
066C:  MOVF   x8D,W
066E:  SUBLW  0A
0670:  BNZ   06B4
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0672:  MOVF   x8F,W
0674:  SUBLW  2F
0676:  BC    06B2
0678:  MOVF   x8F,W
067A:  SUBLW  39
067C:  BNC   06B2
....................             result = 10*result + (c - '0'); 
067E:  CLRF   x91
0680:  MOVLW  0A
0682:  MOVWF  x90
0684:  MOVFF  8B,93
0688:  MOVFF  8A,92
068C:  BRA    055A
068E:  MOVLW  30
0690:  SUBWF  x8F,W
0692:  ADDWF  01,W
0694:  MOVWF  x8A
0696:  MOVLW  00
0698:  ADDWFC 02,W
069A:  MOVWF  x8B
....................             c = s[index++]; 
069C:  MOVF   x8E,W
069E:  INCF   x8E,F
06A0:  CLRF   03
06A2:  ADDWF  x88,W
06A4:  MOVWF  FE9
06A6:  MOVF   x89,W
06A8:  ADDWFC 03,W
06AA:  MOVWF  FEA
06AC:  MOVFF  FEF,8F
....................          } 
06B0:  BRA    0672
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
06B2:  BRA    0778
06B4:  MOVF   x8D,W
06B6:  SUBLW  10
06B8:  BNZ   0778
....................       { 
....................          c = toupper(c); 
06BA:  MOVF   x8F,W
06BC:  SUBLW  60
06BE:  BC    06CC
06C0:  MOVF   x8F,W
06C2:  SUBLW  7A
06C4:  BNC   06CC
06C6:  MOVF   x8F,W
06C8:  ANDLW  DF
06CA:  BRA    06CE
06CC:  MOVF   x8F,W
06CE:  MOVWF  x8F
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
06D0:  MOVF   x8F,W
06D2:  SUBLW  2F
06D4:  BC    06DC
06D6:  MOVF   x8F,W
06D8:  SUBLW  39
06DA:  BC    06E8
06DC:  MOVF   x8F,W
06DE:  SUBLW  40
06E0:  BC    0778
06E2:  MOVF   x8F,W
06E4:  SUBLW  46
06E6:  BNC   0778
....................             if (c >= '0' && c <= '9') 
06E8:  MOVF   x8F,W
06EA:  SUBLW  2F
06EC:  BC    0720
06EE:  MOVF   x8F,W
06F0:  SUBLW  39
06F2:  BNC   0720
....................                result = (result << 4) + (c - '0'); 
06F4:  RLCF   x8A,W
06F6:  MOVWF  x90
06F8:  RLCF   x8B,W
06FA:  MOVWF  x91
06FC:  RLCF   x90,F
06FE:  RLCF   x91,F
0700:  RLCF   x90,F
0702:  RLCF   x91,F
0704:  RLCF   x90,F
0706:  RLCF   x91,F
0708:  MOVLW  F0
070A:  ANDWF  x90,F
070C:  MOVLW  30
070E:  SUBWF  x8F,W
0710:  ADDWF  x90,W
0712:  MOVWF  01
0714:  MOVLW  00
0716:  ADDWFC x91,W
0718:  MOVFF  01,8A
071C:  MOVWF  x8B
....................             else 
071E:  BRA    074C
....................                result = (result << 4) + (c - 'A' + 10); 
0720:  RLCF   x8A,W
0722:  MOVWF  x90
0724:  RLCF   x8B,W
0726:  MOVWF  x91
0728:  RLCF   x90,F
072A:  RLCF   x91,F
072C:  RLCF   x90,F
072E:  RLCF   x91,F
0730:  RLCF   x90,F
0732:  RLCF   x91,F
0734:  MOVLW  F0
0736:  ANDWF  x90,F
0738:  MOVLW  41
073A:  SUBWF  x8F,W
073C:  ADDLW  0A
073E:  ADDWF  x90,W
0740:  MOVWF  01
0742:  MOVLW  00
0744:  ADDWFC x91,W
0746:  MOVFF  01,8A
074A:  MOVWF  x8B
....................  
....................             c = s[index++];c = toupper(c); 
074C:  MOVF   x8E,W
074E:  INCF   x8E,F
0750:  CLRF   03
0752:  ADDWF  x88,W
0754:  MOVWF  FE9
0756:  MOVF   x89,W
0758:  ADDWFC 03,W
075A:  MOVWF  FEA
075C:  MOVFF  FEF,8F
0760:  MOVF   x8F,W
0762:  SUBLW  60
0764:  BC    0772
0766:  MOVF   x8F,W
0768:  SUBLW  7A
076A:  BNC   0772
076C:  MOVF   x8F,W
076E:  ANDLW  DF
0770:  BRA    0774
0772:  MOVF   x8F,W
0774:  MOVWF  x8F
....................          } 
0776:  BRA    06D0
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0778:  MOVF   x8D,W
077A:  SUBLW  0A
077C:  BNZ   078C
077E:  DECFSZ x8C,W
0780:  BRA    078C
....................       result = -result; 
0782:  COMF   x8A,F
0784:  COMF   x8B,F
0786:  INCF   x8A,F
0788:  BTFSC  FD8.2
078A:  INCF   x8B,F
....................  
....................    return(result); 
078C:  MOVFF  8A,01
0790:  MOVFF  8B,02
.................... } 
0794:  GOTO   07F4 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS 
.................... #use delay(clock=15MHz) 
*
07FA:  CLRF   FEA
07FC:  MOVLW  82
07FE:  MOVWF  FE9
0800:  MOVF   FEF,W
0802:  BZ    0820
0804:  MOVLW  04
0806:  MOVWF  01
0808:  CLRF   00
080A:  DECFSZ 00,F
080C:  BRA    080A
080E:  DECFSZ 01,F
0810:  BRA    0808
0812:  MOVLW  DC
0814:  MOVWF  00
0816:  DECFSZ 00,F
0818:  BRA    0816
081A:  NOP   
081C:  DECFSZ FEF,F
081E:  BRA    0804
0820:  GOTO   093E (RETURN)
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................  
.................... #include "defines.c" 
.................... /* 
....................  * defines.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
.................... //Comandos 
.................... #define cmd_parar	0x00 
.................... #define cmd_subir	0x01 
.................... #define cmd_descer	0x02 
.................... #define cmd_r		0x04 
.................... #define cmd_w		0x05 
.................... //Entradas 
.................... #define bto_sobe	PIN_B0 
.................... #define bto_desce	PIN_B1 
.................... //Saidas 
.................... #define pin_sobe	PIN_C0 
.................... #define pin_desce	PIN_C1 
.................... //Tempos 
.................... #define debounce 	100 
.................... #define latencia	20 
.................... //definicoes 
.................... #define bufferLen	16 
.................... #define allSlvs		0 
....................  
.................... #include "variaveis.c" 
.................... /* 
....................  * vairaveis.c 
....................  * 
....................  *  Created on: 22/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... short ctrl_bto; 
.................... short RxOk; 
....................  
.................... int m_addr = 0xFF; //meu endereco 
.................... int r_addr = 0xFF; //endereco lido 
.................... int aux_addr = 0xFF; 
.................... int m_cmd = 0xFF; // meu comando atual 
.................... int r_cmd = 0xFF; //comando lido 
.................... int l_cmd = 0xFF; //ultimo comando recebido 
.................... int nrSlv = 2; //nr de escravos da rede 
.................... int i; 
.................... int line; //linha do buffer de leitrua 
....................  
.................... int buffer[bufferLen]; //buffer de leitura 
....................  
.................... long r_pos = 12345; //posicao recebida 
.................... long m_pos = 12345; //minha posicao 
....................  
.................... long *p; 
.................... long pos_slv[bufferLen]; //posicao de todos os escravos 
....................  
.................... #include "funcoes.c" 
.................... /* 
....................  * funcoes.c 
....................  * 
....................  *  Created on: 21/08/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... int getAddr(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
*
04E6:  MOVFF  80,82
04EA:  MOVFF  7F,81
....................  
.................... 	aux[0] = *p; 
04EE:  MOVFF  81,FE9
04F2:  MOVFF  82,FEA
04F6:  MOVFF  FEF,83
.................... 	aux[1] = *(p + 1); 
04FA:  MOVLW  01
04FC:  ADDWF  x81,W
04FE:  MOVWF  01
0500:  MOVLW  00
0502:  ADDWFC x82,W
0504:  MOVFF  01,FE9
0508:  MOVWF  FEA
050A:  MOVFF  FEF,84
....................  
.................... 	return atoi(aux); 
050E:  CLRF   x86
0510:  MOVLW  83
0512:  MOVWF  x85
0514:  RCALL  034C
0516:  MOVF   01,W
.................... } 
0518:  GOTO   0976 (RETURN)
....................  
.................... int getCmd(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[2]; 
....................  
.................... 	p = str; 
051C:  MOVFF  80,82
0520:  MOVFF  7F,81
....................  
.................... 	aux[0] = *(p + 2); 
0524:  MOVLW  02
0526:  ADDWF  x81,W
0528:  MOVWF  01
052A:  MOVLW  00
052C:  ADDWFC x82,W
052E:  MOVFF  01,FE9
0532:  MOVWF  FEA
0534:  MOVFF  FEF,83
.................... 	aux[1] = *(p + 3); 
0538:  MOVLW  03
053A:  ADDWF  x81,W
053C:  MOVWF  01
053E:  MOVLW  00
0540:  ADDWFC x82,W
0542:  MOVFF  01,FE9
0546:  MOVWF  FEA
0548:  MOVFF  FEF,84
....................  
.................... 	return atoi(aux); 
054C:  CLRF   x86
054E:  MOVLW  83
0550:  MOVWF  x85
0552:  RCALL  034C
0554:  MOVF   01,W
.................... } 
0556:  GOTO   0982 (RETURN)
....................  
.................... long getPos(int *str) { 
....................  
.................... 	int *p; 
.................... 	int aux[5]; 
....................  
.................... 	p = str; 
*
0798:  MOVFF  80,82
079C:  MOVFF  7F,81
....................  
.................... 	for (i = 0; i < 5; ++i) 
07A0:  CLRF   27
07A2:  MOVF   27,W
07A4:  SUBLW  04
07A6:  BNC   07EC
.................... 		aux[i] = *(p + i + 2); 
07A8:  CLRF   03
07AA:  MOVF   27,W
07AC:  ADDLW  83
07AE:  MOVWF  01
07B0:  MOVLW  00
07B2:  ADDWFC 03,F
07B4:  MOVFF  01,88
07B8:  MOVFF  03,89
07BC:  MOVF   27,W
07BE:  ADDWF  x81,W
07C0:  MOVWF  x8A
07C2:  MOVLW  00
07C4:  ADDWFC x82,W
07C6:  MOVWF  x8B
07C8:  MOVLW  02
07CA:  ADDWF  x8A,W
07CC:  MOVWF  01
07CE:  MOVLW  00
07D0:  ADDWFC x8B,W
07D2:  MOVFF  01,FE9
07D6:  MOVWF  FEA
07D8:  MOVFF  FEF,8A
07DC:  MOVFF  89,FEA
07E0:  MOVFF  88,FE9
07E4:  MOVFF  8A,FEF
07E8:  INCF   27,F
07EA:  BRA    07A2
....................  
.................... 	return atol(aux); 
07EC:  CLRF   x89
07EE:  MOVLW  83
07F0:  MOVWF  x88
07F2:  BRA    05AC
07F4:  MOVF   02,W
....................  
.................... } 
07F6:  GOTO   09A4 (RETURN)
....................  
.................... int send_cmd(int addr, int cmd) { 
.................... 	delay_ms(latencia); 
.................... 	printf("%02u%02u\n\r", addr, cmd); 
.................... 	return cmd; 
.................... } 
....................  
.................... void send_pos(int addr, long pos) { 
.................... 	delay_ms(latencia); 
*
0938:  MOVLW  14
093A:  MOVWF  x82
093C:  BRA    07FA
.................... 	printf("%02u%05lu\n\r", addr, pos); 
093E:  MOVFF  7F,82
0942:  MOVLW  01
0944:  MOVWF  x83
0946:  BRA    0824
0948:  MOVLW  08
094A:  MOVWF  FE9
094C:  MOVFF  81,83
0950:  MOVFF  80,82
0954:  BRA    0892
0956:  MOVLW  0A
0958:  BTFSS  F9E.4
095A:  BRA    0958
095C:  MOVWF  FAD
095E:  MOVLW  0D
0960:  BTFSS  F9E.4
0962:  BRA    0960
0964:  MOVWF  FAD
.................... } 
0966:  GOTO   09C8 (RETURN)
....................  
.................... long *recall_pos(int nrSlaves, long pos) { 
.................... 	int i; 
.................... 	static long ret[bufferLen]; 
....................  
.................... 	send_cmd(allSlvs, cmd_w); 
.................... 	send_pos(allSlvs, pos); 
....................  
.................... 	for (i = 1; i <= nrSlaves; ++i) { 
.................... 		send_cmd(i, cmd_r); 
.................... 		delay_ms(latencia * 2); 
.................... 		while (!RxOk) 
.................... 			; 
.................... 		RxOk = FALSE; 
.................... 		ret[i - 1] = getPos(buffer); 
.................... 	} 
....................  
.................... 	return ret; 
.................... } 
....................  
.................... int trata_bto(int cmd) { 
.................... 	short sobe = !input(bto_sobe); 
.................... 	short desce = !input(bto_desce); 
.................... 	int ret = cmd; 
....................  
.................... 	if (sobe ^ desce) { 
.................... 		if (!ctrl_bto) { 
.................... 			delay_ms(debounce); 
.................... 			if (!input(bto_sobe)) 
.................... 				ret = send_cmd(allSlvs, cmd_subir); 
.................... 			if (!input(bto_desce)) 
.................... 				ret = send_cmd(allSlvs, cmd_descer); 
.................... 			ctrl_bto = TRUE; 
.................... 		} 
.................... 	} else if (ctrl_bto) { 
.................... 		ctrl_bto = FALSE; 
.................... 		ret = send_cmd(allSlvs, cmd_parar); 
.................... 	} 
....................  
.................... 	return ret; 
.................... } 
....................  
.................... int trata_comunicacao() { 
....................  
.................... 	r_addr = 0xFF; 
096A:  SETF   21
.................... 	r_cmd = 0xFF; 
096C:  SETF   24
....................  
.................... 	r_addr = getAddr(buffer); 
096E:  CLRF   x80
0970:  MOVLW  29
0972:  MOVWF  7F
0974:  BRA    04E6
0976:  MOVFF  01,21
.................... 	r_cmd = getCmd(buffer); 
097A:  CLRF   x80
097C:  MOVLW  29
097E:  MOVWF  7F
0980:  BRA    051C
0982:  MOVFF  01,24
....................  
.................... 	if (r_addr == m_addr || !r_addr) { 
0986:  MOVF   20,W
0988:  SUBWF  21,W
098A:  BZ    0990
098C:  MOVF   21,F
098E:  BNZ   09C8
.................... 		if (r_cmd == cmd_w) { 
0990:  MOVF   24,W
0992:  SUBLW  05
0994:  BNZ   09AE
.................... 			while (!RxOk) 
.................... 				; 
0996:  BTFSS  1F.1
0998:  BRA    0996
.................... 			RxOk = FALSE; 
099A:  BCF    1F.1
.................... 			r_pos = getPos(buffer); 
099C:  CLRF   x80
099E:  MOVLW  29
09A0:  MOVWF  7F
09A2:  BRA    0798
09A4:  MOVFF  02,3A
09A8:  MOVFF  01,39
.................... 		} else if (r_cmd == cmd_r) { 
09AC:  BRA    09C8
09AE:  MOVF   24,W
09B0:  SUBLW  04
09B2:  BNZ   09C8
.................... 			m_pos++; 
09B4:  INCF   3B,F
09B6:  BTFSC  FD8.2
09B8:  INCF   3C,F
.................... 			send_pos(m_addr, m_pos); 
09BA:  MOVFF  20,7F
09BE:  MOVFF  3C,81
09C2:  MOVFF  3B,80
09C6:  BRA    0938
.................... 		} 
.................... 	} 
....................  
.................... 	return r_cmd; 
09C8:  MOVFF  24,01
.................... } 
09CC:  GOTO   0A32 (RETURN)
....................  
.................... void subir() { 
.................... 	output_low(pin_desce); 
.................... 	delay_ms(latencia >> 1); 
.................... 	output_high(pin_sobe); 
.................... } 
....................  
.................... void descer() { 
.................... 	output_low(pin_sobe); 
.................... 	delay_ms(latencia >> 1); 
.................... 	output_high(pin_desce); 
.................... } 
....................  
.................... void parar() { 
.................... 	output_low(pin_sobe); 
*
01AE:  BCF    F94.0
01B0:  BCF    F8B.0
.................... 	output_low(pin_desce); 
01B2:  BCF    F94.1
01B4:  BCF    F8B.1
.................... 	m_pos += get_timer0(); 
01B6:  MOVF   FD6,W
01B8:  ADDWF  3B,F
01BA:  MOVF   FD7,W
01BC:  ADDWFC 3C,F
.................... 	set_timer0(0); 
01BE:  CLRF   FD7
01C0:  CLRF   FD6
.................... } 
01C2:  GOTO   02D4 (RETURN)
....................  
.................... int getMAddr() { 
*
0190:  SETF   F92
0192:  MOVFF  F80,7F
.................... 	int aux = input_a(); 
.................... 	return ((input_a() & 0xF0) >> 4) & 0x0F; 
0196:  SETF   F92
0198:  MOVF   F80,W
019A:  ANDLW  F0
019C:  MOVWF  00
019E:  SWAPF  00,F
01A0:  MOVLW  0F
01A2:  ANDWF  00,F
01A4:  MOVF   00,W
01A6:  ANDLW  0F
01A8:  MOVWF  01
.................... } 
01AA:  GOTO   02CE (RETURN)
....................  
.................... void init_mstr() { 
.................... //	set_timer0(T0_EXT_H_TO_L | T0_DIV_1); 
.................... //	set_timer1(T1_EXTERNAL | T1_DIV_BY_1); 
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... 	enable_interrupts(GLOBAL); 
....................  
.................... 	m_cmd = cmd_parar; 
.................... 	nrSlv = getMAddr(); 
....................  
.................... 	parar(); 
....................  
.................... 	printf("Inicio Mestre:\n\r%d escravos\n\r", nrSlv); 
.................... } 
....................  
.................... void init_slv() { 
.................... //	set_timer0(T0_EXT_H_TO_L | T0_DIV_1); 
.................... //	set_timer1(T1_EXTERNAL | T1_DIV_BY_1); 
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
*
02C4:  BSF    F9D.5
.................... 	enable_interrupts(GLOBAL); 
02C6:  MOVLW  C0
02C8:  IORWF  FF2,F
....................  
.................... 	m_cmd = cmd_parar; 
02CA:  CLRF   23
.................... 	m_addr = getMAddr(); 
02CC:  BRA    0190
02CE:  MOVFF  01,20
....................  
.................... 	parar(); 
02D2:  BRA    01AE
....................  
.................... 	printf("Inicio Escravo:\n\rEndereco: %d\n\r", m_addr); 
02D4:  MOVLW  CC
02D6:  MOVWF  FF6
02D8:  MOVLW  00
02DA:  MOVWF  FF7
02DC:  MOVLW  1B
02DE:  MOVWF  7F
02E0:  BRA    01C6
02E2:  MOVFF  20,7F
02E6:  MOVLW  18
02E8:  MOVWF  x80
02EA:  BRA    0210
02EC:  MOVLW  0A
02EE:  BTFSS  F9E.4
02F0:  BRA    02EE
02F2:  MOVWF  FAD
02F4:  MOVLW  0D
02F6:  BTFSS  F9E.4
02F8:  BRA    02F6
02FA:  MOVWF  FAD
.................... } 
02FC:  GOTO   0A2A (RETURN)
....................  
.................... void trata_cmd(int cmd) { 
.................... 	switch (cmd) { 
.................... 	case cmd_subir: 
.................... 		subir(); 
.................... 		break; 
.................... 	case cmd_descer: 
.................... 		descer(); 
.................... 		break; 
.................... 	case cmd_parar: 
.................... 		parar(); 
.................... 		cmd_parar; 
.................... 		break; 
.................... 	default: 
.................... 	} 
.................... } 
....................  
.................... short recivedOk(int *buff) { 
.................... 	int *p; 
....................  
.................... 	for (p = buff; *p != '\0'; p++) 
*
00EC:  MOVFF  97,99
00F0:  MOVFF  96,98
00F4:  MOVFF  99,03
00F8:  MOVFF  98,FE9
00FC:  MOVFF  99,FEA
0100:  MOVF   FEF,F
0102:  BZ    013C
.................... 		if (*p == '\n' && *(p + 1) == '\r') 
0104:  MOVFF  99,03
0108:  MOVFF  98,FE9
010C:  MOVFF  99,FEA
0110:  MOVF   FEF,W
0112:  SUBLW  0A
0114:  BNZ   0134
0116:  MOVLW  01
0118:  ADDWF  x98,W
011A:  MOVWF  01
011C:  MOVLW  00
011E:  ADDWFC x99,W
0120:  MOVWF  03
0122:  MOVFF  01,FE9
0126:  MOVWF  FEA
0128:  MOVF   FEF,W
012A:  SUBLW  0D
012C:  BNZ   0134
.................... 			return TRUE; 
012E:  MOVLW  01
0130:  MOVWF  01
0132:  BRA    0140
0134:  INCF   x98,F
0136:  BTFSC  FD8.2
0138:  INCF   x99,F
013A:  BRA    00F4
....................  
.................... 	return FALSE; 
013C:  MOVLW  00
013E:  MOVWF  01
.................... } 
0140:  GOTO   017A (RETURN)
....................  
.................... #include "interrupcoes.c" 
.................... /* 
....................  * interrupcoes.c 
....................  * 
....................  *  Created on: 02/09/2014 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #int_rda 
.................... void isr_rda() { 
.................... 	clear_interrupt(INT_RDA); 
.................... 	buffer[line++] = getc(); 
0144:  MOVF   28,W
0146:  INCF   28,F
0148:  CLRF   03
014A:  ADDLW  29
014C:  MOVWF  FE9
014E:  MOVLW  00
0150:  ADDWFC 03,W
0152:  MOVWF  FEA
0154:  BTFSS  F9E.5
0156:  BRA    0154
0158:  MOVFF  FAE,FEF
.................... 	buffer[line] = "\0"; 
015C:  CLRF   03
015E:  MOVF   28,W
0160:  ADDLW  29
0162:  MOVWF  01
0164:  MOVLW  00
0166:  ADDWFC 03,F
0168:  MOVFF  03,FEA
016C:  MOVFF  01,FE9
0170:  CLRF   FEF
.................... 	RxOk = recivedOk(buffer); 
0172:  CLRF   x97
0174:  MOVLW  29
0176:  MOVWF  x96
0178:  BRA    00EC
017A:  BCF    1F.1
017C:  BTFSC  01.0
017E:  BSF    1F.1
.................... 	if (RxOk && line) 
0180:  BTFSS  1F.1
0182:  BRA    018A
0184:  MOVF   28,F
0186:  BZ    018A
.................... 		line = 0; 
0188:  CLRF   28
.................... } 
....................  
....................  
018A:  BCF    F9E.5
018C:  GOTO   0060
.................... int main(void) { 
*
09D0:  CLRF   FF8
09D2:  BCF    FD0.7
09D4:  BSF    07.7
09D6:  MOVLW  FE
09D8:  MOVWF  00
09DA:  MOVLW  06
09DC:  MOVWF  01
09DE:  MOVLW  02
09E0:  MOVWF  FE9
09E2:  MOVLW  00
09E4:  MOVWF  FEA
09E6:  CLRF   FEE
09E8:  DECFSZ 00,F
09EA:  BRA    09E6
09EC:  DECFSZ 01,F
09EE:  BRA    09E6
09F0:  CLRF   FEA
09F2:  CLRF   FE9
09F4:  MOVLW  61
09F6:  MOVWF  FAF
09F8:  MOVLW  A6
09FA:  MOVWF  FAC
09FC:  MOVLW  90
09FE:  MOVWF  FAB
0A00:  SETF   20
0A02:  SETF   21
0A04:  SETF   22
0A06:  SETF   23
0A08:  SETF   24
0A0A:  SETF   25
0A0C:  MOVLW  02
0A0E:  MOVWF  26
0A10:  MOVLW  30
0A12:  MOVWF  3A
0A14:  MOVLW  39
0A16:  MOVWF  39
0A18:  MOVLW  30
0A1A:  MOVWF  3C
0A1C:  MOVLW  39
0A1E:  MOVWF  3B
0A20:  BSF    FC1.0
0A22:  BSF    FC1.1
0A24:  BSF    FC1.2
0A26:  BCF    FC1.3
....................  
.................... 	init_slv(); 
0A28:  BRA    02C4
....................  
.................... 	while (TRUE) { 
....................  
.................... 		if (RxOk) { 
0A2A:  BTFSS  1F.1
0A2C:  BRA    0A32
.................... 			RxOk = FALSE; 
0A2E:  BCF    1F.1
.................... 			trata_comunicacao(); 
0A30:  BRA    096A
.................... 		} 
....................  
.................... 	} 
0A32:  BRA    0A2A
....................  
.................... 	return 0; 
0A34:  MOVLW  00
0A36:  MOVWF  01
.................... } 
0A38:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
